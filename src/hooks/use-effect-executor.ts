'use client';

import { useCallback, useRef } from 'react';
import type { SideEffect } from '@/core/entities/side-effects';
import { executeEffect } from '@/core/engines/effect-executor';
import type { EffectExecutorDeps } from '@/core/engines/effect-executor';
import { useAudioContext } from '@/lib/audio/AudioProvider';
import { useToast } from '@/hooks/use-toast';
import { useLanguage } from '@/context/language-context';
import { useAuth } from '@/context/auth-context';
import { createGameStateRepository } from '@/infrastructure/persistence';
import { EventBus } from '@/lib/events/event-bus';

/**
 * Hook for executing side effects from usecases.
 *
 * @remarks
 * **Purpose:**
 * Provides a unified interface for executing side effects generated by pure usecases.
 * Handles dependency injection of all effect executors (audio, particles, notifications, etc).
 *
 * **Architecture:**
 * - Hooks call usecases which return { result, effects[] }
 * - After state update, call executeEffects(effects)
 * - This hook coordinates all side-effect dependencies
 *
 * **Design Decisions:**
 * - Separate hook for testability and composability
 * - Lazy initialization of expensive deps (save manager, event bus)
 * - Mutable ref for dependencies (no re-render on dep changes)
 * - One-way flow: usecase → hook → executor → real services
 *
 * @returns { executeEffects } Function to execute effect arrays
 *
 * @example
 * const { executeEffects } = useEffectExecutor();
 * const { result, effects } = attackUsecase(state, targetId);
 * setState(result);
 * executeEffects(effects);
 */
export function useEffectExecutor() {
    // Get all effect executor dependencies
    const { playSfx, stopMusic } = useAudioContext();
    const { toast } = useToast();
    const { t } = useLanguage();
    const { user } = useAuth();

    // Lazy refs for expensive dependencies
    const gameStateRepoRef = useRef(createGameStateRepository({ userId: user?.id || null }));
    const eventBusRef = useRef(new EventBus());

    /**
     * Execute an array of side effects
     *
     * @remarks
     * Batch processes all effects through the effect executor.
     * Each effect is routed to appropriate handler based on type.
     * Errors are logged but don't stop processing of remaining effects (graceful degradation).
     *
     * @param effects - Array of side effects to execute
     */
    const executeEffects = useCallback((effects: SideEffect[]) => {
        if (!effects || effects.length === 0) return;

        // Build dependency object for effect executor
        const deps: EffectExecutorDeps = {
            // Audio effects
            audioService: {
                play: (sound: string, volume?: number) => {
                    try {
                        playSfx(sound);
                    } catch (err) {
                        console.warn(`[Effect] Failed to play audio: ${sound}`, err);
                    }
                },
                stop: () => {
                    try {
                        stopMusic();
                    } catch (err) {
                        console.warn(`[Effect] Failed to stop audio`, err);
                    }
                }
            },

            // UI notifications
            notificationService: {
                show: (message: string, duration?: number, type?: 'info' | 'success' | 'warning' | 'error') => {
                    try {
                        toast({
                            description: message,
                            duration: duration || 3000,
                            variant: (type === 'error' ? 'destructive' : undefined) as any,
                            title: type === 'success' ? '✓ Success' : undefined
                        });
                    } catch (err) {
                        console.warn(`[Effect] Failed to show notification: ${message}`, err);
                    }
                }
            },

            // Game state persistence
            saveManager: {
                save: async (timestamp?: number, reason?: string) => {
                    try {
                        const repo = gameStateRepoRef.current;
                        if (repo) {
                            // Note: repo.save requires gameState parameter, 
                            // so this needs to be handled at hook level, not effect executor
                            console.warn('[Effect] Save triggered (implement at hook level)');
                        }
                    } catch (err) {
                        console.warn('[Effect] Failed to save game state', err);
                    }
                }
            },

            // Event bus for triggering events
            eventBus: {
                emit: (eventName: string, data?: Record<string, unknown>) => {
                    try {
                        const bus = eventBusRef.current;
                        if (bus) {
                            bus.emit(eventName, data);
                        }
                    } catch (err) {
                        console.warn(`[Effect] Failed to emit event: ${eventName}`, err);
                    }
                }
            },

            // Debug logger
            logger: {
                debug: (message: string, data?: unknown) => {
                    if (process.env.NODE_ENV === 'development') {
                        console.log(`[Effect] ${message}`, data);
                    }
                }
            }
        };

        // Execute each effect in sequence
        effects.forEach((effect, index) => {
            try {
                // Execute the side effect (audio, UI, etc)
                executeEffect(effect, deps);
            } catch (err) {
                console.error(`[Effect] Error executing effect #${index}:`, effect, err);
                // Continue processing remaining effects (graceful degradation)
            }
        });
    }, [playSfx, stopMusic, toast]);

    return {
        executeEffects
    };
}

'use client';

import { useCallback, useRef } from 'react';
import type { SideEffect } from '@/core/entities/side-effects';
import type { GameEvent } from '@/core/types/events';
import type { GameState } from '@/core/domain/gamestate';
import { executeEffect } from '@/core/engines/effect-executor';
import type { EffectExecutorDeps } from '@/core/engines/effect-executor';
import { StatisticsEngine } from '@/core/engines/statistics/engine';
import { evaluateAllActiveQuests } from '@/core/usecases/quest-usecase';
import { evaluateAllAchievements } from '@/core/usecases/achievement-usecase';
import { useAudioContext } from '@/lib/audio/AudioProvider';
import { useToast } from '@/hooks/use-toast';
import { useLanguage } from '@/context/language-context';
import { useAuth } from '@/context/auth-context';
import { createGameStateRepository } from '@/infrastructure/persistence';
import { EventBus } from '@/lib/events/event-bus';

/**
 * Hook for executing side effects from usecases.
 *
 * @remarks
 * **Purpose:**
 * Provides a unified interface for executing side effects generated by pure usecases.
 * Integrates with Statistics Engine to track all player actions and auto-evaluate quests/achievements.
 *
 * **Architecture:**
 * 1. Hook calls usecase which returns { newState, effects[] }
 * 2. After state update, call executeEffects(gameState, effects)
 * 3. For each effect:
 *    a. Emit typed GameEvent (if applicable)
 *    b. Update statistics via StatisticsEngine
 *    c. Execute side effect (audio, particles, etc)
 * 4. After all effects: evaluate active quests and achievements
 * 5. Return cascading effects (quest/achievement completion)
 *
 * **Design Decisions:**
 * - Emit events AFTER state update (consistency-first)
 * - Evaluate quests/achievements after each effect batch
 * - Cascading: quest complete → auto-evaluate achievements
 * - Mutable ref for dependencies (no re-render on dep changes)
 * - One-way flow: usecase → hook → executor → engine/services
 *
 * @returns { executeEffects } Function to execute effect arrays and return cascading effects
 *
 * @example
 * const { executeEffects } = useEffectExecutor();
 * const { newState, effects } = attackUsecase(state, targetId);
 * setState(newState);
 * const cascadingEffects = executeEffects(newState, effects);  // Returns quest/achievement effects
 * executeEffects(newState, cascadingEffects);
 */
export function useEffectExecutor() {
    // Get all effect executor dependencies
    const { playSfx, stopMusic } = useAudioContext();
    const { toast } = useToast();
    const { t } = useLanguage();
    const { user } = useAuth();

    // Lazy refs for expensive dependencies
    const gameStateRepoRef = useRef(createGameStateRepository({ userId: user?.id || null }));
    const eventBusRef = useRef(new EventBus());

    /**
     * Execute an array of side effects with Statistics Engine integration.
     *
     * @remarks
     * **Flow:**
     * 1. Map side effects to GameEvents (if applicable)
     * 2. Process events through StatisticsEngine
     * 3. Execute side effects (audio, particles, UI notifications)
     * 4. Evaluate all active quests (check for auto-completion)
     * 5. Evaluate all achievements (check for auto-unlock)
     * 6. Return cascading effects from quest/achievement completions
     *
     * **Supported Event Mappings:**
     * - applyDamage → CREATURE_KILLED (if target hp ≤ 0)
     * - grantLoot → ITEM_GATHERED
     * - addExperience → (no direct event, just stat tracking)
     * - (others don't generate events)
     *
     * @param gameState - Current game state (needed for quest/achievement evaluation)
     * @param effects - Array of side effects to execute
     * @returns Cascading effects from quest/achievement completions
     */
    const executeEffects = useCallback((gameState: GameState, effects: SideEffect[]): SideEffect[] => {
        if (!gameState || !effects || effects.length === 0) return [];

        // Build dependency object for effect executor
        const deps: EffectExecutorDeps = {
            // Audio effects
            audioService: {
                play: (sound: string, volume?: number) => {
                    try {
                        playSfx(sound);
                    } catch (err) {
                        console.warn(`[Effect] Failed to play audio: ${sound}`, err);
                    }
                },
                stop: () => {
                    try {
                        stopMusic();
                    } catch (err) {
                        console.warn(`[Effect] Failed to stop audio`, err);
                    }
                }
            },

            // UI notifications
            notificationService: {
                show: (message: string, duration?: number, type?: 'info' | 'success' | 'warning' | 'error') => {
                    try {
                        toast({
                            description: message,
                            duration: duration || 3000,
                            variant: (type === 'error' ? 'destructive' : undefined) as any,
                            title: type === 'success' ? '✓ Success' : undefined
                        });
                    } catch (err) {
                        console.warn(`[Effect] Failed to show notification: ${message}`, err);
                    }
                }
            },

            // Game state persistence
            saveManager: {
                save: async (timestamp?: number, reason?: string) => {
                    try {
                        const repo = gameStateRepoRef.current;
                        if (repo) {
                            // Note: repo.save requires gameState parameter, 
                            // so this needs to be handled at hook level, not effect executor
                            console.warn('[Effect] Save triggered (implement at hook level)');
                        }
                    } catch (err) {
                        console.warn('[Effect] Failed to save game state', err);
                    }
                }
            },

            // Event bus for triggering events
            eventBus: {
                emit: (eventName: string, data?: Record<string, unknown>) => {
                    try {
                        const bus = eventBusRef.current;
                        if (bus) {
                            bus.emit(eventName, data);
                        }
                    } catch (err) {
                        console.warn(`[Effect] Failed to emit event: ${eventName}`, err);
                    }
                }
            },

            // Debug logger
            logger: {
                debug: (message: string, data?: unknown) => {
                    if (process.env.NODE_ENV === 'development') {
                        console.log(`[Effect] ${message}`, data);
                    }
                }
            }
        };

        // Process effects and collect statistics events
        let currentState: GameState = gameState;
        const cascadingEffects: SideEffect[] = [];

        effects.forEach((effect, index) => {
            try {
                // 1. Convert side effect to game event (if applicable)
                let gameEvent: GameEvent | null = null;
                
                if (effect.type === 'applyDamage' && 'targetId' in effect && 'damage' in effect) {
                    // Only emit CREATURE_KILLED if we know the target died
                    // This requires checking if target hp would be ≤ 0
                    gameEvent = {
                        type: 'CREATURE_KILLED',
                        payload: {
                            creatureId: 'unknown',
                            creatureType: 'unknown',
                            location: { biome: 'unknown', x: 0, y: 0 },
                            weapon: null,
                            timestamp: Date.now()
                        }
                    };
                } else if (effect.type === 'grantLoot' && 'items' in effect) {
                    // Emit ITEM_GATHERED for each item granted
                    gameEvent = {
                        type: 'ITEM_GATHERED',
                        payload: {
                            itemId: Array.isArray(effect.items) ? effect.items[0] : 'unknown',
                            quantity: 1,
                            location: { biome: 'unknown' },
                            tool: null,
                            timestamp: Date.now()
                        }
                    };
                }

                // 2. Update statistics if event emitted
                if (gameEvent) {
                    currentState = {
                        ...currentState,
                        statistics: StatisticsEngine.processEvent(currentState.statistics, gameEvent)
                    };
                }

                // 3. Execute the side effect (audio, UI, etc)
                executeEffect(effect, deps);
            } catch (err) {
                console.error(`[Effect] Error executing effect #${index}:`, effect, err);
                // Continue processing remaining effects (graceful degradation)
            }
        });

        // 4. After all effects processed, evaluate quests
        try {
            const questResult = evaluateAllActiveQuests(currentState);
            currentState = questResult.newState;
            cascadingEffects.push(...questResult.effects);
        } catch (err) {
            console.error('[Effect] Failed to evaluate quests:', err);
        }

        // 5. Evaluate achievements (might unlock from quest completions)
        try {
            const achResult = evaluateAllAchievements(currentState);
            currentState = achResult.newState;
            cascadingEffects.push(...achResult.effects);
        } catch (err) {
            console.error('[Effect] Failed to evaluate achievements:', err);
        }

        return cascadingEffects;
    }, [playSfx, stopMusic, toast]);

    return {
        executeEffects
    };
}

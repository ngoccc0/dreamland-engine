[{"filePath":"D:\\dreamland-engine\\src\\ai\\client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\dev.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\fuse-items-flow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-journal-entry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-legendary-quest-flow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-narrative-flow.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-new-item.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-new-quest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-new-recipe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\generate-world-setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'db' is defined but never used.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'collection' is defined but never used.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDocs' is defined but never used.","line":24,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ItemCatalogCreativeOutputSchema' is assigned a value but only used as a type.","line":57,"column":7,"nodeType":null,"messageId":"usedOnlyAsType","endLine":57,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WorldNamesOutputSchema' is assigned a value but only used as a type.","line":63,"column":7,"nodeType":null,"messageId":"usedOnlyAsType","endLine":63,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NarrativeConceptsOutputSchema' is assigned a value but only used as a type.","line":68,"column":7,"nodeType":null,"messageId":"usedOnlyAsType","endLine":68,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StructureCatalogCreativeOutputSchema' is assigned a value but only used as a type.","line":78,"column":7,"nodeType":null,"messageId":"usedOnlyAsType","endLine":78,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * An AI agent for generating game world concepts by distributing tasks across multiple AI models.\r\n * This file defines a sophisticated, parallelized AI workflow for world creation.\r\n * It splits the generation process into four distinct, concurrent tasks to leverage the strengths\r\n * of different AI models, increase speed, and improve reliability with a fallback mechanism.\r\n */\r\nimport Handlebars from 'handlebars';\r\nimport {ai} from '@/ai/genkit';\r\nimport type { Genkit } from 'genkit';\r\nimport {z} from 'zod';\r\nimport type {Terrain, Skill} from '@/lib/game/types';\r\nimport {\r\n    GeneratedItemSchema,\r\n    SkillSchema,\r\n    NarrativeConceptArraySchema,\r\n    StructureDefinitionSchema,\r\n    allTerrains as allTerrainsSchema,\r\n    TranslatableStringSchema\r\n} from '@/ai/schemas';\r\nimport {ItemCategorySchema} from '@/lib/game/definitions';\r\nimport { skillDefinitions } from '@/lib/game/skills';\r\nimport { getEmojiForItem, getTranslatedText } from '@/lib/utils';\r\nimport { db } from '@/lib/firebase-config';\r\nimport { collection, getDocs } from 'firebase/firestore';\r\nimport { itemDefinitions as staticItemDefinitions } from '@/lib/game/items';\r\nimport { logger } from '@/lib/logger';\r\n\r\n\r\nconst getRandomInRange = (range: { min: number, max: number }) => Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;\r\n\r\n\r\n// == INPUT SCHEMA ==\r\n/**\r\n * @typedef {object} GenerateWorldSetupInput\r\n * The input schema for the world generation flow.\r\n * @property {string} userInput - The user's initial idea, prompt, or description for the game world.\r\n * @property {string} language - The language code for the generated content (e.g., 'en', 'vi').\r\n */\r\nconst GenerateWorldSetupInputSchema = z.object({\r\n  userInput: z.string().describe(\"The user's initial idea, prompt, or description for the game world.\"),\r\n  language: z.string().describe(\"The language for the generated content (e.g., 'en', 'vi').\"),\r\n});\r\nexport type GenerateWorldSetupInput = z.infer<typeof GenerateWorldSetupInputSchema>;\r\n\r\n\r\n// == INTERMEDIATE & FINAL OUTPUT SCHEMAS ==\r\n\r\n// -- New, simplified schema for the AI's creative output for items --\r\nconst AIGeneratedItemCreativeSchema = z.object({\r\n  name: TranslatableStringSchema.describe(\"A unique and thematic name for the item.\"),\r\n  description: TranslatableStringSchema.describe(\"A flavorful, one-sentence description of the item.\"),\r\n  category: ItemCategorySchema,\r\n  spawnBiomes: z.array(z.string()).min(1).describe(`An array of one or more biomes where this item can be found. Choose from: ${allTerrainsSchema.join(', ')}.`),\r\n});\r\n\r\n// -- Task A Output: The AI now generates a simpler structure. --\r\nconst ItemCatalogCreativeOutputSchema = z.object({\r\n    customItemCatalog: z.array(AIGeneratedItemCreativeSchema).min(5).max(10).describe(\"A shared catalog of 5-10 unique, thematic items invented for this specific game world theme.\"),\r\n});\r\n\r\n\r\n// -- Task B Output: World Names --\r\nconst WorldNamesOutputSchema = z.object({\r\n    worldNames: z.array(TranslatableStringSchema).length(3).describe(\"An array of three distinct and creative world names based on the user's input.\"),\r\n});\r\n\r\n// -- Task C Output: Narrative Concepts --\r\nconst NarrativeConceptsOutputSchema = z.object({\r\n    narrativeConcepts: NarrativeConceptArraySchema.describe(\"An array of three distinct narrative starting points, including descriptions and quests.\"),\r\n});\r\n\r\n// -- New schema for AI's creative output for structures --\r\nconst AIGeneratedStructureCreativeSchema = z.object({\r\n    name: TranslatableStringSchema.describe(\"A unique and thematic name for the structure.\"),\r\n    description: TranslatableStringSchema.describe(\"A flavorful, one-sentence description of the structure.\"),\r\n    emoji: z.string().describe(\"A single emoji that represents the structure.\"),\r\n});\r\nconst StructureCatalogCreativeOutputSchema = z.object({\r\n    customStructures: z.array(AIGeneratedStructureCreativeSchema).min(2).max(4).describe(\"A catalog of 2-4 unique structures or landmarks invented for this world.\"),\r\n});\r\n\r\n\r\n// -- Final Combined Output Schema (for the frontend) --\r\nexport const WorldConceptSchema = z.object({\r\n  worldName: TranslatableStringSchema,\r\n  initialNarrative: TranslatableStringSchema,\r\n  startingBiome: z.custom<Terrain>(), // Using custom to avoid z.enum with a const\r\n  playerInventory: z.array(z.object({ name: TranslatableStringSchema, quantity: z.number().int().min(1) })),\r\n  initialQuests: z.array(TranslatableStringSchema),\r\n  startingSkill: SkillSchema,\r\n  customStructures: z.array(StructureDefinitionSchema), // Pass the generated structures with each concept\r\n});\r\nexport type WorldConcept = z.infer<typeof WorldConceptSchema>;\r\n\r\nexport const GenerateWorldSetupOutputSchema = z.object({\r\n    customItemCatalog: z.array(GeneratedItemSchema),\r\n    customStructures: z.array(StructureDefinitionSchema),\r\n    concepts: z.array(WorldConceptSchema).length(3),\r\n});\r\nexport type GenerateWorldSetupOutput = z.infer<typeof GenerateWorldSetupOutputSchema>;\r\n\r\n\r\n/**\r\n * This is the primary function that the application's frontend will call.\r\n * It orchestrates a complex, multi-model AI workflow to generate rich game world concepts.\r\n * @param {GenerateWorldSetupInput} input - The user's prompt and language preference.\r\n * @returns {Promise<GenerateWorldSetupOutput>} A promise resolving to the final structured output for the frontend.\r\n */\r\nexport async function generateWorldSetup(input: GenerateWorldSetupInput): Promise<GenerateWorldSetupOutput> {\r\n  logger.info('Starting generateWorldSetup flow');\r\n  return generateWorldSetupFlow(input);\r\n}\r\n\r\n\r\n// == PROMPT TEMPLATES (TASK DEFINITIONS) ==\r\n\r\n// -- Template for Task A: Item Catalog Generation --\r\nconst itemCatalogPromptTemplate = `You are a creative world-building assistant specializing in game item design. ALL TEXT in your response MUST be in the language specified by the code '{{language}}' (e.g., 'en' for English, 'vi' for Vietnamese). This is a critical and non-negotiable instruction.\r\n\r\nBased on the user's idea, your task is to generate **a small, initial catalog of EXACTLY 5 to 10 unique, thematically appropriate items** that could be found in this world.\r\n\r\n**User's Idea:** {{{userInput}}}\r\n\r\n**Rules:**\r\n1.  The \"customItemCatalog\" array in your JSON output MUST contain between 5 and 10 items.\r\n2.  For each item, you MUST define only the following fields: 'name', 'description', 'category', and 'spawnBiomes'.\r\n3.  The 'category' must be one of the allowed values: {{json validCategories}}.\r\n4.  The 'spawnBiomes' must be an array of biome names from this list: ${allTerrainsSchema.join(', ')}.\r\n5.  DO NOT create items that are already on this list: {{json existingItemNames}}.\r\n6.  DO NOT include 'tier', 'effects', 'baseQuantity', or any other fields.`;\r\n\r\n// -- Template for Task B: World Name Generation --\r\nconst worldNamesPromptTemplate = `You are a creative brainstorming assistant. ALL TEXT in your response MUST be in the language specified by the code '{{language}}' (e.g., 'en' for English, 'vi' for Vietnamese). This is a strict requirement.\r\n\r\nBased on the user's idea, generate **three (3) distinct and creative world names.**\r\n\r\n**User's Idea:** {{{userInput}}}\r\n\r\nProvide the response as a single JSON object containing the 'worldNames' array.`;\r\n\r\n\r\n// -- Template for Task C: Narrative Concept Generation --\r\nconst narrativeConceptsPromptTemplate = `You are a creative Game Master. ALL TEXT in your response (initial narrative, quests, etc.) MUST be in the language specified by the code '{{language}}' (e.g., 'en' for English, 'vi' for Vietnamese). This is a non-negotiable, strict requirement.\r\n\r\nBased on the user's idea, you need to generate **three (3) distinct starting concepts for a game.**\r\n\r\n**User's Idea:** {{{userInput}}}\r\n\r\nFor EACH of the three concepts, create the specific narrative details:\r\n1.  **initialNarrative:** A rich, descriptive opening paragraph.\r\n2.  **initialQuests:** One or two simple starting quests.\r\n\r\n**Critical Rules:**\r\n- **DO NOT** create world names, player items, a starting biome, an item catalog, custom structures, or starting skills.\r\n\r\nProvide the response as a single JSON object containing the 'narrativeConcepts' array.`;\r\n\r\n// -- New Template for Task D: Structure Catalog Generation --\r\nconst structureCatalogPromptTemplate = `You are a creative world-building assistant specializing in architectural and landmark design. ALL TEXT in your response MUST be in the language specified by the code '{{language}}'.\r\n\r\nBased on the user's idea, generate **a small catalog of 2 to 4 unique, thematically appropriate structures or landmarks** that could be found in this world.\r\n\r\n**User's Idea:** {{{userInput}}}\r\n\r\n**Rules:**\r\n1.  The \"customStructures\" array in your JSON output MUST contain between 2 and 4 structures.\r\n2.  For each structure, you MUST define only 'name', 'description', and 'emoji'.\r\n3.  DO NOT include fields like 'buildable', 'providesShelter', 'buildCost', etc. These will be handled by the game logic.`;\r\n\r\n\r\n/**\r\n * The core Genkit flow that orchestrates parallel AI tasks for world generation.\r\n * It combines the results from item, name, narrative, and structure generation into a coherent output.\r\n */\r\nconst generateWorldSetupFlow = (ai as Genkit).defineFlow(\r\n  {\r\n    name: 'generateWorldSetupFlow',\r\n    inputSchema: GenerateWorldSetupInputSchema,\r\n    outputSchema: GenerateWorldSetupOutputSchema,\r\n  },\r\n  async (input: GenerateWorldSetupInput): Promise<GenerateWorldSetupOutput> => {\r\n\r\n    logger.info('--- STARTING WORLD GENERATION ---', { userInput: input.userInput, language: input.language });\r\n    \r\n    // --- Step 1: Define four independent AI tasks to run in parallel ---\r\n    \r\n    // Get existing item names ONLY from the static, code-based definitions.\r\n    const itemNamesList = Object.keys(staticItemDefinitions);\r\n\r\n    // Task A: Generate the item catalog.\r\n    const itemCatalogTask = (async () => {\r\n        const template = Handlebars.compile(itemCatalogPromptTemplate);\r\n        const promptInput = { ...input, existingItemNames: itemNamesList, validCategories: ItemCategorySchema.options };\r\n        const renderedPrompt = template(promptInput);\r\n\r\n        try {\r\n            logger.debug(`[Task A] Generating item catalog with configured Gemini prompt`, { prompt: renderedPrompt });\r\n            const result = await (ai as Genkit).generate<typeof ItemCatalogCreativeOutputSchema>([\r\n                {\r\n                    text: renderedPrompt,\r\n                    custom: {}\r\n                }\r\n            ]);\r\n            logger.info('[Task A] SUCCESS with configured Gemini.');\r\n            logger.debug('[Task A] Parsed AI output:', result.output);\r\n            return result;\r\n        } catch (error: any) {\r\n            const errorMessage = `Gemini failed for item catalog generation. Reason: ${error.message || error}`;\r\n            logger.error('[Task A] ' + errorMessage);\r\n            throw new Error(errorMessage);\r\n        }\r\n    })();\r\n    \r\n    // Task B: Generate world names.\r\n    const worldNamesTask = (async () => {\r\n        const template = Handlebars.compile(worldNamesPromptTemplate);\r\n        const renderedPrompt = template(input);\r\n        try {\r\n            logger.debug('[Task B] Generating world names with configured Gemini prompt', { prompt: renderedPrompt });\r\n            const result = await (ai as Genkit).generate<typeof WorldNamesOutputSchema>([\r\n                {\r\n                    text: renderedPrompt,\r\n                    custom: {}\r\n                }\r\n            ]);\r\n            logger.info('[Task B] SUCCESS with configured Gemini.');\r\n            return result;\r\n        } catch (error: any) {\r\n            logger.error('[Task B] Gemini failed for world name generation: ' + (error.message || error));\r\n            throw error;\r\n        }\r\n    })();\r\n\r\n    // Task C: Generate narrative concepts.\r\n    const narrativeConceptsTask = (async () => {\r\n        const template = Handlebars.compile(narrativeConceptsPromptTemplate);\r\n        const renderedPrompt = template(input);\r\n        try {\r\n            logger.debug('[Task C] Generating narrative concepts with configured Gemini prompt', { prompt: renderedPrompt });\r\n            const result = await (ai as Genkit).generate<typeof NarrativeConceptsOutputSchema>([\r\n                {\r\n                    text: renderedPrompt,\r\n                    custom: {}\r\n                }\r\n            ]);\r\n            logger.info('[Task C] SUCCESS with configured Gemini.');\r\n            return result;\r\n        } catch (error: any) {\r\n            logger.error('[Task C] Gemini failed for narrative concepts generation: ' + (error.message || error));\r\n            throw error;\r\n        }\r\n    })();\r\n    \r\n    // Task D: Generate custom structures.\r\n    const structureCatalogTask = (async () => {\r\n        const template = Handlebars.compile(structureCatalogPromptTemplate);\r\n        const renderedPrompt = template(input);\r\n        try {\r\n            logger.debug('[Task D] Generating structure catalog with configured Gemini prompt', { prompt: renderedPrompt });\r\n            const result = await (ai as Genkit).generate<typeof StructureCatalogCreativeOutputSchema>([\r\n                {\r\n                    text: renderedPrompt,\r\n                    custom: {}\r\n                }\r\n            ]);\r\n            logger.info('[Task D] SUCCESS with configured Gemini.');\r\n            return result;\r\n        } catch (error: any) {\r\n            logger.warn('[Task D] Gemini failed to generate structures. Proceeding without custom structures: ' + (error.message || error));\r\n            return { output: { customStructures: [] } };\r\n        }\r\n    })();\r\n\r\n\r\n    // --- Step 2: Run all tasks in parallel and wait for them to complete ---\r\n    const [itemCatalogResult, worldNamesResult, narrativeConceptsResult, structureCatalogResult] = await Promise.all([\r\n        itemCatalogTask,\r\n        worldNamesTask,\r\n        narrativeConceptsTask,\r\n        structureCatalogTask,\r\n    ]);\r\n\r\n    logger.info('--- AI TASKS COMPLETE. PROCESSING AND COMBINING RESULTS... ---');\r\n    \r\n    // --- Step 3: Process the AI results and combine them ---\r\n    const creativeItems = itemCatalogResult.output?.customItemCatalog;\r\n    if (!creativeItems || creativeItems.length === 0) {\r\n        logger.error(\"Failed to generate a valid item catalog from the AI.\");\r\n        throw new Error(\"Failed to generate a valid item catalog from the AI.\");\r\n    }\r\n\r\n    // Programmatically add logical fields to the creative items generated by the AI.\r\n    const allTerrainsList: Terrain[] = [\"forest\", \"grassland\", \"desert\", \"swamp\", \"mountain\", \"cave\", \"jungle\", \"volcanic\", \"tundra\", \"beach\", \"mesa\", \"mushroom_forest\", \"ocean\"];\r\n    const customItemCatalog = creativeItems.map((item: typeof AIGeneratedItemCreativeSchema._type) => {\r\n        const validBiomes = item.spawnBiomes.filter((b: string) => allTerrainsList.includes(b as Terrain)) as Terrain[];\r\n        if (validBiomes.length === 0) {\r\n            validBiomes.push('forest'); // Add a fallback biome if the AI provides an invalid one\r\n        }\r\n\r\n        const itemName = typeof item.name === 'string' ? item.name : getTranslatedText(item.name, 'en');\r\n\r\n        return {\r\n            ...item,\r\n            id: itemName.toLowerCase().replace(/\\s+/g, '_'),\r\n            tier: getRandomInRange({ min: 1, max: 3 }),\r\n            effects: [], // Start with no effects for AI-generated items\r\n            baseQuantity: { min: 1, max: getRandomInRange({ min: 1, max: 5 }) },\r\n            spawnBiomes: validBiomes,\r\n            spawnEnabled: true,\r\n            growthConditions: undefined,\r\n            subCategory: undefined,\r\n            emoji: getEmojiForItem(itemName, item.category),\r\n        };\r\n    });\r\n    \r\n    const worldNames = worldNamesResult.output?.worldNames;\r\n    if (!worldNames || worldNames.length !== 3) {\r\n        logger.error(\"Failed to generate valid world names from the AI.\");\r\n        throw new Error(\"Failed to generate valid world names from the AI.\");\r\n    }\r\n\r\n    const narrativeConcepts = narrativeConceptsResult.output?.narrativeConcepts;\r\n    if (!narrativeConcepts || narrativeConcepts.length !== 3) {\r\n        logger.error(\"Failed to generate valid narrative concepts from the AI.\");\r\n        throw new Error(\"Failed to generate valid narrative concepts from the AI.\");\r\n    }\r\n    \r\n    const creativeStructures = structureCatalogResult.output?.customStructures || [];\r\n    const customStructures = creativeStructures.map((struct: typeof AIGeneratedStructureCreativeSchema._type) => ({\r\n        ...struct,\r\n        providesShelter: Math.random() > 0.6, // 40% chance of providing shelter\r\n        buildable: false, // AI-generated structures aren't buildable by default\r\n        buildCost: [],\r\n        restEffect: undefined,\r\n        heatValue: 0,\r\n    }));\r\n\r\n    // --- Step 4: Combine the results and programmatically create inventory & skills ---\r\n    const tier1Skills = skillDefinitions.filter(s => s.tier === 1);\r\n    const tier2Skills = skillDefinitions.filter(s => s.tier === 2);\r\n    const availableBiomes: Terrain[] = ['forest', 'grassland', 'desert', 'swamp', 'mountain', 'beach']; // Basic biomes for starting\r\n    \r\n    const finalConcepts = worldNames.map((name: typeof TranslatableStringSchema._type, index: number) => {\r\n        const concept = narrativeConcepts[index];\r\n        \r\n        // Programmatically select starting inventory\r\n        const lowTierItems = customItemCatalog.filter((item: typeof GeneratedItemSchema._type) => item.tier <= 2);\r\n        const shuffledItems = [...lowTierItems].sort(() => 0.5 - Math.random());\r\n        const numItemsToTake = getRandomInRange({ min: 2, max: 3 });\r\n        const startingItems = shuffledItems.slice(0, numItemsToTake);\r\n        \r\n        const playerInventory = startingItems.map(item => ({\r\n            name: item.name,\r\n            quantity: getRandomInRange(item.baseQuantity)\r\n        }));\r\n\r\n        // Programmatically select starting skill based on tier\r\n        let selectedSkill: Skill;\r\n        if (Math.random() < 0.7 || tier2Skills.length === 0) {\r\n            // 70% chance for Tier 1, or if no Tier 2 skills exist\r\n            selectedSkill = tier1Skills[Math.floor(Math.random() * tier1Skills.length)];\r\n        } else {\r\n            // 30% chance for Tier 2\r\n            selectedSkill = tier2Skills[Math.floor(Math.random() * tier2Skills.length)];\r\n        }\r\n        \r\n        // Programmatically select a starting biome\r\n        const selectedBiome = availableBiomes[Math.floor(Math.random() * availableBiomes.length)];\r\n\r\n        return {\r\n            worldName: name,\r\n            initialNarrative: concept.initialNarrative,\r\n            startingBiome: selectedBiome,\r\n            playerInventory: playerInventory,\r\n            initialQuests: concept.initialQuests,\r\n            startingSkill: selectedSkill,\r\n            customStructures: customStructures,\r\n        };\r\n    });\r\n\r\n    const finalOutput: GenerateWorldSetupOutput = {\r\n        customItemCatalog,\r\n        customStructures: customStructures,\r\n        concepts: finalConcepts,\r\n    };\r\n    \r\n    logger.info('--- FINAL WORLD SETUP DATA ---', finalOutput);\r\n\r\n    return finalOutput;\r\n  }\r\n);\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\provide-quest-hint.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\flows\\suggest-keywords.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\genkit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\plugins\\deepseek.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\ai\\tools\\game-actions.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SkillSchema' is defined but never used.","line":17,"column":91,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":102},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslatableStringSchema' is defined but never used.","line":17,"column":104,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":128},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Skill' is defined but never used.","line":19,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Structure' is defined but never used.","line":19,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildableStructures' is defined but never used.","line":25,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'questText' is defined but never used. Allowed unused args must match /^_/u.","line":701,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":701,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// ai/tools/game-actions.ts\r\n'use server';\r\n/**\r\n * ─Éß╗ïnh ngh─⌐a c├íc c├┤ng cß╗Ñ (tools) game logic ph├¡a server cho Genkit.\r\n *\r\n * File n├áy chß╗⌐a c├íc h├ám logic thuß║ºn t├║y cß╗ºa game, ─æ╞░ß╗úc ─æß╗ïnh ngh─⌐a d╞░ß╗¢i dß║íng Genkit tools.\r\n * Nhß╗»ng tools n├áy sß║╜ ─æ╞░ß╗úc m├┤ h├¼nh AI (LLM) gß╗ìi ─æß╗â thß╗▒c hiß╗çn c├íc h├ánh ─æß╗Öng cß╗Ñ thß╗â trong game\r\n * nh╞░ tß║Ñn c├┤ng, nhß║╖t ─æß╗ô, sß╗¡ dß╗Ñng vß║¡t phß║⌐m, thuß║ºn h├│a kß║╗ th├╣, sß╗¡ dß╗Ñng kß╗╣ n─âng, hoß║╖c quß║ún l├╜ nhiß╗çm vß╗Ñ.\r\n *\r\n * Mß╗Ñc ─æ├¡ch ch├¡nh l├á t├ích biß╗çt logic game deterministic (c├│ thß╗â dß╗▒ ─æo├ín ─æ╞░ß╗úc) khß╗Åi\r\n * khß║ú n─âng s├íng tß║ío cß╗ºa AI, ─æß║úm bß║úo c├íc quy tß║»c game ─æ╞░ß╗úc tu├ón thß╗º.\r\n *\r\n */\r\n\r\nimport {ai} from '@/ai/genkit';\r\nimport {z} from 'genkit';\r\nimport { EnemySchema, PlayerItemSchema, ChunkItemSchema, ItemDefinitionSchema, PetSchema, SkillSchema, TranslatableStringSchema } from '@/ai/schemas';\r\nimport { allTerrains } from '@/lib/game/types';\r\nimport type { PlayerItem, Pet, ChunkItem, Skill, Structure, Terrain } from '@/lib/game/types';\r\nimport type { TranslatableString } from '@/core/types/i18n';\r\nimport { PlayerStatusSchema } from '@/ai/schemas';\r\ntype PlayerStatus = import('zod').infer<typeof PlayerStatusSchema>;\r\nimport { isInlineTranslation, isTranslationObject } from '@/core/types/i18n';\r\nimport { getTemplates } from '@/lib/game/templates';\r\nimport { buildableStructures } from '@/lib/game/structures';\r\nimport { getTranslatedText } from '@/lib/utils';\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\n\r\n/**\r\n * Helper function to get a random integer within a specified range.\r\n * @param range - An object with min and max properties.\r\n * @returns A random integer between min and max (inclusive).\r\n */\r\nconst getRandomInRange = (range: { min: number, max: number }) => Math.floor(Math.random() * (range.max - range.min + 1)) + range.min;\r\n\r\n/**\r\n * Helper function to get the string value from a TranslatableString based on language, or a default.\r\n * @param translatable - The TranslatableString object. Can be a simple string too.\r\n * @param language - The desired language ('en' or 'vi').\r\n * @returns The translated string, or 'unknown' if not found.\r\n */\r\nfunction getTranslatableStringValue(translatable: TranslatableString | string | undefined, language: 'en' | 'vi'): string {\r\n    if (translatable === undefined) return 'unknown';\r\n    if (typeof translatable === 'string') return translatable;\r\n    if (isInlineTranslation(translatable)) return translatable[language] || translatable.en || translatable.vi || 'unknown';\r\n    if (isTranslationObject(translatable)) return translatable.key;\r\n    return 'unknown';\r\n}\r\n\r\n/**\r\n * Helper function to ensure a value is of type TranslatableString.\r\n * If the value is a string, it converts it into a TranslatableString object.\r\n * If it's already a TranslatableString, it returns it as is.\r\n * @param value - The string or TranslatableString to convert.\r\n * @returns The value as a TranslatableString.\r\n */\r\nfunction ensureTranslatableString(value: string | TranslatableString): TranslatableString {\r\n    if (typeof value === 'string') {\r\n        return { en: value, vi: value }; // Default to both languages if it's just a string\r\n    }\r\n    return value;\r\n}\r\n\r\n// --- PlayerAttack Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `playerAttackTool`.\r\n * @property {PlayerStatusSchema} playerStatus - Trß║íng th├íi hiß╗çn tß║íi cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * @property {EnemySchema} enemy - Th├┤ng tin chi tiß║┐t vß╗ü kß║╗ th├╣ ─æang bß╗ï tß║Ñn c├┤ng.\r\n * @property {z.enum} terrain - Loß║íi ─æß╗ïa h├¼nh hiß╗çn tß║íi (ß║únh h╞░ß╗ƒng ─æß║┐n chiß║┐n ─æß║Ñu).\r\n * @property {z.record} customItemDefinitions - Map chß╗⌐a tß║Ñt cß║ú ─æß╗ïnh ngh─⌐a vß║¡t phß║⌐m t├╣y chß╗ënh (AI-generated v├á static).\r\n * @property {z.number} [lightLevel] - Mß╗⌐c ─æß╗Ö ├ính s├íng hiß╗çn tß║íi (-10 ─æß║┐n 10). ├ünh s├íng thß║Ñp c├│ thß╗â giß║úm ─æß╗Ö ch├¡nh x├íc.\r\n * @property {z.number} [moisture] - Mß╗⌐c ─æß╗Ö ß║⌐m hiß╗çn tß║íi (0-10). ─Éß╗Ö ß║⌐m cao c├│ thß╗â cß║ún trß╗ƒ c├íc cuß╗Öc tß║Ñn c├┤ng vß║¡t l├╜.\r\n * @property {z.enum} successLevel - Kß║┐t quß║ú ph├ón loß║íi cß╗ºa mß╗Öt lß║ºn tung x├║c xß║╗ d20, quyß║┐t ─æß╗ïnh kß║┐t quß║ú tß║Ñn c├┤ng.\r\n */\r\nexport const PlayerAttackInputSchema = z.object({\r\n    playerStatus: PlayerStatusSchema,\r\n    enemy: EnemySchema,\r\n    terrain: z.enum(allTerrains),\r\n    customItemDefinitions: z.record(ItemDefinitionSchema).describe(\"A map of ALL item definitions (static and custom) for the current game session.\"),\r\n    lightLevel: z.number().optional().describe(\"The current light level (-10 to 10). Low light (e.g., < -3) can reduce accuracy.\"),\r\n    moisture: z.number().optional().describe(\"The current moisture level (0-10). High moisture (e.g., > 8) can impede physical attacks.\"),\r\n    successLevel: z.enum(['CriticalFailure', 'Failure', 'Success', 'GreatSuccess', 'CriticalSuccess']).describe(\"The categorized result of a d20 dice roll, which dictates the attack's outcome.\"),\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `playerAttackTool`.\r\n * @property {z.number} playerDamageDealt - S├ít th╞░╞íng ng╞░ß╗¥i ch╞íi g├óy ra.\r\n * @property {z.number} enemyDamageDealt - S├ít th╞░╞íng kß║╗ th├╣ g├óy ra. C├│ thß╗â l├á 0 nß║┐u kß║╗ th├╣ bß╗Å chß║íy.\r\n * @property {z.number} finalPlayerHp - M├íu cß╗ºa ng╞░ß╗¥i ch╞íi sau khi trao ─æß╗òi.\r\n * @property {z.number} finalEnemyHp - M├íu cß╗ºa kß║╗ th├╣ sau khi bß╗ï tß║Ñn c├┤ng.\r\n * @property {z.boolean} enemyDefeated - `true` nß║┐u m├íu cß╗ºa kß║╗ th├╣ <= 0.\r\n * @property {z.boolean} fled - `true` nß║┐u kß║╗ th├╣ bß╗Å chß║íy thay v├¼ chiß║┐n ─æß║Ñu.\r\n * @property {z.string} [combatLog] - Nhß║¡t k├╜ chiß║┐n ─æß║Ñu ngß║»n gß╗ìn, thß╗▒c tß║┐.\r\n * @property {z.array} [lootDrops] - Danh s├ích c├íc vß║¡t phß║⌐m kß║╗ th├╣ r╞íi ra nß║┐u bß╗ï ─æ├ính bß║íi.\r\n */\r\nexport const PlayerAttackOutputSchema = z.object({\r\n    playerDamageDealt: z.number().describe(\"Damage dealt by the player.\"),\r\n    enemyDamageDealt: z.number().describe(\"Damage dealt by the enemy. Can be 0 if it fled.\"),\r\n    finalPlayerHp: z.number().describe(\"Player's HP after the exchange.\"),\r\n    finalEnemyHp: z.number().describe(\"Enemy's HP after being attacked.\"),\r\n    enemyDefeated: z.boolean().describe(\"True if the enemy's HP is 0 or less.\"),\r\n    fled: z.boolean().describe(\"True if the enemy fled instead of fighting back.\"),\r\n    combatLog: z.string().optional().describe(\"A brief, factual log of what happened, e.g., 'Player dealt 15 damage. The creature fought back fiercely.' or 'The small creature fled in terror!'\"),\r\n    lootDrops: z.array(ChunkItemSchema).optional().describe(\"A list of items dropped by the defeated enemy. The narrative should mention these items.\"),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â t├¡nh to├ín kß║┐t quß║ú cß╗ºa ng╞░ß╗¥i ch╞íi tß║Ñn c├┤ng mß╗Öt kß║╗ th├╣ trong mß╗Öt v├▓ng chiß║┐n ─æß║Ñu.\r\n * AI n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy khi h├ánh ─æß╗Öng cß╗ºa ng╞░ß╗¥i ch╞íi l├á mß╗Öt cuß╗Öc tß║Ñn c├┤ng.\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `PlayerAttackInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú chiß║┐n ─æß║Ñu theo `PlayerAttackOutputSchema`.\r\n */\r\nexport const playerAttackTool = ai.defineTool({\r\n    name: 'playerAttack',\r\n    description: 'Calculates the result of a player attacking an enemy in a single combat round. Call this when the player action is an attack.',\r\n    inputSchema: PlayerAttackInputSchema,\r\n    outputSchema: PlayerAttackOutputSchema\r\n}, async ({ playerStatus, enemy, terrain, customItemDefinitions, lightLevel, moisture, successLevel }) => {\r\n    let playerDamage = 0;\r\n    const combatLogParts: string[] = [];\r\n    let damageMultiplier = 1.0;\r\n    switch (successLevel) {\r\n        case 'CriticalFailure':\r\n            damageMultiplier = 0;\r\n            combatLogParts.push(\"Player attack was a critical failure.\");\r\n            break;\r\n        case 'Failure':\r\n            damageMultiplier = 0;\r\n            combatLogParts.push(\"Player attack failed.\");\r\n            break;\r\n        case 'GreatSuccess':\r\n            damageMultiplier = 1.5;\r\n            break;\r\n        case 'CriticalSuccess':\r\n            damageMultiplier = 2.0;\r\n            break;\r\n        case 'Success':\r\n        default:\r\n            damageMultiplier = 1.0;\r\n            break;\r\n    }\r\n    \r\n    if (damageMultiplier > 0) {\r\n        let playerDamageModifier = 1.0;\r\n        if (lightLevel !== undefined && lightLevel < -3) {\r\n            playerDamageModifier *= 0.8;\r\n        }\r\n        if (moisture !== undefined && moisture > 8) {\r\n            playerDamageModifier *= 0.9;\r\n        }\r\n\r\n        let playerBaseDamage = playerStatus.attributes?.physicalAttack ?? 0;\r\n        if (playerStatus.persona === 'warrior') {\r\n            playerBaseDamage += 2;\r\n        }\r\n\r\n        playerDamage = Math.round(playerBaseDamage * damageMultiplier * playerDamageModifier);\r\n    }\r\n    \r\n    const finalEnemyHp = Math.max(0, enemy.hp - playerDamage);\r\n    const enemyDefeated = finalEnemyHp <= 0;\r\n    let lootDrops: ChunkItem[] | undefined = undefined;\r\n\r\n    if (playerDamage > 0) {\r\n        combatLogParts.push(`Player dealt ${playerDamage} damage.`);\r\n        if (successLevel === 'CriticalSuccess') combatLogParts.push('Critical Hit!');\r\n    }\r\n    \r\n    if (enemyDefeated) {\r\n        // Fix: Explicitly type templates and access it correctly\r\n        const templates = getTemplates(playerStatus.language || 'en');\r\n        const terrainKey = terrain as Terrain; // Assert terrain type\r\n        const enemyTemplate = (templates[terrainKey] as { enemies: { data: { type: TranslatableString, loot?: any[] } }[] })?.enemies.find((e: any) => \r\n            getTranslatedText(e.data.type ?? '', playerStatus.language || 'en') === getTranslatedText(enemy.type ?? '', playerStatus.language || 'en')\r\n        );\r\n\r\n        if (enemyTemplate && enemyTemplate.data.loot) {\r\n            const drops: ChunkItem[] = [];\r\n\r\n            for (const lootItem of enemyTemplate.data.loot) {\r\n                if (Math.random() < lootItem.chance) {\r\n                    const itemName = getTranslatedText(lootItem.name, playerStatus.language || 'en');\r\n                    const definition = resolveItemDef(itemName, customItemDefinitions);\r\n                    if (definition) {\r\n                        const quantity = getRandomInRange(lootItem.quantity);\r\n                        drops.push({\r\n                            name: ensureTranslatableString(lootItem.name), // FIX: Ensure name is TranslatableString\r\n                            description: definition.description,\r\n                            tier: definition.tier,\r\n                            quantity: quantity,\r\n                            emoji: definition.emoji,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (drops.length > 0) {\r\n                    lootDrops = drops;\r\n                    combatLogParts.push(`Enemy dropped ${drops.map(d => `${d.quantity} ${getTranslatedText(d.name, playerStatus.language || 'en')}`).join(', ')}.`);\r\n            }\r\n        }\r\n        \r\n        return {\r\n            playerDamageDealt: playerDamage,\r\n            enemyDamageDealt: 0,\r\n            finalPlayerHp: playerStatus.hp,\r\n            finalEnemyHp,\r\n            enemyDefeated: true,\r\n            fled: false,\r\n            combatLog: combatLogParts.join(' '),\r\n            lootDrops,\r\n        };\r\n    }\r\n    \r\n    let fled = false;\r\n    let enemyDamage = 0;\r\n    \r\n    const shouldFlee = enemy.behavior === 'passive' || (successLevel === 'CriticalSuccess' && enemy.size === 'small');\r\n\r\n    if (shouldFlee) {\r\n        fled = true;\r\n        combatLogParts.push('The creature fled in terror!');\r\n    } else {\r\n        fled = false;\r\n        let enemyDamageModifier = 1.0;\r\n        if (successLevel !== 'CriticalFailure' && lightLevel !== undefined && lightLevel < -3) {\r\n            enemyDamageModifier *= 0.8;\r\n        }\r\n        if (successLevel !== 'CriticalFailure' && moisture !== undefined && moisture > 8) {\r\n            enemyDamageModifier *= 0.9;\r\n        }\r\n        enemyDamage = Math.round(enemy.damage * enemyDamageModifier);\r\n        if (enemyDamage > 0) {\r\n                combatLogParts.push(`Enemy retaliated for ${enemyDamage} damage.`);\r\n        }\r\n    }\r\n    \r\n    const finalPlayerHp = Math.max(0, playerStatus.hp - enemyDamage);\r\n\r\n    return {\r\n        playerDamageDealt: playerDamage,\r\n        enemyDamageDealt: enemyDamage,\r\n        finalPlayerHp,\r\n        finalEnemyHp,\r\n        enemyDefeated: false,\r\n        fled,\r\n        combatLog: combatLogParts.join(' '),\r\n        lootDrops: undefined,\r\n    };\r\n});\r\n\r\n// --- TakeItem Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `takeItemTool`.\r\n * @property {ChunkItemSchema} itemToTake - Vß║¡t phß║⌐m cß╗Ñ thß╗â ─æ╞░ß╗úc lß║Ñy tß╗½ chunk.\r\n * @property {z.array} currentChunkItems - Danh s├ích ─æß║ºy ─æß╗º c├íc vß║¡t phß║⌐m hiß╗çn c├│ trong chunk.\r\n * @property {z.array} playerInventory - T├║i ─æß╗ô hiß╗çn tß║íi cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n */\r\nexport const TakeItemInputSchema = z.object({\r\n    itemToTake: ChunkItemSchema.describe(\"The specific item being taken from the chunk.\"),\r\n    currentChunkItems: z.array(ChunkItemSchema).describe(\"The complete list of items currently in the chunk.\"),\r\n    playerInventory: z.array(PlayerItemSchema).describe(\"The player's current inventory.\"),\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `takeItemTool`.\r\n * @property {z.array} updatedPlayerInventory - T├║i ─æß╗ô cß╗ºa ng╞░ß╗¥i ch╞íi sau khi h├ánh ─æß╗Öng.\r\n * @property {z.array} updatedChunkItems - C├íc vß║¡t phß║⌐m c├▓n lß║íi trong chunk sau khi h├ánh ─æß╗Öng.\r\n */\r\nexport const TakeItemOutputSchema = z.object({\r\n    updatedPlayerInventory: z.array(PlayerItemSchema),\r\n    updatedChunkItems: z.array(ChunkItemSchema),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â di chuyß╗ân to├án bß╗Ö mß╗Öt stack vß║¡t phß║⌐m tß╗½ thß║┐ giß╗¢i game v├áo t├║i ─æß╗ô cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * AI n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy khi h├ánh ─æß╗Öng cß╗ºa ng╞░ß╗¥i ch╞íi l├á nhß║╖t hoß║╖c lß║Ñy vß║¡t phß║⌐m.\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `TakeItemInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú cß║¡p nhß║¡t t├║i ─æß╗ô v├á chunk theo `TakeItemOutputSchema`.\r\n */\r\nexport const takeItemTool = ai.defineTool({\r\n    name: 'takeItem',\r\n    description: \"Moves an entire stack of items from the game world into the player's inventory. Call this when the player action is to pick up or take an item.\",\r\n    inputSchema: TakeItemInputSchema,\r\n    outputSchema: TakeItemOutputSchema\r\n}, async ({ itemToTake, currentChunkItems, playerInventory }) => {\r\n    const updatedChunkItems = currentChunkItems.filter(i => getTranslatedText(i.name, 'en') !== getTranslatedText(itemToTake.name, 'en')); // Use 'en' for filtering consistency if internal\r\n    const updatedPlayerInventory = [...playerInventory];\r\n    \r\n    // Fix: Use getTranslatableStringValue for comparison\r\n    const existingItem = updatedPlayerInventory.find(i => getTranslatedText(i.name, 'en') === getTranslatedText(itemToTake.name, 'en'));\r\n    \r\n    if (existingItem) {\r\n        existingItem.quantity += itemToTake.quantity;\r\n    } else {\r\n        updatedPlayerInventory.push({ \r\n            name: ensureTranslatableString(itemToTake.name), // FIX: Ensure name is TranslatableString\r\n            quantity: itemToTake.quantity, \r\n            tier: itemToTake.tier,\r\n            emoji: itemToTake.emoji,\r\n        });\r\n    }\r\n\r\n    return { updatedPlayerInventory, updatedChunkItems };\r\n});\r\n\r\n// --- UseItem Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `useItemTool`.\r\n * @property {z.string} itemName - T├¬n cß╗ºa vß║¡t phß║⌐m cß║ºn sß╗¡ dß╗Ñng tß╗½ t├║i ─æß╗ô.\r\n * @property {PlayerStatusSchema} playerStatus - Trß║íng th├íi hiß╗çn tß║íi cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * @property {z.record} customItemDefinitions - Map chß╗⌐a tß║Ñt cß║ú ─æß╗ïnh ngh─⌐a vß║¡t phß║⌐m t├╣y chß╗ënh (AI-generated v├á static).\r\n */\r\nexport const UseItemInputSchema = z.object({\r\n    itemName: z.string().describe(\"The name of the item to use from the inventory.\"),\r\n    playerStatus: PlayerStatusSchema,\r\n    customItemDefinitions: z.record(ItemDefinitionSchema).describe(\"A map of ALL item definitions (static and custom) for the current game session.\"),\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `useItemTool`.\r\n * @property {PlayerStatusSchema} updatedPlayerStatus - Trß║íng th├íi ng╞░ß╗¥i ch╞íi sau khi vß║¡t phß║⌐m ─æ╞░ß╗úc sß╗¡ dß╗Ñng.\r\n * @property {z.boolean} wasUsed - `true` nß║┐u vß║¡t phß║⌐m ─æ╞░ß╗úc t├¼m thß║Ñy v├á sß╗¡ dß╗Ñng th├ánh c├┤ng.\r\n * @property {z.string} effectDescription - M├┤ tß║ú thß╗▒c tß║┐ vß╗ü t├íc dß╗Ñng cß╗ºa vß║¡t phß║⌐m.\r\n */\r\nexport const UseItemOutputSchema = z.object({\r\n    updatedPlayerStatus: PlayerStatusSchema,\r\n    wasUsed: z.boolean().describe(\"Whether the item was successfully found and used.\"),\r\n    effectDescription: z.string().describe(\"A simple, factual description of what the item did, e.g., 'Healed for 25 HP. Restored 10 Stamina.'\"),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â sß╗¡ dß╗Ñng mß╗Öt vß║¡t phß║⌐m tß╗½ t├║i ─æß╗ô cß╗ºa ng╞░ß╗¥i ch╞íi, ├íp dß╗Ñng hiß╗çu ß╗⌐ng cß╗ºa n├│ v├á giß║úm sß╗æ l╞░ß╗úng.\r\n * AI n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy khi h├ánh ─æß╗Öng cß╗ºa ng╞░ß╗¥i ch╞íi l├á sß╗¡ dß╗Ñng mß╗Öt vß║¡t phß║⌐m TR├èN Bß║óN TH├éN (v├¡ dß╗Ñ: '─ân quß║ú mß╗ìng', 'uß╗æng thuß╗æc').\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `UseItemInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú cß║¡p nhß║¡t trß║íng th├íi ng╞░ß╗¥i ch╞íi theo `UseItemOutputSchema`.\r\n */\r\nexport const useItemTool = ai.defineTool({\r\n    name: 'useItem',\r\n    description: \"Uses one item from the player's inventory, applying its effect and decrementing its quantity. Call this when the player action is to use an item ON THEMSELVES (e.g. 'eat berry', 'drink potion').\",\r\n    inputSchema: UseItemInputSchema,\r\n    outputSchema: UseItemOutputSchema\r\n}, async ({ itemName, playerStatus, customItemDefinitions }) => {\r\n    const newStatus: PlayerStatus = JSON.parse(JSON.stringify(playerStatus)); // Deep copy\r\n    newStatus.items = newStatus.items || [];\r\n    newStatus.skills = newStatus.skills || [];\r\n    newStatus.pets = newStatus.pets || [];\r\n    // Fix: Use getTranslatableStringValue for comparison\r\n    const itemIndex = newStatus.items.findIndex((i: PlayerItem) => getTranslatedText(i.name, playerStatus.language || 'en').toLowerCase() === itemName.toLowerCase());\r\n\r\n    if (itemIndex === -1) {\r\n        return { updatedPlayerStatus: playerStatus, wasUsed: false, effectDescription: 'Item not found.' };\r\n    }\r\n\r\n    // Fix: Use resolveItemDef to access item definitions (prefer custom, fall back to master)\r\n    const itemDef = resolveItemDef(getTranslatedText(newStatus.items[itemIndex].name, playerStatus.language || 'en'), customItemDefinitions);\r\n    \r\n    if (!itemDef) {\r\n        return { updatedPlayerStatus: playerStatus, wasUsed: false, effectDescription: 'Item has no defined effect.' };\r\n    }\r\n    \r\n    const effectDescriptions: string[] = [];\r\n    // Fix: Explicitly type 'effect'\r\n    itemDef.effects.forEach((effect: typeof ItemDefinitionSchema._type['effects'][number]) => {\r\n        switch (effect.type) {\r\n            case 'HEAL':\r\n                if (typeof effect.amount === 'number') {\r\n                    const oldHp = newStatus.hp;\r\n                    newStatus.hp = Math.min(100, newStatus.hp + effect.amount);\r\n                    if (newStatus.hp > oldHp) {\r\n                        effectDescriptions.push(`Healed for ${newStatus.hp - oldHp} HP.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'RESTORE_STAMINA':\r\n                if (typeof effect.amount === 'number') {\r\n                    const oldStamina = newStatus.stamina;\r\n                    newStatus.stamina = Math.min(100, newStatus.stamina + effect.amount);\r\n                    if (newStatus.stamina > oldStamina) {\r\n                        effectDescriptions.push(`Restored ${newStatus.stamina - oldStamina} stamina.`);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    });\r\n\r\n    if (effectDescriptions.length === 0) {\r\n        return { updatedPlayerStatus: playerStatus, wasUsed: false, effectDescription: 'Item had no effect.' };\r\n    }\r\n\r\n    newStatus.items[itemIndex].quantity -= 1;\r\n    if (newStatus.items[itemIndex].quantity <= 0) {\r\n        newStatus.items.splice(itemIndex, 1);\r\n    }\r\n    \r\n    return { \r\n        updatedPlayerStatus: newStatus, \r\n        wasUsed: true, \r\n        effectDescription: effectDescriptions.join(' ') \r\n    };\r\n});\r\n\r\n// --- TameEnemy Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `tameEnemyTool`.\r\n * @property {z.string} itemName - T├¬n vß║¡t phß║⌐m thß╗⌐c ─ân d├╣ng ─æß╗â thuß║ºn h├│a.\r\n * @property {PlayerStatusSchema} playerStatus - Trß║íng th├íi hiß╗çn tß║íi cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * @property {EnemySchema} enemy - Kß║╗ th├╣ ─æang cß╗æ gß║»ng thuß║ºn h├│a.\r\n */\r\nexport const TameEnemyInputSchema = z.object({\r\n    itemName: z.string().describe(\"The name of the food item to use for taming.\"),\r\n    playerStatus: PlayerStatusSchema,\r\n    enemy: EnemySchema,\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `tameEnemyTool`.\r\n * @property {z.boolean} wasTamed - `true` nß║┐u nß╗ù lß╗▒c thuß║ºn h├│a th├ánh c├┤ng.\r\n * @property {z.boolean} itemConsumed - `true` nß║┐u sinh vß║¡t ─æ├ú ─ân vß║¡t phß║⌐m.\r\n * @property {PlayerStatusSchema} updatedPlayerStatus - Trß║íng th├íi ng╞░ß╗¥i ch╞íi sau khi vß║¡t phß║⌐m ─æ╞░ß╗úc ti├¬u thß╗Ñ.\r\n * @property {EnemySchema} updatedEnemy - Trß║íng th├íi mß╗¢i cß╗ºa kß║╗ th├╣, hoß║╖c `null` nß║┐u ─æ├ú ─æ╞░ß╗úc thuß║ºn h├│a.\r\n * @property {PetSchema} newPet - Dß╗» liß╗çu pet mß╗¢i, nß║┐u thuß║ºn h├│a th├ánh c├┤ng.\r\n * @property {z.string} log - Nhß║¡t k├╜ thß╗▒c tß║┐ vß╗ü nhß╗»ng g├¼ ─æ├ú xß║úy ra.\r\n */\r\nexport const TameEnemyOutputSchema = z.object({\r\n    wasTamed: z.boolean().describe(\"Whether the taming attempt succeeded.\"),\r\n    itemConsumed: z.boolean().describe(\"Whether the creature ate the item.\"),\r\n    updatedPlayerStatus: PlayerStatusSchema.describe(\"The player's status after consuming the item from inventory.\"),\r\n    updatedEnemy: EnemySchema.nullable().describe(\"The enemy's new state, or null if tamed.\"),\r\n    newPet: PetSchema.nullable().describe(\"The new pet data, if taming was successful.\"),\r\n    log: z.string().describe(\"A factual log of what happened, e.g., 'The wolf ate the Raw Wolf Meat. Taming failed.'\"),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â cß╗æ gß║»ng thuß║ºn h├│a mß╗Öt kß║╗ th├╣ bß║▒ng c├ích cho n├│ mß╗Öt vß║¡t phß║⌐m thß╗⌐c ─ân tß╗½ t├║i ─æß╗ô cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * AI n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy khi h├ánh ─æß╗Öng cß╗ºa ng╞░ß╗¥i ch╞íi l├á sß╗¡ dß╗Ñng mß╗Öt vß║¡t phß║⌐m l├¬n mß╗Öt sinh vß║¡t (v├¡ dß╗Ñ: 'cho thß╗ït s├│i').\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `TameEnemyInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú thuß║ºn h├│a theo `TameEnemyOutputSchema`.\r\n */\r\nexport const tameEnemyTool = ai.defineTool({\r\n    name: 'tameEnemy',\r\n    description: \"Attempts to tame an enemy by giving it a food item from the player's inventory. Call this when the player's action is to use an item on a creature (e.g. 'give meat to wolf').\",\r\n    inputSchema: TameEnemyInputSchema,\r\n    outputSchema: TameEnemyOutputSchema\r\n}, async ({ itemName, playerStatus, enemy }) => {\r\n    const newStatus: PlayerStatus = JSON.parse(JSON.stringify(playerStatus)); // Deep copy\r\n    // Fix: Use getTranslatableStringValue for comparison\r\n    const itemIndex = newStatus.items.findIndex(i => getTranslatableStringValue(i.name, playerStatus.language || 'en').toLowerCase() === itemName.toLowerCase());\r\n\r\n    if (itemIndex === -1) {\r\n        return {\r\n            wasTamed: false,\r\n            itemConsumed: false,\r\n            updatedPlayerStatus: playerStatus,\r\n            updatedEnemy: enemy,\r\n            newPet: null,\r\n            log: \"Player does not have the specified item.\"\r\n        };\r\n    }\r\n\r\n    // Fix: Check if enemy.diet exists before calling includes, and handle TranslatableString for enemy.type\r\n    if (!enemy.diet || !enemy.diet.includes(itemName)) {\r\n        return {\r\n            wasTamed: false,\r\n            itemConsumed: false,\r\n            updatedPlayerStatus: playerStatus,\r\n            updatedEnemy: enemy,\r\n            newPet: null,\r\n            log: `The ${getTranslatedText(enemy.type ?? '', playerStatus.language || 'en')} is not interested in the ${itemName ?? ''}.`\r\n        };\r\n    }\r\n    \r\n    newStatus.items[itemIndex].quantity -= 1;\r\n    if (newStatus.items[itemIndex].quantity <= 0) {\r\n        newStatus.items.splice(itemIndex, 1);\r\n    }\r\n    \r\n    const newEnemyState = { ...enemy };\r\n        // Fix: Provide default values for satiation and maxSatiation if they are undefined\r\n    newEnemyState.satiation = Math.min((newEnemyState.satiation ?? 0) + 1, (newEnemyState.maxSatiation ?? 1));\r\n\r\n    const baseTameChance = 0.1; \r\n    const satiationBonus = ((newEnemyState.satiation ?? 0) / (newEnemyState.maxSatiation ?? 1)) * 0.4; \r\n    const healthPenalty = (newEnemyState.hp / 100) * 0.2; \r\n    const tamingChance = baseTameChance + satiationBonus - healthPenalty;\r\n\r\n    if (Math.random() < tamingChance) {\r\n        const newPet: Pet = {\r\n            // FIX: Use ensureTranslatableString to correctly assign enemy.type with type assertion\r\n            type: ensureTranslatableString(enemy.type as TranslatableString), \r\n            level: 1,\r\n        };\r\n        \r\n        if (!newStatus.pets) {\r\n            newStatus.pets = [];\r\n        }\r\n        newStatus.pets.push(newPet);\r\n\r\n        return {\r\n            wasTamed: true,\r\n            itemConsumed: true,\r\n            updatedPlayerStatus: newStatus,\r\n            updatedEnemy: null, \r\n            newPet: newPet,\r\n            log: `The ${getTranslatedText(enemy.type ?? '', playerStatus.language || 'en')} ate the ${itemName ?? ''}. Taming was successful!`\r\n        };\r\n    } else {\r\n        return {\r\n            wasTamed: false,\r\n            itemConsumed: true,\r\n            updatedPlayerStatus: newStatus,\r\n            updatedEnemy: newEnemyState,\r\n            newPet: null,\r\n            log: `The ${getTranslatedText(enemy.type ?? '', playerStatus.language || 'en')} ate the ${itemName ?? ''}, but remains wild.`\r\n        };\r\n    }\r\n});\r\n\r\n// --- UseSkill Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `useSkillTool`.\r\n * @property {z.string} skillName - T├¬n kß╗╣ n─âng cß║ºn sß╗¡ dß╗Ñng tß╗½ danh s├ích kß╗╣ n─âng cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * @property {PlayerStatusSchema} playerStatus - Trß║íng th├íi hiß╗çn tß║íi cß╗ºa ng╞░ß╗¥i ch╞íi.\r\n * @property {EnemySchema} [enemy] - Kß║╗ th├╣, nß║┐u kß╗╣ n─âng nhß║»m mß╗Ñc ti├¬u.\r\n * @property {z.enum} successLevel - Kß║┐t quß║ú ph├ón loß║íi cß╗ºa mß╗Öt lß║ºn tung x├║c xß║»c d20, quyß║┐t ─æß╗ïnh kß║┐t quß║ú kß╗╣ n─âng.\r\n */\r\nexport const UseSkillInputSchema = z.object({\r\n    skillName: z.string().describe(\"The name of the skill to use from the player's skill list.\"),\r\n    playerStatus: PlayerStatusSchema,\r\n    enemy: EnemySchema.nullable().optional().describe(\"The enemy, if the skill targets one.\"),\r\n    successLevel: z.enum(['CriticalFailure', 'Failure', 'Success', 'GreatSuccess', 'CriticalSuccess']).describe(\"The categorized result of a d20 dice roll, which dictates the skill's outcome.\"),\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `useSkillTool`.\r\n * @property {PlayerStatusSchema} updatedPlayerStatus - Trß║íng th├íi ng╞░ß╗¥i ch╞íi sau khi kß╗╣ n─âng ─æ╞░ß╗úc sß╗¡ dß╗Ñng.\r\n * @property {EnemySchema} [updatedEnemy] - Trß║íng th├íi mß╗¢i cß╗ºa kß║╗ th├╣, hoß║╖c `null` nß║┐u bß╗ï ─æ├ính bß║íi.\r\n * @property {z.string} log - Nhß║¡t k├╜ thß╗▒c tß║┐ vß╗ü nhß╗»ng g├¼ ─æ├ú xß║úy ra (v├¡ dß╗Ñ: 'Ng╞░ß╗¥i ch╞íi hß║┐t mana.', 'Hß╗ôi m├íu 25 HP.'). Nhß║¡t k├╜ n├áy n├¬n ─æ╞░ß╗úc AI d├╣ng ─æß╗â kß╗â chuyß╗çn.\r\n */\r\nexport const UseSkillOutputSchema = z.object({\r\n    updatedPlayerStatus: PlayerStatusSchema.describe(\"The player's status after the skill is used.\"),\r\n    updatedEnemy: EnemySchema.nullable().optional().describe(\"The enemy's new state, or null if defeated.\"),\r\n    log: z.string().describe(\"A factual log of what happened, e.g., 'Player is out of mana.', 'Healed for 25 HP.', 'The skill fizzles!'. This log should be narrated by the AI.\"),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â sß╗¡ dß╗Ñng mß╗Öt trong c├íc kß╗╣ n─âng ─æ├ú biß║┐t cß╗ºa ng╞░ß╗¥i ch╞íi, xem x├⌐t mß╗⌐c ─æß╗Ö th├ánh c├┤ng cß╗ºa lß║ºn tung d20.\r\n * AI n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy khi h├ánh ─æß╗Öng cß╗ºa ng╞░ß╗¥i ch╞íi l├á sß╗¡ dß╗Ñng mß╗Öt kß╗╣ n─âng (v├¡ dß╗Ñ: 'sß╗¡ dß╗Ñng Hß╗ôi m├íu', 'thi triß╗ân Cß║ºu Lß╗¡a').\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `UseSkillInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú sß╗¡ dß╗Ñng kß╗╣ n─âng theo `UseSkillOutputSchema`.\r\n */\r\nexport const useSkillTool = ai.defineTool({\r\n    name: 'useSkill',\r\n    description: \"Uses one of the player's known skills, considering the d20 roll's success level. Call this when the player's action is to use a skill (e.g., 'use Heal', 'cast Fireball').\",\r\n    inputSchema: UseSkillInputSchema,\r\n    outputSchema: UseSkillOutputSchema\r\n}, async ({ skillName, playerStatus, enemy, successLevel }) => {\r\n    const newPlayerStatus: PlayerStatus = JSON.parse(JSON.stringify(playerStatus));\r\n    let newEnemy: typeof enemy | null = enemy ? JSON.parse(JSON.stringify(enemy)) : null;\r\n\r\n    // Fix: Use getTranslatableStringValue for comparison\r\n    const skillToUse = newPlayerStatus.skills.find(s => getTranslatedText(s.name, playerStatus.language || 'en').toLowerCase() === skillName.toLowerCase());\r\n\r\n    if (!skillToUse) {\r\n        return { updatedPlayerStatus: playerStatus, updatedEnemy: enemy, log: `Player does not know the skill: ${skillName}.` };\r\n    }\r\n\r\n    if ((newPlayerStatus.mana ?? 0) < skillToUse.manaCost) {\r\n        // FIX: Add type assertion for skillToUse.name to resolve potential TypeScript inference issues.\r\n        return { updatedPlayerStatus: playerStatus, updatedEnemy: enemy, log: `Not enough mana to use ${getTranslatedText(skillToUse.name as TranslatableString, playerStatus.language || 'en')}.` };\r\n    }\r\n\r\n    newPlayerStatus.mana = (newPlayerStatus.mana ?? 0) - skillToUse.manaCost;\r\n\r\n    let log = \"\";\r\n    let effectMultiplier = 1.0;\r\n\r\n    switch (successLevel) {\r\n        case 'CriticalFailure':\r\n            if (skillToUse.effect.type === 'HEAL') {\r\n                const backfireDamage = Math.round(skillToUse.effect.amount * 0.5);\r\n                newPlayerStatus.hp = Math.max(0, newPlayerStatus.hp - backfireDamage);\r\n                log = `Skill backfired! Your healing spell inflicts ${backfireDamage} damage on you instead.`;\r\n            } else if (skillToUse.effect.type === 'DAMAGE') {\r\n                    const backfireDamage = Math.round(skillToUse.effect.amount * 0.5);\r\n                newPlayerStatus.hp = Math.max(0, newPlayerStatus.hp - backfireDamage);\r\n                log = `Skill backfired! The fireball explodes in your hand, dealing ${backfireDamage} damage.`;\r\n            }\r\n            return { updatedPlayerStatus: newPlayerStatus, updatedEnemy: newEnemy, log };\r\n\r\n        case 'Failure':\r\n            // FIX: Add type assertion for skillToUse.name.\r\n            log = `The magic fizzles! Your attempt to cast ${getTranslatedText(skillToUse.name as TranslatableString, playerStatus.language || 'en')} fails.`;\r\n            return { updatedPlayerStatus: newPlayerStatus, updatedEnemy: newEnemy, log };\r\n\r\n        case 'GreatSuccess':\r\n            effectMultiplier = 1.5;\r\n            break;\r\n        case 'CriticalSuccess':\r\n            effectMultiplier = 2.0;\r\n            break;\r\n        case 'Success':\r\n        default:\r\n            effectMultiplier = 1.0;\r\n            break;\r\n    }\r\n\r\n    switch (skillToUse.effect.type) {\r\n        case 'HEAL':\r\n            if (skillToUse.effect.target === 'SELF') {\r\n                const healAmount = Math.round(skillToUse.effect.amount * effectMultiplier);\r\n                const oldHp = newPlayerStatus.hp;\r\n                newPlayerStatus.hp = Math.min(100, newPlayerStatus.hp + healAmount);\r\n                const healedAmount = newPlayerStatus.hp - oldHp;\r\n                // FIX: Add type assertion for skillToUse.name.\r\n                log = `Used ${getTranslatableStringValue(skillToUse.name as TranslatableString, playerStatus.language || 'en')}, healing for ${healedAmount} HP.`;\r\n                if (successLevel === 'GreatSuccess') log += ' A powerful surge of energy makes you feel much more refreshed.';\r\n                if (successLevel === 'CriticalSuccess') log += ' A divine energy surrounds you, miraculously healing your wounds!';\r\n            }\r\n            break;\r\n        case 'DAMAGE':\r\n            if (skillToUse.effect.target === 'ENEMY') {\r\n                if (!newEnemy) {\r\n                    // FIX: Add type assertion for skillToUse.name.\r\n                    log = `Used ${getTranslatableStringValue(skillToUse.name as TranslatableString, playerStatus.language || 'en')}, but there was no target.`;\r\n                } else {\r\n                    const baseDamage = skillToUse.effect.amount + Math.round((newPlayerStatus.attributes?.magicalAttack ?? 0) * 0.5);\r\n                    const finalDamage = Math.round(baseDamage * effectMultiplier);\r\n\r\n                    newEnemy.hp = Math.max(0, newEnemy.hp - finalDamage);\r\n                    // FIX: Add type assertion for skillToUse.name.\r\n                    log = `Used ${getTranslatableStringValue(skillToUse.name as TranslatableString, playerStatus.language || 'en')}, dealing ${finalDamage} magic damage to the ${getTranslatableStringValue(newEnemy.type, playerStatus.language || 'en')}.`;\r\n                        if (successLevel === 'GreatSuccess') log += ' The fireball flies faster and more accurately, dealing extra damage.';\r\n                    // FIX: Add type assertion for skillToUse.name.\r\n                    if (successLevel === 'CriticalSuccess') log = `A magical CRITICAL HIT! Your ${getTranslatableStringValue(skillToUse.name as TranslatableString, playerStatus.language || 'en')} explodes violently, dealing a devastating ${finalDamage} damage to the ${getTranslatableStringValue(newEnemy.type, playerStatus.language || 'en')}.`;\r\n\r\n                    if (skillToUse.effect.healRatio) {\r\n                        const healedAmount = Math.round(finalDamage * skillToUse.effect.healRatio);\r\n                        const oldHp = newPlayerStatus.hp;\r\n                        newPlayerStatus.hp = Math.min(100, newPlayerStatus.hp + healedAmount);\r\n                        if (newPlayerStatus.hp > oldHp) {\r\n                            log += ` You siphon ${newPlayerStatus.hp - oldHp} health from the hit.`\r\n                        }\r\n                    }\r\n\r\n                    if (newEnemy.hp <= 0) {\r\n                        log += ` The ${getTranslatableStringValue(newEnemy.type, playerStatus.language || 'en')} has been vanquished!`;\r\n                        newEnemy = null;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n    }\r\n\r\n    return {\r\n        updatedPlayerStatus: newPlayerStatus,\r\n        updatedEnemy: newEnemy,\r\n        log,\r\n    };\r\n});\r\n\r\n// --- CompleteQuest Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `completeQuestTool`.\r\n * @property {z.string} questText - V─ân bß║ún ch├¡nh x├íc cß╗ºa nhiß╗çm vß╗Ñ ─æang ─æ╞░ß╗úc ho├án th├ánh.\r\n * @property {PlayerStatusSchema} playerStatus - Trß║íng th├íi hiß╗çn tß║íi cß╗ºa ng╞░ß╗¥i ch╞íi, ─æß╗â tham chiß║┐u.\r\n */\r\nexport const CompleteQuestInputSchema = z.object({\r\n    questText: z.string().describe(\"The exact text of the quest being completed.\"),\r\n    playerStatus: PlayerStatusSchema.describe(\"The player's current status, for context.\"),\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `completeQuestTool`.\r\n * @property {z.boolean} isCompleted - Lu├┤n trß║ú vß╗ü `true` ─æß╗â x├íc nhß║¡n ho├án th├ánh nhiß╗çm vß╗Ñ.\r\n * @property {z.string} rewardDescription - V─ân bß║ún m├┤ tß║ú phß║ºn th╞░ß╗ƒng, v├¡ dß╗Ñ: 'Ng╞░ß╗¥i thß╗ú s─ân cß║úm ╞ín bß║ín v├á tß║╖ng bß║ín mß╗Öt nß║»m thß║úo mß╗Öc qu├╜ hiß║┐m.'\r\n * @property {z.array} [rewardItems] - Mß║úng c├íc vß║¡t phß║⌐m sß║╜ ─æ╞░ß╗úc trao cho ng╞░ß╗¥i ch╞íi nh╞░ mß╗Öt phß║ºn th╞░ß╗ƒng.\r\n */\r\nexport const CompleteQuestOutputSchema = z.object({\r\n    isCompleted: z.boolean().describe(\"Always returns true to confirm completion.\"),\r\n    rewardDescription: z.string().describe(\"A short, flavorful text describing the reward given, e.g., 'The hunter thanks you and gives you a handful of rare herbs.'\"),\r\n    rewardItems: z.array(PlayerItemSchema).optional().describe(\"An array of items to be given to the player as a reward.\"),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â x├íc nhß║¡n mß╗Öt nhiß╗çm vß╗Ñ ─æ├ú ho├án th├ánh v├á x├íc ─æß╗ïnh phß║ºn th╞░ß╗ƒng ph├╣ hß╗úp.\r\n * AI chß╗ë n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy KHI h├ánh ─æß╗Öng cß╗ºa ng╞░ß╗¥i ch╞íi trß╗▒c tiß║┐p ho├án th├ánh mß╗Ñc ti├¬u nhiß╗çm vß╗Ñ.\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `CompleteQuestInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú ho├án th├ánh nhiß╗çm vß╗Ñ v├á phß║ºn th╞░ß╗ƒng theo `CompleteQuestOutputSchema`.\r\n */\r\nexport const completeQuestTool = ai.defineTool({\r\n    name: 'completeQuest',\r\n    description: \"Confirms a quest is completed and determines a suitable reward. Call this ONLY when the player's action directly fulfills a quest's objective.\",\r\n    inputSchema: CompleteQuestInputSchema,\r\n    outputSchema: CompleteQuestOutputSchema\r\n}, async ({ questText, playerStatus }) => {\r\n    const possibleRewards: PlayerItem[] = [\r\n        { name: {en: 'Minor Healing Potion', vi: 'Thuß╗æc M├íu Yß║┐u'}, quantity: 2, tier: 1, emoji: '≡ƒº¬' },\r\n        { name: {en: 'Sharpening Stone', vi: '─É├í M├ái'}, quantity: 1, tier: 2, emoji: '≡ƒö¬' },\r\n        { name: {en: 'Bone Powder', vi: 'Bß╗Öt X╞░╞íng'}, quantity: 3, tier: 2, emoji: '≡ƒÆÇ' },\r\n        { name: {en: 'Magic Dust', vi: 'C├ít Ma Thuß║¡t'}, quantity: 1, tier: 4, emoji: 'Γ£¿'},\r\n    ];\r\n    \r\n    const rewardItems: PlayerItem[] = [];\r\n    const numberOfRewards = getRandomInRange({ min: 1, max: 2 });\r\n\r\n    for (let i = 0; i < numberOfRewards; i++) {\r\n        const reward = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];\r\n        const existing = rewardItems.find(r => getTranslatableStringValue(r.name, playerStatus.language || 'en') === getTranslatableStringValue(reward.name, playerStatus.language || 'en'));\r\n        if (!existing) {\r\n            rewardItems.push(reward);\r\n        }\r\n    }\r\n\r\n    return {\r\n        isCompleted: true,\r\n        rewardDescription: \"As a token of gratitude, you receive a reward.\",\r\n        rewardItems: rewardItems,\r\n    };\r\n});\r\n\r\n// --- StartQuest Tool Schemas ---\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu v├áo cho c├┤ng cß╗Ñ `startQuestTool`.\r\n * @property {z.string} questText - V─ân bß║ún ─æß║ºy ─æß╗º cß╗ºa nhiß╗çm vß╗Ñ mß╗¢i sß║╜ ─æ╞░ß╗úc giao cho ng╞░ß╗¥i ch╞íi.\r\n */\r\nexport const StartQuestInputSchema = z.object({\r\n    questText: z.string().describe(\"The full text of the new quest to be given to the player.\"),\r\n});\r\n\r\n/**\r\n * Schema ─æß╗ïnh ngh─⌐a ─æß║ºu ra cho c├┤ng cß╗Ñ `startQuestTool`.\r\n * @property {z.string} questStarted - V─ân bß║ún nhiß╗çm vß╗Ñ ─æ├ú ─æ╞░ß╗úc bß║»t ─æß║ºu th├ánh c├┤ng.\r\n */\r\nexport const StartQuestOutputSchema = z.object({\r\n    questStarted: z.string().describe(\"The quest text that was successfully started.\"),\r\n});\r\n\r\n/**\r\n * C├┤ng cß╗Ñ ─æß╗â bß║»t ─æß║ºu mß╗Öt nhiß╗çm vß╗Ñ mß╗¢i cho ng╞░ß╗¥i ch╞íi.\r\n * AI chß╗ë n├¬n gß╗ìi c├┤ng cß╗Ñ n├áy KHI mß╗Öt NPC giao cho ng╞░ß╗¥i ch╞íi mß╗Öt nhiß╗çm vß╗Ñ mß╗¢i trong cuß╗Öc tr├▓ chuyß╗çn.\r\n * @param {object} input - Dß╗» liß╗çu ─æß║ºu v├áo theo `StartQuestInputSchema`.\r\n * @returns {Promise<object>} - Kß║┐t quß║ú bß║»t ─æß║ºu nhiß╗çm vß╗Ñ theo `StartQuestOutputSchema`.\r\n */\r\nexport const startQuestTool = ai.defineTool({\r\n    name: 'startQuest',\r\n    description: \"Starts a new quest for the player. Call this ONLY when an NPC gives the player a new quest during a conversation.\",\r\n    inputSchema: StartQuestInputSchema,\r\n    outputSchema: StartQuestOutputSchema\r\n}, async ({ questText }) => {\r\n    return {\r\n        questStarted: questText,\r\n    };\r\n});","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\app\\api\\generate-world\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\app\\api\\narrative-preview\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createRng' is defined but never used.","line":4,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Lexicon' is defined but never used.","line":5,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'selectPrimaryTemplate' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fillTemplate' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lexEnPath' is assigned a value but never used.","line":11,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'lexViPath' is assigned a value but never used.","line":12,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { NextResponse } from 'next/server';\r\nimport path from 'path';\r\nimport { readFileSync } from 'fs';\r\nimport createRng from '@/lib/narrative/rng';\r\nimport Lexicon from '@/lib/narrative/lexicon';\r\nimport { selectPrimaryTemplate } from '@/lib/narrative/selector';\r\nimport { fillTemplate } from '@/lib/narrative/assembler';\r\nimport { generateNarrative, loadPersonasSample } from '@/lib/narrative/orchestrator';\r\n\r\nconst templatesPath = path.resolve(process.cwd(), 'src/lib/narrative/data/templates.sample.json');\r\nconst lexEnPath = path.resolve(process.cwd(), 'src/lib/narrative/data/lexicon.en.json');\r\nconst lexViPath = path.resolve(process.cwd(), 'src/lib/narrative/data/lexicon.vi.json');\r\n\r\nexport async function GET(req: Request) {\r\n  const url = new URL(req.url);\r\n  const seed = url.searchParams.get('seed') || 'preview';\r\n  const lang = (url.searchParams.get('lang') || 'en') as 'en' | 'vi';\r\n  const personaId = url.searchParams.get('persona') || undefined;\r\n\r\n  const templates = JSON.parse(readFileSync(templatesPath, 'utf8'));\r\n\r\n  const personas = loadPersonasSample();\r\n  const persona = personaId ? personas.find(p => p.id === personaId) : undefined;\r\n\r\n  // sample snapshot - in real use, pass snapshot via POST\r\n  const snapshot = { chunk: { terrain: 'Jungle', lightLevel: 8, moisture: 50 }, moods: ['lush'] };\r\n\r\n  const out = generateNarrative(snapshot, templates, { seed, lang, desiredDetail: 2, persona });\r\n  return NextResponse.json(out);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\app\\api\\sound\\[...path]\\route.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":30,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from 'fs/promises';\r\nimport path from 'path';\r\nimport { NextResponse } from 'next/server';\r\n\r\nexport async function GET(_req: Request, { params }: { params: { path?: string[] } }) {\r\n  try {\r\n    const segments = params?.path ?? [];\r\n    if (!segments || segments.length === 0) return new NextResponse('Not found', { status: 404 });\r\n\r\n    // root of asset folder in repo\r\n    const root = path.join(process.cwd(), 'asset', 'sound');\r\n    // Prevent path traversal\r\n    const safePath = path.join(root, ...segments);\r\n    if (!safePath.startsWith(root)) return new NextResponse('Forbidden', { status: 403 });\r\n\r\n    const buf = await fs.readFile(safePath);\r\n    const ext = path.extname(safePath).toLowerCase();\r\n    let contentType = 'application/octet-stream';\r\n    if (ext === '.mp3') contentType = 'audio/mpeg';\r\n    if (ext === '.wav') contentType = 'audio/wav';\r\n    if (ext === '.ogg') contentType = 'audio/ogg';\r\n\r\n    return new NextResponse(buf, {\r\n      status: 200,\r\n      headers: {\r\n        'Content-Type': contentType,\r\n        'Cache-Control': 'public, max-age=31536000, immutable'\r\n      }\r\n    });\r\n  } catch (e) {\r\n    return new NextResponse('Not found', { status: 404 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\app\\dev\\narrative-preview\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\app\\layout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\app\\page.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\client\\client-init.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\bottom-action-bar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\building-popup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\controls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\crafting-popup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslationKey' is defined but never used.","line":12,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used.","line":18,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n\"use client\";\r\n\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from \"@/components/ui/dialog\";\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport { Tooltip, TooltipProvider, TooltipTrigger, TooltipContent } from \"@/components/ui/tooltip\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport type { PlayerItem, Recipe, ItemDefinition, CraftingOutcome } from \"@/lib/game/types\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\nimport { calculateCraftingOutcome } from \"@/lib/game/engine/crafting\";\r\nimport { Hammer } from \"./icons\";\r\nimport { cn, getTranslatedText } from \"@/lib/utils\";\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\nimport { Switch } from \"@/components/ui/switch\";\r\nimport { useState, useEffect } from \"react\";\r\n\r\ninterface CraftingPopupProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  playerItems: PlayerItem[];\r\n  itemDefinitions: Record<string, ItemDefinition>;\r\n  recipes: Record<string, Recipe>;\r\n  onCraft: (recipe: Recipe, outcome: CraftingOutcome) => void;\r\n}\r\n\r\nexport function CraftingPopup({ open, onOpenChange, playerItems, itemDefinitions, recipes, onCraft }: CraftingPopupProps) {\r\n  const { t, language } = useLanguage();\r\n  const [showOnlyCraftable, setShowOnlyCraftable] = useState(false);\r\n  const [showOnlyWithAnyIngredient, setShowOnlyWithAnyIngredient] = useState(false);\r\n  const [sortByCraftability, setSortByCraftability] = useState(false);\r\n\r\n  // Process recipes with craftability scores\r\n  const processedRecipes = Object.values(recipes).map(recipe => {\r\n    const outcome = calculateCraftingOutcome(playerItems, recipe, itemDefinitions);\r\n    const craftabilityScore = outcome.resolvedIngredients.filter(ing => ing.hasEnough).length / recipe.ingredients.length;\r\n    return { recipe, outcome, craftabilityScore };\r\n  });\r\n\r\n  // Filter and sort recipes\r\n  const filteredRecipes = processedRecipes\r\n    .filter(({ craftabilityScore, outcome }) => {\r\n      if (showOnlyCraftable && craftabilityScore < 1) {\r\n        return false;\r\n      }\r\n      if (showOnlyWithAnyIngredient && outcome.resolvedIngredients.every(ing => ing.playerQuantity === 0)) {\r\n        return false;\r\n      }\r\n      return true;\r\n    })\r\n    .sort((a, b) => {\r\n      if (sortByCraftability) {\r\n        return b.craftabilityScore - a.craftabilityScore;\r\n      }\r\n      return 0;\r\n    });\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent className=\"sm:max-w-2xl\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"font-headline flex items-center gap-2\">\r\n            <Hammer /> {t('crafting')}\r\n          </DialogTitle>\r\n          <DialogDescription>{t('craftingDesc')}</DialogDescription>\r\n        </DialogHeader>\r\n        <div className=\"flex gap-4 mb-4\">\r\n          <div className=\"flex items-center gap-2\">\r\n            <Switch\r\n              checked={showOnlyCraftable}\r\n              onCheckedChange={setShowOnlyCraftable}\r\n              id=\"craftable-filter\"\r\n            />\r\n            <label htmlFor=\"craftable-filter\" className=\"text-sm\">\r\n              {t('showOnlyCraftable')}\r\n            </label>\r\n          </div>\r\n          <div className=\"flex items-center gap-2\">\r\n            <Switch\r\n              checked={showOnlyWithAnyIngredient}\r\n              onCheckedChange={setShowOnlyWithAnyIngredient}\r\n              id=\"any-ingredient-filter\"\r\n            />\r\n            <label htmlFor=\"any-ingredient-filter\" className=\"text-sm\">\r\n              {t('showOnlyWithAnyIngredient')}\r\n            </label>\r\n          </div>\r\n          <Button\r\n            variant=\"outline\"\r\n            size=\"sm\"\r\n            onClick={() => setSortByCraftability(!sortByCraftability)}\r\n            className={cn(\"text-sm\", sortByCraftability && \"bg-accent\")}\r\n          >\r\n            {t('sortByCraftability')}\r\n          </Button>\r\n        </div>\r\n        <Separator />\r\n        <ScrollArea className=\"max-h-[65vh] pr-4\">\r\n          <div className=\"p-4 space-y-4\">\r\n            {filteredRecipes.map(({ recipe, outcome }, index) => {\r\n              const hasRequiredTool = outcome.hasRequiredTool;\r\n              const resultName = getTranslatedText(recipe.result.name, language, t);\r\n              const resultDescText = getTranslatedText(recipe.description, language, t);\r\n              const requiredToolName = recipe.requiredTool ? getTranslatedText(recipe.requiredTool as any, language, t) : '';\r\n\r\n              return (\r\n                <div key={index} \r\n                  className={cn(\r\n                    \"p-4 border rounded-lg bg-muted/50 flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4\",\r\n                    outcome.canCraft && \"border-green-400/20\"\r\n                  )}>\r\n                  <div className=\"flex-grow\">\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <h4 className=\"font-bold text-lg text-foreground flex items-center gap-2\">\r\n                        <span className=\"text-2xl\">{recipe.result.emoji}</span>\r\n                        {resultName}\r\n                      </h4>\r\n                      <TooltipProvider>\r\n                        <Tooltip>\r\n                          <TooltipTrigger>\r\n                            <div className={cn(\r\n                              \"px-2 py-0.5 rounded text-xs\",\r\n                              outcome.canCraft ? \"bg-green-500/20 text-green-400\" : \"bg-red-500/20 text-red-400\"\r\n                            )}>\r\n                              {Math.round((outcome.resolvedIngredients.filter(ing => ing.hasEnough).length / recipe.ingredients.length) * 100)}% craftable\r\n                            </div>\r\n                          </TooltipTrigger>\r\n                          <TooltipContent>\r\n                            <p className=\"text-sm\">\r\n                              {outcome.canCraft \r\n                                ? t('readyToCraft')\r\n                                : t('missingIngredients')}\r\n                            </p>\r\n                          </TooltipContent>\r\n                        </Tooltip>\r\n                      </TooltipProvider>\r\n                    </div>\r\n                    <p className=\"text-sm text-muted-foreground italic mb-2\">{resultDescText}</p>\r\n                    <div className=\"text-sm space-y-1\">\r\n                      <div>\r\n                        <span className=\"font-semibold\">{t('ingredients')}:</span>\r\n                        <ul className=\"list-disc list-inside ml-4\">\r\n                          {outcome.resolvedIngredients.map((resolvedIng, i) => {\r\n                             const itemToShow = resolvedIng.usedItem;\r\n                             const requirement = resolvedIng.requirement;\r\n                             const playerQty = resolvedIng.playerQuantity;\r\n\r\n                             let itemClass = \"text-red-400\";\r\n                             if (resolvedIng.hasEnough) {\r\n                                 itemClass = resolvedIng.isSubstitute ? \"text-yellow-400\" : \"text-green-400\";\r\n                             }\r\n\r\n                             const usedItemName = itemToShow ? getTranslatedText(itemToShow.name, language, t) : '';\r\n                             const requirementName = getTranslatedText(requirement.name, language, t);\r\n                             const reqDef = resolveItemDef(getTranslatedText(requirement.name, 'en'), itemDefinitions);\r\n                             const reqDesc = reqDef ? getTranslatedText(reqDef.description, language, t) : '';\r\n\r\n                            return (\r\n                              <TooltipProvider key={i}>\r\n                                <Tooltip>\r\n                                  <TooltipTrigger asChild>\r\n                                    <li className={itemClass}>\r\n                                      {itemToShow ? usedItemName : requirementName} ({playerQty}/{requirement.quantity})\r\n                                    </li>\r\n                                  </TooltipTrigger>\r\n                                  <TooltipContent>\r\n                                    <div className=\"space-y-1\">\r\n                                      <p>{reqDesc}</p>\r\n                                      {resolvedIng.hasEnough ? (\r\n                                        <p className=\"text-green-400\">{t('ingredientAvailable')}</p>\r\n                                      ) : (\r\n                                        <p className=\"text-red-400\">{t('ingredientMissing', { quantity: resolvedIng.requirement.quantity - resolvedIng.playerQuantity })}</p>\r\n                                      )}\r\n                                    </div>\r\n                                  </TooltipContent>\r\n                                </Tooltip>\r\n                              </TooltipProvider>\r\n                            )\r\n                          })}\r\n                        </ul>\r\n                      </div>\r\n                       {recipe.requiredTool && (\r\n                        <div>\r\n                           <span className={cn(\"font-semibold\", hasRequiredTool ? 'text-green-400' : 'text-red-400')}>\r\n                             {t('requiredTool')}: {requiredToolName}\r\n                           </span>\r\n                        </div>\r\n                       )}\r\n                    </div>\r\n                  </div>\r\n                  <TooltipProvider>\r\n                    <Tooltip>\r\n                      <TooltipTrigger asChild>\r\n                        <div className=\"flex-shrink-0\">\r\n                          <Button onClick={() => onCraft(recipe, outcome)} disabled={!outcome.canCraft}>\r\n                            {outcome.canCraft ? `${t('craft')} (${outcome.chance}%)` : t('craft')}\r\n                          </Button>\r\n                        </div>\r\n                      </TooltipTrigger>\r\n                      <TooltipContent>\r\n                        {outcome.canCraft ? <p>{t('successChance', { chance: outcome.chance })}</p> : <p>{t('notEnoughIngredients')}</p>}\r\n                      </TooltipContent>\r\n                    </Tooltip>\r\n                  </TooltipProvider>\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        </ScrollArea>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\full-map-popup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\fusion-popup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslationKey' is defined but never used.","line":13,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\"use client\";\r\n\r\nimport * as React from \"react\";\r\nimport { useState } from \"react\";\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from \"@/components/ui/dialog\";\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\r\nimport { Button } from \"@/components/ui/button\";\r\n// Separator not used in this component\r\nimport { Tooltip, TooltipProvider, TooltipTrigger, TooltipContent } from \"@/components/ui/tooltip\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport type { PlayerItem, ItemDefinition } from \"@/lib/game/types\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\nimport { getTranslatedText } from \"@/lib/utils\";\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\nimport { FlaskConical, X } from \"./icons\";\r\nimport { IconRenderer } from \"@/components/ui/icon-renderer\";\r\n\r\ninterface FusionPopupProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  playerItems: PlayerItem[];\r\n  itemDefinitions: Record<string, ItemDefinition>;\r\n  onFuse: (itemsToFuse: PlayerItem[]) => void;\r\n  isLoading: boolean;\r\n}\r\n\r\nexport function FusionPopup({ open, onOpenChange, playerItems, itemDefinitions, onFuse, isLoading }: FusionPopupProps) {\r\n  const { t } = useLanguage();\r\n  const [selectedItems, setSelectedItems] = useState<PlayerItem[]>([]);\r\n\r\n  const handleSelectItem = (item: PlayerItem) => {\r\n    if (selectedItems.length >= 3) return;\r\n    // Check if we can select one more of this item\r\n    const key = getTranslatedText(item.name as any, 'en');\r\n    const countInSelection = selectedItems.filter(i => getTranslatedText(i.name as any, 'en') === key).length;\r\n    if (item.quantity > countInSelection) {\r\n      setSelectedItems(prev => [...prev, { ...item, quantity: 1 }]);\r\n    }\r\n  };\r\n\r\n  const handleRemoveItem = (index: number) => {\r\n    setSelectedItems(prev => prev.filter((_, i) => i !== index));\r\n  };\r\n\r\n  const handleFuseClick = () => {\r\n    if (!canFuse()) return;\r\n    onFuse(selectedItems);\r\n    setSelectedItems([]);\r\n    onOpenChange(false);\r\n  };\r\n\r\n  const getAvailablePlayerItems = (): PlayerItem[] => {\r\n    const availableMap = new Map<string, PlayerItem>();\r\n    playerItems.forEach(item => {\r\n      const key = getTranslatedText(item.name as any, 'en');\r\n      const selectedCount = selectedItems.filter(sel => getTranslatedText(sel.name as any, 'en') === key).length;\r\n      if (item.quantity - selectedCount > 0) {\r\n        availableMap.set(key, { ...item, quantity: item.quantity - selectedCount });\r\n      }\r\n    });\r\n    return Array.from(availableMap.values());\r\n  };\r\n\r\n  const canFuse = (): boolean => {\r\n    if (selectedItems.length < 2 || selectedItems.length > 3) return false;\r\n    const hasTool = selectedItems.some(item => {\r\n      const def = resolveItemDef(getTranslatedText(item.name as any, 'en'), itemDefinitions);\r\n      return def?.category === 'Tool';\r\n    });\r\n    return hasTool;\r\n  };\r\n\r\n  // Memoize the onOpenChange handler to avoid infinite update loops\r\n  const handleDialogOpenChange = React.useCallback(\r\n    (isOpen: boolean) => {\r\n      if (!isOpen) setSelectedItems([]);\r\n      onOpenChange(isOpen);\r\n    },\r\n    [onOpenChange]\r\n  );\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={handleDialogOpenChange}>\r\n      <DialogContent className=\"sm:max-w-2xl\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"font-headline flex items-center gap-2\">\r\n            <FlaskConical /> {t('fusionAltar')}\r\n          </DialogTitle>\r\n          <DialogDescription>{t('fusionDesc')}</DialogDescription>\r\n        </DialogHeader>\r\n        \r\n        <ScrollArea className=\"max-h-[70vh] -mx-6\">\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 px-6\">\r\n              {/* Left side: Your Inventory */}\r\n              <div className=\"flex flex-col gap-2\">\r\n                  <h3 className=\"font-semibold text-center text-muted-foreground\">{t('yourInventory')}</h3>\r\n                  <div className=\"h-72 border rounded-md p-2 bg-muted/20 overflow-y-auto\">\r\n                      <div className=\"space-y-2\">\r\n                        {getAvailablePlayerItems().map((item) => (\r\n                          // Use a stable unique key: prefer the canonical id, fall back to the English string\r\n                          <TooltipProvider key={item.id ?? getTranslatedText(item.name as any, 'en')}>\r\n                            <Tooltip>\r\n                              <TooltipTrigger asChild>\r\n                                <button\r\n                                  className=\"w-full flex justify-between items-center p-2 bg-muted rounded-md text-left text-sm cursor-pointer hover:bg-accent/20\"\r\n                                  onClick={() => handleSelectItem(item)}\r\n                                >\r\n                                    <div className=\"flex items-center gap-2\">\r\n                                    <IconRenderer icon={resolveItemDef(getTranslatedText(item.name as any, 'en'), itemDefinitions)?.emoji || item.emoji} size={20} alt={getTranslatedText(item.name as any, 'en')} />\r\n                                    <span>{getTranslatedText(item.name as any, 'en') /* EN label for layout; use language if desired */}</span>\r\n                                  </div>\r\n                                  <span className=\"font-mono text-sm font-bold\">x{item.quantity}</span>\r\n                                </button>\r\n                              </TooltipTrigger>\r\n              <TooltipContent>\r\n                {\r\n                  (() => {\r\n                    const def = resolveItemDef(getTranslatedText(item.name as any, 'en'), itemDefinitions);\r\n                    return <p>{getTranslatedText(def?.description ?? '', 'en', t)}</p>;\r\n                  })()\r\n                }\r\n              </TooltipContent>\r\n                             </Tooltip>\r\n                          </TooltipProvider>\r\n                        ))}\r\n                      </div>\r\n                  </div>\r\n              </div>\r\n              {/* Right side: Fusion Slots */}\r\n              <div className=\"flex flex-col gap-2\">\r\n                   <h3 className=\"font-semibold text-center text-muted-foreground\">{t('fusionSlots')}</h3>\r\n                   <div className=\"h-72 border rounded-md p-4 bg-muted/20 flex flex-col justify-between\">\r\n                      <div className=\"space-y-3\">\r\n                          {[0, 1, 2].map(index => (\r\n                              <div key={index} className=\"h-14 w-full bg-background rounded-md border-2 border-dashed flex items-center justify-between px-4\">\r\n                                  {selectedItems[index] ? (\r\n                                      <>\r\n                                          <div className=\"flex items-center gap-2\">\r\n                                              <IconRenderer icon={resolveItemDef(getTranslatedText(selectedItems[index].name as any, 'en'), itemDefinitions)?.emoji || selectedItems[index].emoji} size={20} alt={getTranslatedText(selectedItems[index].name as any, 'en')} />\r\n                                              <span className=\"text-sm\">{getTranslatedText(selectedItems[index].name as any, 'en', t)}</span>\r\n                                          </div>\r\n                                          <Button variant=\"ghost\" size=\"icon\" className=\"h-6 w-6\" onClick={() => handleRemoveItem(index)}>\r\n                                              <X className=\"h-4 w-4\"/>\r\n                                          </Button>\r\n                                      </>\r\n                                  ) : (\r\n                                      <span className=\"text-sm text-muted-foreground italic\">{t('emptySlot')}</span>\r\n                                  )}\r\n                              </div>\r\n                          ))}\r\n                      </div>\r\n                      <Button onClick={handleFuseClick} disabled={!canFuse() || isLoading}>\r\n                          {isLoading ? t('fusing') : t('fuseItems')}\r\n                      </Button>\r\n                   </div>\r\n              </div>\r\n          </div>\r\n        </ScrollArea>\r\n\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\game-layout.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HudIconProgress' is defined but never used.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslationKey' is defined but never used.","line":35,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Heart' is defined but never used.","line":36,"column":119,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":124},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Zap' is defined but never used.","line":36,"column":126,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":129},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Footprints' is defined but never used.","line":36,"column":131,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":141},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Beef' is defined but never used.","line":36,"column":166,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":170},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleKeyDown' is assigned a value but never used.","line":284,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mainActions' is assigned a value but never used.","line":315,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport React, { useState, useEffect, useCallback, useRef } from \"react\";\r\nimport { Minimap } from \"@/components/game/minimap\";\r\nimport { StatusPopup } from \"@/components/game/status-popup\";\r\nimport { InventoryPopup } from \"@/components/game/inventory-popup\";\r\nimport { FullMapPopup } from \"@/components/game/full-map-popup\";\r\nimport { CraftingPopup } from \"@/components/game/crafting-popup\";\r\nimport { BuildingPopup } from \"@/components/game/building-popup\";\r\nimport { TutorialPopup } from \"@/components/game/tutorial-popup\";\r\nimport { FusionPopup } from \"@/components/game/fusion-popup\";\r\nimport { PwaInstallPopup } from \"@/components/game/pwa-install-popup\";\r\nimport { SettingsPopup } from \"@/components/game/settings-popup\";\r\nimport { Controls } from \"@/components/game/controls\";\r\nimport BottomActionBar from \"@/components/game/bottom-action-bar\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Input } from \"@/components/ui/input\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"@/components/ui/tooltip\";\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from \"@/components/ui/dialog\";\r\nimport { Checkbox } from \"@/components/ui/checkbox\";\r\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuSeparator, DropdownMenuTrigger } from \"@/components/ui/dropdown-menu\";\r\nimport { AlertDialog, AlertDialogAction, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from \"@/components/ui/alert-dialog\";\r\nimport { HudIconProgress } from \"@/components/game/hud-icon-progress\";\r\nimport HudIconHealth from \"@/components/game/hud-icon-health\";\r\nimport HudIconStamina from \"@/components/game/hud-icon-stamina\";\r\nimport HudIconMana from \"@/components/game/hud-icon-mana\";\r\nimport HudIconHunger from \"@/components/game/hud-icon-hunger\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport { useSettings } from \"@/context/settings-context\";\r\nimport useKeyboardBindings from \"@/hooks/use-keyboard-bindings\";\r\nimport { useGameEngine } from \"@/hooks/use-game-engine\";\r\nimport type { Structure, Action, NarrativeEntry } from \"@/lib/game/types\";\r\nimport { cn, getTranslatedText } from \"@/lib/utils\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\nimport { Backpack, Shield, Cpu, Hammer, WandSparkles, Home, BedDouble, Thermometer, LifeBuoy, FlaskConical, Settings, Heart, Zap, Footprints, Loader2, Menu, LogOut, Beef } from \"./icons\";\r\nimport { IconRenderer } from \"@/components/ui/icon-renderer\";\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\nimport { logger } from \"@/lib/logger\";\r\n\r\n\r\ninterface GameLayoutProps {\r\n    gameSlot: number;\r\n}\r\n\r\nexport default function GameLayout(props: GameLayoutProps) {\r\n    // Guard: If gameSlot is not a valid number, show error and do not render game logic\r\n    if (typeof props.gameSlot !== 'number' || isNaN(props.gameSlot) || props.gameSlot < 0) {\r\n        return (\r\n            <div className=\"flex flex-col items-center justify-center h-full text-red-600\">\r\n                <h2>Invalid or missing game slot.</h2>\r\n                <p>Please return to the main menu and select a valid save slot.</p>\r\n            </div>\r\n        );\r\n    }\r\n    const { t, language } = useLanguage();\r\n    const { settings } = useSettings();\r\n    const [isDesktop, setIsDesktop] = useState(false);\r\n    const [showNarrativeDesktop, setShowNarrativeDesktop] = useState(true);\r\n    // Dev-only: track mount/unmount counts to help diagnose unexpected remounts\r\n    if (process.env.NODE_ENV !== 'production') {\r\n         \r\n        const g = globalThis as any;\r\n        if (!g.__gameLayoutMountCount) g.__gameLayoutMountCount = 0;\r\n    }\r\n    \r\n    const {\r\n        world,\r\n        recipes,\r\n        buildableStructures,\r\n        playerStats,\r\n        playerPosition,\r\n        narrativeLog,\r\n        isLoading,\r\n        isGameOver,\r\n        finalWorldSetup,\r\n        customItemDefinitions,\r\n        currentChunk,\r\n        turn,\r\n    biomeDefinitions,\r\n        isLoaded,\r\n        handleMove,\r\n        handleAttack,\r\n        handleAction,\r\n        handleCustomAction,\r\n        handleCraft,\r\n        handleBuild,\r\n        handleItemUsed,\r\n        handleUseSkill,\r\n        handleRest,\r\n        handleFuseItems,\r\n        handleRequestQuestHint,\r\n        handleEquipItem,\r\n        handleUnequipItem,\r\n    handleReturnToMenu,\r\n        narrativeContainerRef,\r\n    } = useGameEngine(props);\r\n\r\n    // increment mount counter for GameLayout and expose to window for quick checks\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV === 'production') return;\r\n         \r\n        const g = globalThis as any;\r\n        g.__gameLayoutMountCount = (g.__gameLayoutMountCount || 0) + 1;\r\n        // also expose on window for console inspection\r\n        try { (window as any).__GAME_LAYOUT_MOUNT_COUNT = g.__gameLayoutMountCount; } catch {}\r\n        logger.debug('[GameLayout] mounted - count', { count: g.__gameLayoutMountCount });\r\n        return () => {\r\n            g.__gameLayoutMountCount = Math.max(0, (g.__gameLayoutMountCount || 1) - 1);\r\n            try { (window as any).__GAME_LAYOUT_MOUNT_COUNT = g.__gameLayoutMountCount; } catch {}\r\n            logger.debug('[GameLayout] unmounted - count', { count: g.__gameLayoutMountCount });\r\n        };\r\n    }, []);\r\n\r\n    // Track whether we are on a desktop-sized viewport so we can render the desktop layout\r\n    useEffect(() => {\r\n        const onResize = () => setIsDesktop(typeof window !== 'undefined' && window.innerWidth >= 1024);\r\n        onResize();\r\n        window.addEventListener('resize', onResize);\r\n        return () => window.removeEventListener('resize', onResize);\r\n    }, []);\r\n\r\n    \r\n\r\n    const [isStatusOpen, setStatusOpen] = useState(false);\r\n    const [isInventoryOpen, setInventoryOpen] = useState(false);\r\n    const [isCraftingOpen, setCraftingOpen] = useState(false);\r\n    const [isBuildingOpen, setBuildingOpen] = useState(false);\r\n    const [isFusionOpen, setFusionOpen] = useState(false);\r\n    const [isFullMapOpen, setIsFullMapOpen] = useState(false);\r\n    const [isTutorialOpen, setTutorialOpen] = useState(false);\r\n    const [isSettingsOpen, setSettingsOpen] = useState(false);\r\n    const [showInstallPopup, setShowInstallPopup] = useState(false);\r\n    const [inputValue, setInputValue] = useState(\"\");\r\n    const [isAvailableActionsOpen, setAvailableActionsOpen] = useState(false);\r\n    const [isCustomDialogOpen, setCustomDialogOpen] = useState(false);\r\n    const [customDialogValue, setCustomDialogValue] = useState(\"\");\r\n    const [isPickupDialogOpen, setPickupDialogOpen] = useState(false);\r\n    const [selectedPickupIds, setSelectedPickupIds] = useState<number[]>([]);\r\n    \r\n    const customActionInputRef = useRef<HTMLInputElement>(null);\r\n\r\n    const focusCustomActionInput = useCallback(() => {\r\n        setTimeout(() => {\r\n                        try {\r\n                            const el = customActionInputRef.current as (HTMLInputElement | null);\r\n                            if (!el) return;\r\n                            const isDesktop = typeof window !== 'undefined' && window.innerWidth >= 768;\r\n                            // Respect user setting for preventing control-panel scrolling\r\n                            const prevent = settings?.controlsPreventScroll ?? true;\r\n                            if (isDesktop && prevent) {\r\n                                // @ts-ignore - some TS DOM libs may not include the options overload\r\n                                el.focus?.({ preventScroll: true });\r\n                            } else {\r\n                                el.focus?.();\r\n                            }\r\n                        } catch {\r\n                            try { customActionInputRef.current?.focus(); } catch {}\r\n                        }\r\n        }, 0);\r\n            }, [settings]);\r\n\r\n    // Use centralized keyboard bindings hook for all global key handling\r\n    useKeyboardBindings({\r\n        handlers: {\r\n            move: (dir: 'north' | 'south' | 'west' | 'east') => handleMove(dir),\r\n            attack: () => handleAttack(),\r\n            openInventory: () => setInventoryOpen(true),\r\n            openStatus: () => setStatusOpen(true),\r\n            openMap: () => setIsFullMapOpen(true),\r\n            customAction: () => setCustomDialogOpen(true),\r\n            pickUp: () => { setPickupDialogOpen(true); setSelectedPickupIds([]); },\r\n            hotkey: (index: number) => {\r\n                // Prefer skills mapped to hotkeys (leftmost skills). If missing, fall back to available actions.\r\n                try {\r\n                    const idx = index - 1;\r\n                    const skill = playerStats?.skills?.[idx];\r\n                    if (skill) {\r\n                        const skillName = getTranslatedText(skill.name, language, t);\r\n                        handleUseSkill(skillName);\r\n                        return;\r\n                    }\r\n\r\n                    // If no skill in that slot, attempt to trigger the corresponding available action\r\n                    const action = otherActions[idx] || pickUpActions[idx];\r\n                    if (action) {\r\n                        handleAction(action.id);\r\n                        return;\r\n                    }\r\n                } catch (e) {\r\n                    logger.debug('[GameLayout] hotkey handler error', e);\r\n                }\r\n            }\r\n        },\r\n        popupOpen: isSettingsOpen || isFullMapOpen || isInventoryOpen || isStatusOpen || isCraftingOpen || isBuildingOpen || isFusionOpen || isTutorialOpen,\r\n        focusCustomActionInput: focusCustomActionInput,\r\n        enabled: true,\r\n        movementWhileTyping: true,\r\n    });\r\n\r\n    const handleActionClick = (actionId: number) => {\r\n        handleAction(actionId);\r\n        focusCustomActionInput();\r\n    };\r\n\r\n    const onCustomActionSubmit = () => {\r\n        if (inputValue.trim()) {\r\n            handleCustomAction(inputValue);\r\n            setInputValue(\"\");\r\n        }\r\n        focusCustomActionInput();\r\n    };\r\n    const onCustomDialogSubmit = () => {\r\n        const v = customDialogValue.trim();\r\n        if (v) {\r\n            handleCustomAction(v);\r\n            setCustomDialogValue(\"\");\r\n        }\r\n        setCustomDialogOpen(false);\r\n        focusCustomActionInput();\r\n    };\r\n    \r\n    useEffect(() => {\r\n        const promptShown = localStorage.getItem('pwaInstallPromptShown');\r\n        if (!promptShown) {\r\n            setShowInstallPopup(true);\r\n            localStorage.setItem('pwaInstallPromptShown', 'true');\r\n        }\r\n    }, []);\r\n\r\n    const generateMapGrid = useCallback(() => {\r\n        if (!isLoaded || !finalWorldSetup) {\r\n            logger.warn(`[GameLayout] Grid generation SKIPPED. isLoaded: ${isLoaded} | finalWorldSetup exists: ${!!finalWorldSetup}`);\r\n            return [];\r\n        }\r\n        \r\n        // Calculate visibility grid size (3x3 around player)\r\n        const visibilityRadius = 1; // 3x3 grid for direct visibility\r\n        // Calculate total grid size (5x5 for minimap display, but with visibility rules)\r\n        const displayRadius = 2; // 5x5 grid for display\r\n        const size = displayRadius * 2 + 1;\r\n        const grid = Array.from({ length: size }, () => Array(size).fill(null));\r\n\r\n        for (let gy = 0; gy < size; gy++) {\r\n            for (let gx = 0; gx < size; gx++) {\r\n                const wx = playerPosition.x - displayRadius + gx;\r\n                const wy = playerPosition.y + displayRadius - gy;\r\n                const chunkKey = `${wx},${wy}`;\r\n                \r\n                // Check if this chunk is within the 3x3 visibility radius\r\n                const chunk = world[chunkKey];\r\n                if (chunk) {\r\n                    const distanceFromPlayer = Math.max(\r\n                        Math.abs(wx - playerPosition.x),\r\n                        Math.abs(wy - playerPosition.y)\r\n                    );\r\n                    \r\n                    // Mark chunks within visibility radius as explored\r\n                    if (distanceFromPlayer <= visibilityRadius) {\r\n                        chunk.explored = true;\r\n                        chunk.lastVisited = turn;\r\n                    }\r\n                }\r\n\r\n                grid[gy][gx] = chunk;\r\n            }\r\n        }\r\n        return grid;\r\n    }, [world, playerPosition.x, playerPosition.y, finalWorldSetup, isLoaded, turn]);\r\n    \r\n    const restingPlace = currentChunk?.structures?.find((s: Structure) => s.restEffect);\r\n    \r\n    if (!isLoaded || !finalWorldSetup || !currentChunk) {\r\n        return (\r\n            <div className=\"flex items-center justify-center min-h-dvh bg-background text-foreground\">\r\n                <div className=\"flex flex-col items-center gap-2 mt-4 text-muted-foreground\">\r\n                    <Loader2 className=\"h-8 w-8 animate-spin\" />\r\n                    <p className=\"mt-2\">{t('loadingAdventure')}</p>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n    \r\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\r\n        if (e.key === 'Enter') {\r\n          e.preventDefault();\r\n          onCustomActionSubmit();\r\n        }\r\n    };\r\n    \r\n    const worldNameText = getTranslatedText(finalWorldSetup.worldName, language, t);\r\n\r\n    // Stat display helpers for HUD numeric labels\r\n    const hpVal = Number(playerStats.hp ?? 0);\r\n    const hpMax = Number(playerStats.maxHp ?? 100);\r\n    const hpPct = hpMax > 0 ? hpVal / hpMax : 0;\r\n\r\n    const manaVal = Number(playerStats.mana ?? 0);\r\n    const manaMax = Number(playerStats.maxMana ?? 50);\r\n    const manaPct = manaMax > 0 ? manaVal / manaMax : 0;\r\n\r\n    const stamVal = Number(playerStats.stamina ?? 0);\r\n    const stamMax = Number(playerStats.maxStamina ?? 100);\r\n    const stamPct = stamMax > 0 ? stamVal / stamMax : 0;\r\n\r\n    const hungerVal = Number(playerStats.hunger ?? 0);\r\n    const hungerMax = Number(playerStats.maxHunger ?? 100);\r\n    // `playerStats.hunger` is a fullness-like value (higher means more full),\r\n    // so the HUD percent should directly reflect hungerVal / hungerMax.\r\n    const hungerPct = hungerMax > 0 ? Math.max(0, Math.min(1, hungerVal / hungerMax)) : 0;\r\n\r\n    const statColorClass = (pct: number) => pct <= 0.3 ? 'text-destructive' : pct <= 0.6 ? 'text-amber-500' : 'text-foreground';\r\n\r\n    // Consolidated main actions trigger: single button that opens a dropdown with the full action set.\r\n    const mainActions = (\r\n        <DropdownMenu>\r\n            <DropdownMenuTrigger asChild>\r\n                <Button variant=\"ghost\" className=\"ml-2\" aria-label={t('mainActions') || 'Main actions'}>\r\n                    {t('mainActions') || 'Actions'}\r\n                </Button>\r\n            </DropdownMenuTrigger>\r\n            <DropdownMenuContent align=\"start\" className=\"w-64\">\r\n                <div className=\"grid grid-cols-1 gap-2 p-2\">\r\n                    <Button variant=\"ghost\" className=\"justify-start\" onClick={() => { setStatusOpen(true); focusCustomActionInput(); }}>{t('statusShort') || 'Status'}</Button>\r\n                    <Button variant=\"ghost\" className=\"justify-start\" onClick={() => { setInventoryOpen(true); focusCustomActionInput(); }}>{t('inventoryShort') || 'Inventory'}</Button>\r\n                    <Button variant=\"ghost\" className=\"justify-start\" onClick={() => { setCraftingOpen(true); focusCustomActionInput(); }}>{t('craftingShort') || 'Craft'}</Button>\r\n                    <Button variant=\"ghost\" className=\"justify-start\" onClick={() => { setBuildingOpen(true); focusCustomActionInput(); }}>{t('buildingShort') || 'Build'}</Button>\r\n                    <Button variant=\"ghost\" className=\"justify-start\" onClick={() => { setFusionOpen(true); focusCustomActionInput(); }}>{t('fusionShort') || 'Fuse'}</Button>\r\n                </div>\r\n            </DropdownMenuContent>\r\n        </DropdownMenu>\r\n    );\r\n\r\n    // Pickup action grouping: collect pick-up actions to present in a single dialog\r\n    const pickUpActions = (currentChunk?.actions || []).filter((a: Action) => a.textKey === 'pickUpAction_item');\r\n    const otherActions = (currentChunk?.actions || []).filter((a: Action) => a.textKey !== 'pickUpAction_item');\r\n\r\n    // Helpers for the pickup dialog selection\r\n    const togglePickupSelection = (id: number) => {\r\n        setSelectedPickupIds(prev => (prev.includes(id) ? prev.filter(x => x !== id) : [...prev, id]));\r\n    };\r\n\r\n    const handlePickupConfirm = () => {\r\n        if (!selectedPickupIds || selectedPickupIds.length === 0) {\r\n            setPickupDialogOpen(false);\r\n            return;\r\n        }\r\n\r\n        // Execute each selected pick-up action using the existing action handler\r\n        selectedPickupIds.forEach((actionId) => {\r\n            try {\r\n                handleAction(actionId);\r\n            } catch (e) {\r\n                logger.error('Pickup action failed for id', { actionId, error: e });\r\n            }\r\n        });\r\n\r\n        // Reset dialog state and focus input\r\n        setSelectedPickupIds([]);\r\n        setPickupDialogOpen(false);\r\n        focusCustomActionInput();\r\n    };\r\n\r\n\r\n    return (\r\n        <TooltipProvider>\r\n            <div className=\"flex flex-col md:flex-row md:h-dvh bg-background text-foreground font-body\" style={{ ['--aside-w' as any]: 'min(462px,36vw)' }}>\r\n                {/* Left Panel: Narrative */}\r\n                <div className={`${isDesktop && !showNarrativeDesktop ? 'md:hidden' : ''} w-full md:flex-1 flex flex-col md:overflow-hidden md:pb-16`}>\r\n                    <header className=\"p-4 border-b flex-shrink-0 flex flex-col md:flex-row md:items-center md:justify-between gap-3\">\r\n                        <div className=\"flex items-center gap-3 w-full md:max-w-3xl\">\r\n                            <h1 className=\"text-2xl font-bold font-headline\">{worldNameText}</h1>\r\n                            {/* On desktop (non-legacy layout), show main actions next to the world title as inline icon buttons */}\r\n                            {isDesktop && !settings?.useLegacyLayout && (\r\n                                <div className=\"ml-6 hidden md:flex md:items-center md:flex-1 gap-2\">\r\n                                    <div className=\"flex items-center gap-2\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button aria-label={t('statusShort') || 'Status'} variant=\"outline\" size=\"icon\" onClick={() => { setStatusOpen(true); focusCustomActionInput(); }}><Shield /></Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('statusShort') || 'Status'}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button aria-label={t('inventoryShort') || 'Inventory'} variant=\"outline\" size=\"icon\" onClick={() => { setInventoryOpen(true); focusCustomActionInput(); }}><Backpack /></Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('inventoryShort') || 'Inventory'}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button aria-label={t('craftingShort') || 'Craft'} variant=\"outline\" size=\"icon\" onClick={() => { setCraftingOpen(true); focusCustomActionInput(); }}><Hammer /></Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('craftingShort') || 'Craft'}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button aria-label={t('buildingShort') || 'Build'} variant=\"outline\" size=\"icon\" onClick={() => { setBuildingOpen(true); focusCustomActionInput(); }}><Home /></Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('buildingShort') || 'Build'}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button aria-label={t('fusionShort') || 'Fuse'} variant=\"outline\" size=\"icon\" onClick={() => { setFusionOpen(true); focusCustomActionInput(); }}><FlaskConical /></Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('fusionShort') || 'Fuse'}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                    </div>\r\n                                </div>\r\n                            )}\r\n                        </div>\r\n                        <div className=\"flex items-center gap-2\">\r\n                            {/* Desktop-only toggle for narrative visibility */}\r\n                            <Button variant=\"ghost\" size=\"icon\" className=\"hidden md:inline-flex\" onClick={() => setShowNarrativeDesktop(s => !s)} aria-label={showNarrativeDesktop ? (t('hideNarrative') || 'Hide narrative') : (t('showNarrative') || 'Show narrative')}>\r\n                                {showNarrativeDesktop ? 'Hide' : 'Show'}\r\n                            </Button>\r\n                            <DropdownMenu>\r\n                            <DropdownMenuTrigger asChild>\r\n                                <Button variant=\"ghost\" size=\"icon\" aria-label={t('openMenu') || 'Open menu'}>\r\n                                    <Menu />\r\n                                </Button>\r\n                            </DropdownMenuTrigger>\r\n                            <DropdownMenuContent align=\"end\">\r\n                                <DropdownMenuItem onClick={() => { setTutorialOpen(true); focusCustomActionInput(); }}>\r\n                                    <LifeBuoy className=\"mr-2 h-4 w-4\" />\r\n                                    <span>{t('tutorialTitle')}</span>\r\n                                </DropdownMenuItem>\r\n                                <DropdownMenuItem onClick={() => { setSettingsOpen(true); focusCustomActionInput(); }}>\r\n                                    <Settings className=\"mr-2 h-4 w-4\" />\r\n                                    <span>{t('gameSettings')}</span>\r\n                                </DropdownMenuItem>\r\n                                <DropdownMenuSeparator />\r\n                                <DropdownMenuItem onClick={handleReturnToMenu}>\r\n                                    <LogOut className=\"mr-2 h-4 w-4\" />\r\n                                    <span>{t('returnToMenu')}</span>\r\n                                </DropdownMenuItem>\r\n                            </DropdownMenuContent>\r\n                        </DropdownMenu>\r\n                        </div>\r\n                    </header>\r\n\r\n                    <main ref={narrativeContainerRef} className=\"flex-grow p-4 md:p-6 overflow-y-auto max-h-[50dvh] md:max-h-full hide-scrollbar\">\r\n                        <div className=\"prose prose-stone dark:prose-invert max-w-4xl mx-auto\">\r\n                            {(() => {\r\n                                // Defensive render-time dedupe: ensure we never render multiple elements with the same key.\r\n                                // If duplicates exist in state due to a transient race, keep the last occurrence (most recent)\r\n                                // and log the condition to aid debugging.\r\n                                const map = new Map(narrativeLog.map((e: NarrativeEntry) => [e.id, e]));\r\n                                const deduped = Array.from(map.values());\r\n                                if (deduped.length !== narrativeLog.length) {\r\n                                     \r\n                                    console.warn('[GameLayout] narrativeLog contained duplicate ids; rendering deduped list.');\r\n                                }\r\n                                return deduped.map((entry: NarrativeEntry) => (\r\n                                    <p key={entry.id} id={entry.id} className={cn(\"animate-in fade-in duration-500 whitespace-pre-line\",\r\n                                        (String(entry.type) === 'action' || String(entry.type) === 'monologue') ? 'italic text-muted-foreground' : '',\r\n                                        entry.type === 'system' ? 'font-semibold text-accent' : ''\r\n                                    )}>\r\n                                        {getTranslatedText(entry.text, language, t)}\r\n                                    </p>\r\n                                ));\r\n                            })()}\r\n                            {isLoading && (\r\n                                <div className=\"flex items-center gap-2 text-muted-foreground italic mt-4\">\r\n                                    <Cpu className=\"h-4 w-4 animate-pulse\" />\r\n                                    <p>AI is thinking...</p>\r\n                                </div>\r\n                            )}\r\nc├│                         </div>\r\n                    </main>\r\n\r\n                    {/* Desktop horizontal action bar removed - main actions are now inline in the header for desktop non-legacy layout */}\r\n\r\n                </div>\r\n\r\n                {/* Right Panel: Controls & Actions */}\r\n                <aside className=\"w-full md:w-[min(462px,36vw)] md:flex-none bg-card border-l pt-4 pb-0 px-4 md:pt-6 md:pb-0 md:px-6 flex flex-col gap-6 min-h-0\">\r\n                    {/* Top Section - HUD & Minimap */}\r\n                    <div className=\"flex-shrink-0 flex flex-col gap-6\">\r\n                        {isDesktop && !settings?.useLegacyLayout ? (\r\n                            // Desktop (non-legacy): show map above HUD in the right panel\r\n                            <>\r\n                                {/* Minimap */}\r\n                                <div className=\"flex flex-col items-center gap-2\">\r\n                                    <h3 className=\"text-lg font-headline font-semibold text-center text-foreground/80 cursor-pointer hover:text-accent transition-colors\" onClick={() => { setIsFullMapOpen(true); focusCustomActionInput(); }}>{t('minimap')}</h3>\r\n                                    <div className=\"flex items-center justify-center gap-x-4 gap-y-1 text-sm text-muted-foreground flex-wrap\">\r\n                                        <Tooltip><TooltipTrigger asChild><div className=\"flex items-center gap-1 cursor-default\"><Thermometer className=\"h-4 w-4 text-orange-500\" /><span>{t('environmentTemperature', { temp: currentChunk?.temperature?.toFixed(0) || 'N/A' })}</span></div></TooltipTrigger><TooltipContent><p>{t('environmentTempTooltip')}</p></TooltipContent></Tooltip>\r\n                                        <Tooltip><TooltipTrigger asChild><div className=\"flex items-center gap-1 cursor-default\"><Thermometer className=\"h-4 w-4 text-rose-500\" /><span>{t('hudBodyTemp', { temp: playerStats.bodyTemperature.toFixed(1) })}</span></div></TooltipTrigger><TooltipContent><p>{t('bodyTempDesc')}</p></TooltipContent></Tooltip>\r\n                                    </div>\r\n                                    <Minimap grid={generateMapGrid()} playerPosition={playerPosition} turn={turn} biomeDefinitions={biomeDefinitions} />\r\n                                </div>\r\n\r\n                                {/* HUD */}\r\n                                <div className=\"grid grid-cols-4 gap-x-4 gap-y-2 text-sm justify-items-center\">\r\n                                    {/* Health (use new HudIconHealth) */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconHealth percent={Math.max(0, Math.min(1, hpPct))} size={40} />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudHealth') ?? 'Health'}: {Math.round(playerStats.hp ?? 0)}/{playerStats.maxHp ?? 100}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(hpPct)}`}>{Math.round(hpVal)}/{hpMax}</span>\r\n                                    </div>\r\n\r\n                                    {/* Mana */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconMana percent={Math.max(0, Math.min(1, manaPct))} size={40} />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudMana') ?? 'Mana'}: {Math.round(playerStats.mana ?? 0)}/{playerStats.maxMana ?? 50}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(manaPct)}`}>{Math.round(manaVal)}/{manaMax}</span>\r\n                                    </div>\r\n\r\n                                    {/* Stamina */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconStamina percent={Math.max(0, Math.min(1, stamPct))} size={40} className=\"\" />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudStamina') ?? 'Stamina'}: {Math.round(playerStats.stamina ?? 0)}/{playerStats.maxStamina ?? 100}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(stamPct)}`}>{Math.round(stamVal)}/{stamMax}</span>\r\n                                    </div>\r\n\r\n                                    {/* Hunger */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button variant=\"ghost\" size=\"icon\" aria-label={t('hudHunger') ?? 'Hunger'} onClick={() => { setStatusOpen(true); focusCustomActionInput(); }} className=\"p-0\">\r\n                                                    <HudIconHunger percent={Math.max(0, Math.min(1, hungerPct))} size={40} />\r\n                                                </Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudHunger') ?? 'Hunger'}: {Math.round(playerStats.hunger ?? 0)}/{playerStats.maxHunger ?? 100}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <button onClick={() => { setStatusOpen(true); focusCustomActionInput(); }} className={`text-xs mt-1 ${statColorClass(hungerPct)} focus:outline-none`}>{Math.round(hungerVal)}/{hungerMax}</button>\r\n                                    </div>\r\n                                </div>\r\n                            </>\r\n                        ) : (\r\n                            // Default (mobile / legacy): HUD then Minimap\r\n                            <>\r\n                                {/* HUD */}\r\n                                <div className=\"grid grid-cols-4 gap-x-4 gap-y-2 text-sm justify-items-center\">\r\n                                    {/* Health (mobile) */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconHealth percent={Math.max(0, Math.min(1, hpPct))} size={40} />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudHealth') ?? 'Health'}: {Math.round(playerStats.hp ?? 0)}/{playerStats.maxHp ?? 100}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(hpPct)}`}>{Math.round(hpVal)}/{hpMax}</span>\r\n                                    </div>\r\n\r\n                                    {/* Mana (mobile) */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconMana percent={Math.max(0, Math.min(1, manaPct))} size={40} />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudMana') ?? 'Mana'}: {Math.round(playerStats.mana ?? 0)}/{playerStats.maxMana ?? 50}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(manaPct)}`}>{Math.round(manaVal)}/{manaMax}</span>\r\n                                    </div>\r\n\r\n                                    {/* Stamina (mobile) */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconStamina percent={Math.max(0, Math.min(1, stamPct))} size={40} className=\"\" />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudStamina') ?? 'Stamina'}: {Math.round(playerStats.stamina ?? 0)}/{playerStats.maxStamina ?? 100}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(stamPct)}`}>{Math.round(stamVal)}/{stamMax}</span>\r\n                                    </div>\r\n\r\n                                    {/* Hunger (mobile) */}\r\n                                    <div className=\"flex flex-col items-center\">\r\n                                        <Tooltip>\r\n                                            <TooltipTrigger asChild>\r\n                                                <div>\r\n                                                    <HudIconHunger percent={Math.max(0, Math.min(1, hungerPct))} size={40} />\r\n                                                </div>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{t('hudHunger') ?? 'Hunger'}: {Math.round(playerStats.hunger ?? 0)}/{playerStats.maxHunger ?? 100}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                        <span className={`text-xs mt-1 ${statColorClass(hungerPct)}`}>{Math.round(hungerVal)}/{hungerMax}</span>\r\n                                    </div>\r\n                                </div>\r\n\r\n                                {/* Minimap */}\r\n                                <div className=\"flex flex-col items-center gap-2\">\r\n                                    <h3 className=\"text-lg font-headline font-semibold text-center text-foreground/80 cursor-pointer hover:text-accent transition-colors\" onClick={() => { setIsFullMapOpen(true); focusCustomActionInput(); }}>{t('minimap')}</h3>\r\n                                    <div className=\"flex items-center justify-center gap-x-4 gap-y-1 text-sm text-muted-foreground flex-wrap\">\r\n                                        <Tooltip><TooltipTrigger asChild><div className=\"flex items-center gap-1 cursor-default\"><Thermometer className=\"h-4 w-4 text-orange-500\" /><span>{t('environmentTemperature', { temp: currentChunk?.temperature?.toFixed(0) || 'N/A' })}</span></div></TooltipTrigger><TooltipContent><p>{t('environmentTempTooltip')}</p></TooltipContent></Tooltip>\r\n                                        <Tooltip><TooltipTrigger asChild><div className=\"flex items-center gap-1 cursor-default\"><Thermometer className=\"h-4 w-4 text-rose-500\" /><span>{t('hudBodyTemp', { temp: playerStats.bodyTemperature.toFixed(1) })}</span></div></TooltipTrigger><TooltipContent><p>{t('bodyTempDesc')}</p></TooltipContent></Tooltip>\r\n                                    </div>\r\n                                    <Minimap grid={generateMapGrid()} playerPosition={playerPosition} turn={turn} biomeDefinitions={biomeDefinitions} />\r\n                                </div>\r\n                            </>\r\n                        )}\r\n                    </div>\r\n                    \r\n                    {/* Bottom Section - Actions (desktop shows horizontal bar instead unless legacy layout is enabled) */}\r\n                    <div className=\"flex flex-col gap-4 flex-grow\">\r\n                        {/* Controls (mobile only). On desktop we show the bottom fixed action bar instead. */}\r\n                        <div className=\"flex items-center justify-between gap-4\">\r\n                            {!isDesktop && (\r\n                                <Controls onMove={(dir) => { handleMove(dir); focusCustomActionInput(); }} onAttack={() => { handleAttack(); focusCustomActionInput(); }} />\r\n                            )}\r\n                        </div>\r\n\r\n                        {/* Horizontal bottom action bar: skills (left), available actions (center), main actions (right) */}\r\n                        <div className=\"w-full bg-transparent p-3 flex items-center gap-3 overflow-x-auto md:hidden\">\r\n                            {/* Skills (left) */}\r\n                            <div className=\"flex items-center gap-2\">\r\n                                {playerStats.skills?.map((skill: import('@/lib/game/types').Skill) => {\r\n                                    const skillName = getTranslatedText(skill.name, language, t);\r\n                                    return (\r\n                                        <Tooltip key={skillName}>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button variant=\"secondary\" className=\"text-xs\" onClick={() => { handleUseSkill(skillName); focusCustomActionInput(); }} disabled={isLoading || playerStats.mana < skill.manaCost}>\r\n                                                    <WandSparkles className=\"h-4 w-4 mr-2\" />\r\n                                                    <span className=\"hidden sm:inline\">{skillName}</span>\r\n                                                </Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{getTranslatedText(skill.description, language, t)}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n\r\n                            {/* Available actions (center) */}\r\n                            <div className=\"flex-1 flex items-center justify-center gap-2\">\r\n                                {pickUpActions.length > 0 && (\r\n                                    <Button variant=\"accent\" onClick={() => { setPickupDialogOpen(true); setSelectedPickupIds([]); }}>{t('pickUpItems') || 'Pick up items'}</Button>\r\n                                )}\r\n                                {otherActions.map((action: Action) => {\r\n                                    const actionText = getTranslatedText({ key: action.textKey, params: action.params }, language, t);\r\n                                    return (\r\n                                        <Tooltip key={action.id}>\r\n                                            <TooltipTrigger asChild>\r\n                                                <Button variant=\"secondary\" className=\"text-sm\" onClick={() => handleActionClick(action.id)} disabled={isLoading}>{actionText}</Button>\r\n                                            </TooltipTrigger>\r\n                                            <TooltipContent><p>{actionText}</p></TooltipContent>\r\n                                        </Tooltip>\r\n                                    );\r\n                                })}\r\n                            </div>\r\n\r\n                            {/* Main actions & menu (right) */}\r\n                            <div className=\"ml-auto flex items-center gap-2\">\r\n                                <Button aria-label={t('statusShort') || 'Status'} variant=\"outline\" size=\"icon\" onClick={() => { setStatusOpen(true); focusCustomActionInput(); }}><Shield /></Button>\r\n                                <Button aria-label={t('inventoryShort') || 'Inventory'} variant=\"outline\" size=\"icon\" onClick={() => { setInventoryOpen(true); focusCustomActionInput(); }}><Backpack /></Button>\r\n                                <Button aria-label={t('craftingShort') || 'Crafting'} variant=\"outline\" size=\"icon\" onClick={() => { setCraftingOpen(true); focusCustomActionInput(); }}><Hammer /></Button>\r\n                                <Button aria-label={t('buildingShort') || 'Build'} variant=\"outline\" size=\"icon\" onClick={() => { setBuildingOpen(true); focusCustomActionInput(); }}><Home /></Button>\r\n                                <Button aria-label={t('fusionShort') || 'Fuse'} variant=\"outline\" size=\"icon\" onClick={() => { setFusionOpen(true); focusCustomActionInput(); }}><FlaskConical /></Button>\r\n                                <Button variant=\"outline\" onClick={() => setAvailableActionsOpen(true)}>{t('actions') || 'Actions'}</Button>\r\n                                {/* Custom action removed from the map/HUD column to keep it map+HUD only */}\r\n                            </div>\r\n                        </div>\r\n\r\n                        {/* Desktop bottom action bar (fixed) inserted so it doesn't overlap the right HUD/map column. */}\r\n                        <BottomActionBar\r\n                            skills={playerStats.skills}\r\n                            playerStats={playerStats}\r\n                            language={language}\r\n                            t={t}\r\n                            pickUpActions={pickUpActions}\r\n                            otherActions={otherActions}\r\n                            isLoading={isLoading}\r\n                            onUseSkill={(skillName: string) => { handleUseSkill(skillName); focusCustomActionInput(); }}\r\n                            onActionClick={handleActionClick}\r\n                            onOpenPickup={() => { setPickupDialogOpen(true); setSelectedPickupIds([]); }}\r\n                            onOpenAvailableActions={() => setAvailableActionsOpen(true)}\r\n                            onOpenCustomDialog={() => setCustomDialogOpen(true)}\r\n                            onOpenStatus={() => { setStatusOpen(true); focusCustomActionInput(); }}\r\n                            onOpenInventory={() => { setInventoryOpen(true); focusCustomActionInput(); }}\r\n                            onOpenCrafting={() => { setCraftingOpen(true); focusCustomActionInput(); }}\r\n                            onOpenBuilding={() => { setBuildingOpen(true); focusCustomActionInput(); }}\r\n                            onOpenFusion={() => { setFusionOpen(true); focusCustomActionInput(); }}\r\n                        />\r\n                        \r\n                        \r\n                        {/* Contextual and Custom Actions */}\r\n                        {restingPlace && (\r\n                            <><div className=\"space-y-2\">\r\n                                <h2 className=\"font-headline text-lg font-semibold text-center text-foreground/80\">{t('structureActions')}</h2>\r\n                                <Tooltip><TooltipTrigger asChild><Button variant=\"secondary\" className=\"w-full justify-center\" onClick={() => { handleRest(); focusCustomActionInput(); }} disabled={isLoading}><BedDouble className=\"mr-2 h-4 w-4\" />{t('rest')}</Button></TooltipTrigger><TooltipContent><p>{t('restTooltip', { shelterName: getTranslatedText(restingPlace.name, language, t), hp: restingPlace.restEffect!.hp, stamina: restingPlace.restEffect!.stamina })}</p></TooltipContent></Tooltip>\r\n                            </div><Separator /></>\r\n                        )}\r\n                        \r\n                        {/* Available actions (mobile only): hide on desktop since desktop has the fixed bottom bar */}\r\n                        {!isDesktop && (\r\n                            <div className=\"space-y-2\">\r\n                                <h2 className=\"font-headline text-lg font-semibold text-center text-foreground/80\">{t('availableActions')}</h2>\r\n                                {/* External pickup button (opens selection dialog) - only visible when there are items */}\r\n                                {pickUpActions.length > 0 && (\r\n                                    <div className=\"flex w-full justify-center mb-2\">\r\n                                        <Button variant=\"accent\" onClick={() => { setPickupDialogOpen(true); setSelectedPickupIds([]); }}>{t('pickUpItems') || 'Pick up items'}</Button>\r\n                                    </div>\r\n                                )}\r\n                                <div className=\"grid grid-cols-2 gap-2\">\r\n                                    {otherActions.map((action: Action) => {\r\n                                        const actionText = getTranslatedText({ key: action.textKey, params: action.params }, language, t);\r\n                                        return (\r\n                                            <Tooltip key={action.id}>\r\n                                                <TooltipTrigger asChild><Button variant=\"secondary\" className=\"w-full justify-center\" onClick={() => handleActionClick(action.id)} disabled={isLoading}>{actionText}</Button></TooltipTrigger>\r\n                                                <TooltipContent><p>{actionText}</p></TooltipContent>\r\n                                            </Tooltip>\r\n                                        );\r\n                                    })}\r\n                                </div>\r\n                            </div>\r\n                        )}\r\n                        \r\n                        {/* Custom action input removed from the map/HUD column so the aside only contains map and HUD */}\r\n                    </div>\r\n                </aside>\r\n                {/* Dialog: Available Actions (desktop) */}\r\n                <Dialog open={isAvailableActionsOpen} onOpenChange={setAvailableActionsOpen}>\r\n                    <DialogContent className=\"sm:max-w-md\">\r\n                        <DialogHeader>\r\n                            <DialogTitle>{t('availableActions') || 'Available Actions'}</DialogTitle>\r\n                            <DialogDescription>{t('availableActionsDesc') || 'Choose an available action.'}</DialogDescription>\r\n                        </DialogHeader>\r\n                        <div className=\"mt-4 grid grid-cols-1 gap-2\">\r\n                            {currentChunk?.actions.length ? (\r\n                                currentChunk!.actions.map((action: Action) => (\r\n                                    <Button key={action.id} variant=\"secondary\" className=\"w-full justify-center\" onClick={() => { handleActionClick(action.id); setAvailableActionsOpen(false); }}>\r\n                                        {getTranslatedText({ key: action.textKey, params: action.params }, language, t)}\r\n                                    </Button>\r\n                                ))\r\n                            ) : (\r\n                                <p className=\"text-sm text-muted-foreground\">{t('noAvailableActions') || 'No actions available.'}</p>\r\n                            )}\r\n                        </div>\r\n                    </DialogContent>\r\n                </Dialog>\r\n\r\n                {/* Dialog: Custom Action input (desktop) */}\r\n                <Dialog open={isCustomDialogOpen} onOpenChange={setCustomDialogOpen}>\r\n                    <DialogContent className=\"sm:max-w-md\">\r\n                        <DialogHeader>\r\n                            <DialogTitle>{t('customAction') || 'Custom Action'}</DialogTitle>\r\n                            <DialogDescription>{t('customActionDesc') || 'Type a custom action and submit.'}</DialogDescription>\r\n                        </DialogHeader>\r\n                        <div className=\"mt-4\">\r\n                            <Input placeholder={t('customActionPlaceholder') || 'Describe your action...'} value={customDialogValue} onChange={(e) => setCustomDialogValue((e.target as HTMLInputElement).value)} onKeyDown={(e) => { if (e.key === 'Enter') { e.preventDefault(); onCustomDialogSubmit(); } }} />\r\n                            <div className=\"flex justify-end mt-3\">\r\n                                <Button variant=\"ghost\" onClick={() => setCustomDialogOpen(false)} className=\"mr-2\">{t('cancel') || 'Cancel'}</Button>\r\n                                <Button onClick={onCustomDialogSubmit}>{t('submit') || 'Submit'}</Button>\r\n                            </div>\r\n                        </div>\r\n                    </DialogContent>\r\n                </Dialog>\r\n                \r\n                \r\n                <StatusPopup open={isStatusOpen} onOpenChange={setStatusOpen} stats={playerStats} onRequestHint={handleRequestQuestHint} onUnequipItem={handleUnequipItem} />\r\n                {/* Dialog: Pickup items selection */}\r\n                <Dialog open={isPickupDialogOpen} onOpenChange={setPickupDialogOpen}>\r\n                    <DialogContent className=\"sm:max-w-md\">\r\n                        <DialogHeader>\r\n                            <DialogTitle>{t('pickUpItems') || 'Pick up items'}</DialogTitle>\r\n                            <DialogDescription>{t('pickUpItemsDesc') || 'Select which items to pick up from this location.'}</DialogDescription>\r\n                        </DialogHeader>\r\n                        <div className=\"mt-4 grid grid-cols-1 gap-2\">\r\n                            {pickUpActions.length ? (\r\n                                pickUpActions.map((action: Action) => {\r\n                                    // Find the matching item in the chunk by using the same lookup used in handlers\r\n                                    const item = (currentChunk?.items || []).find((i: any) => getTranslatedText(i.name, 'en') === action.params?.itemName) || (currentChunk?.items?.[0] || null);\r\n                                    const itemName = item ? getTranslatedText(item.name, language, t) : getTranslatedText({ key: action.textKey, params: action.params }, language, t);\r\n                                    return (\r\n                                        <div key={action.id} className=\"flex items-center justify-between gap-2\">\r\n                                            <label className=\"flex items-center gap-3 cursor-pointer\">\r\n                                                <Checkbox checked={selectedPickupIds.includes(action.id)} onCheckedChange={() => togglePickupSelection(action.id)} />\r\n                                                <div className=\"flex flex-col text-sm\">\r\n                                                    <span className=\"font-medium flex items-center gap-1\">\r\n                                                        <IconRenderer icon={resolveItemDef(getTranslatedText(item.name, 'en'), customItemDefinitions)?.emoji || item.emoji} size={typeof (resolveItemDef(getTranslatedText(item.name, 'en'), customItemDefinitions)?.emoji || item.emoji) === 'object' ? 40 : 25} alt={itemName} />\r\n                                                        {itemName}\r\n                                                    </span>\r\n                                                    {item && <span className=\"text-xs text-muted-foreground\">{t('quantityShort') || 'Qty'}: {item.quantity}</span>}\r\n                                                </div>\r\n                                            </label>\r\n                                        </div>\r\n                                    );\r\n                                })\r\n                            ) : (\r\n                                <p className=\"text-sm text-muted-foreground\">{t('noItemsHere') || 'No items to pick up.'}</p>\r\n                            )}\r\n                        </div>\r\n                        <div className=\"flex justify-end mt-4\">\r\n                            <Button variant=\"ghost\" onClick={() => { setPickupDialogOpen(false); setSelectedPickupIds([]); }} className=\"mr-2\">{t('cancel') || 'Cancel'}</Button>\r\n                            <Button onClick={handlePickupConfirm} disabled={selectedPickupIds.length === 0}>{t('pickUp') || 'Pick up'}</Button>\r\n                        </div>\r\n                    </DialogContent>\r\n                </Dialog>\r\n                <InventoryPopup open={isInventoryOpen} onOpenChange={setInventoryOpen} items={playerStats.items} itemDefinitions={customItemDefinitions} enemy={currentChunk?.enemy || null} onUseItem={handleItemUsed} onEquipItem={handleEquipItem} />\r\n                <CraftingPopup open={isCraftingOpen} onOpenChange={setCraftingOpen} playerItems={playerStats.items} recipes={recipes} onCraft={handleCraft} itemDefinitions={customItemDefinitions} />\r\n                <BuildingPopup open={isBuildingOpen} onOpenChange={setBuildingOpen} playerItems={playerStats.items} buildableStructures={buildableStructures} onBuild={handleBuild} />\r\n                <FusionPopup open={isFusionOpen} onOpenChange={setFusionOpen} playerItems={playerStats.items} itemDefinitions={customItemDefinitions} onFuse={handleFuseItems} isLoading={isLoading} />\r\n                <FullMapPopup open={isFullMapOpen} onOpenChange={setIsFullMapOpen} world={world} playerPosition={playerPosition} turn={turn} />\r\n                <TutorialPopup open={isTutorialOpen} onOpenChange={setTutorialOpen} />\r\n                <SettingsPopup open={isSettingsOpen} onOpenChange={setSettingsOpen} isInGame={true} currentBiome={currentChunk?.terrain ?? null} />\r\n                <PwaInstallPopup open={showInstallPopup} onOpenChange={setShowInstallPopup} />\r\n                \r\n                <AlertDialog open={isGameOver}>\r\n                    <AlertDialogContent>\r\n                        <AlertDialogHeader>\r\n                        <AlertDialogTitle>{t('gameOverTitle')}</AlertDialogTitle>\r\n                        <AlertDialogDescription>\r\n                            {t('gameOverDesc')}\r\n                        </AlertDialogDescription>\r\n                        </AlertDialogHeader>\r\n                        <AlertDialogFooter>\r\n                            <AlertDialogAction onClick={() => {\r\n                                localStorage.removeItem(`gameState_${props.gameSlot}`);\r\n                                window.location.reload();\r\n                            }}>\r\n                                {t('startNewAdventure')}\r\n                            </AlertDialogAction>\r\n                        </AlertDialogFooter>\r\n                    </AlertDialogContent>\r\n                </AlertDialog>\r\n            </div>\r\n        </TooltipProvider>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\hud-icon-health.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'ramp'. Either include it or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [percent, ramp]","fix":{"range":[2523,2532],"text":"[percent, ramp]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef, useState } from 'react';\r\nimport AreaFill from '@/components/ui/area-fill';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface HudIconHealthProps {\r\n  percent: number; // 0..1\r\n  size?: number;\r\n  className?: string;\r\n}\r\n\r\n// Heart silhouette in 0..100 coordinate space (copied from hud-icon-progress)\r\nconst HEART_PATH = 'M50 85 C20 60, 6 42, 20 26 A18 18 0 0 1 50 27 A18 18 0 0 1 80 26 C94 42, 80 60, 50 85 Z';\r\n\r\nfunction hexToRgb(hex: string) {\r\n  const m = hex.replace('#', '');\r\n  const v = parseInt(m, 16);\r\n  return [(v >> 16) & 255, (v >> 8) & 255, v & 255];\r\n}\r\nfunction rgbToHex(r: number, g: number, b: number) {\r\n  return '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('');\r\n}\r\nfunction mixHex(a: string, b: string, t: number) {\r\n  const A = hexToRgb(a);\r\n  const B = hexToRgb(b);\r\n  return rgbToHex(Math.round(A[0] + (B[0] - A[0]) * t), Math.round(A[1] + (B[1] - A[1]) * t), Math.round(A[2] + (B[2] - A[2]) * t));\r\n}\r\n\r\nexport function HudIconHealth({ percent, size = 40, className }: HudIconHealthProps) {\r\n  const id = useRef(`hp-${Math.random().toString(36).slice(2, 9)}`).current;\r\n  const gradId = `dynGradHp-${id}`;\r\n  const outlineGradId = `metalOutlineGradHp-${id}`;\r\n  const filterId = `liquidFilterHp-${id}`;\r\n  const turbRef = useRef<SVGFETurbulenceElement | null>(null);\r\n  const dispRef = useRef<SVGFEDisplacementMapElement | null>(null);\r\n\r\n  const ramp = [\r\n    { p: 100, s: ['#ff4d4d', '#ff1a1a', '#b20000'] },\r\n    { p: 75, s: ['#ff6b6b', '#ff3333', '#c11616'] },\r\n    { p: 50, s: ['#fff176', '#ffd54d', '#ffb74d'] },\r\n    { p: 30, s: ['#ffb84d', '#ff8c00', '#cc6600'] },\r\n    { p: 0, s: ['#7a0000', '#4a0000', '#2a0000'] },\r\n  ];\r\n\r\n  const [stops, setStops] = useState<string[]>(ramp[0].s);\r\n  const lastPercent = useRef<number>(percent * 100);\r\n  const waveAnimRef = useRef<{ id: number } | null>(null);\r\n\r\n  useEffect(() => {\r\n    const p100 = Math.max(0, Math.min(100, Math.round(percent * 100)));\r\n    let lo = ramp[0], hi = ramp[ramp.length - 1];\r\n    for (let i = 0; i < ramp.length - 1; i++) {\r\n      const a = ramp[i], b = ramp[i + 1];\r\n      if (p100 <= a.p && p100 >= b.p) { lo = a; hi = b; break; }\r\n    }\r\n    const t = (p100 - hi.p) / (lo.p - hi.p || 1);\r\n    setStops([mixHex(hi.s[0], lo.s[0], t), mixHex(hi.s[1], lo.s[1], t), mixHex(hi.s[2], lo.s[2], t)]);\r\n\r\n    const delta = p100 - lastPercent.current;\r\n    if (Math.abs(delta) > 0.5) triggerWave(Math.abs(delta) / 100);\r\n    lastPercent.current = p100;\r\n  }, [percent]);\r\n\r\n  function triggerWave(mag: number) {\r\n    const dispEl = dispRef.current;\r\n    const turbEl = turbRef.current;\r\n    if (!dispEl || !turbEl) return;\r\n    if (waveAnimRef.current) cancelAnimationFrame(waveAnimRef.current.id);\r\n    const maxScale = 20 + mag * 60;\r\n    const baseFreq = 0.015 + mag * 0.03;\r\n    const duration = 900 + mag * 900;\r\n    const start = performance.now();\r\n    const anim = { id: 0 };\r\n    const dispNonNull = dispEl as SVGFEDisplacementMapElement;\r\n    const turbNonNull = turbEl as SVGFETurbulenceElement;\r\n    function step(now: number) {\r\n      const t = Math.min(1, (now - start) / duration);\r\n      const ease = 1 - Math.pow(1 - t, 3);\r\n      const scaleVal = maxScale * (1 - ease);\r\n      const freq = baseFreq * (1 + 0.6 * Math.sin(t * Math.PI * 2));\r\n      try { dispNonNull.setAttribute('scale', scaleVal.toFixed(2)); turbNonNull.setAttribute('baseFrequency', freq.toFixed(4)); } catch {}\r\n      if (t < 1) anim.id = requestAnimationFrame(step); else { try { dispNonNull.setAttribute('scale', '0'); turbNonNull.setAttribute('baseFrequency', '0.015'); } catch {} waveAnimRef.current = null; }\r\n    }\r\n    anim.id = requestAnimationFrame(step);\r\n    waveAnimRef.current = anim;\r\n  }\r\n\r\n  // Use exact requested size for consistent HUD icon sizing\r\n  const displayWidth = size;\r\n  const displayHeight = size;\r\n\r\n  return (\r\n    <div className={cn('inline-block', className)} style={{ width: displayWidth, height: displayHeight }}>\r\n      <svg viewBox={`0 0 100 100`} width={displayWidth} height={displayHeight} preserveAspectRatio=\"xMidYMid meet\">\r\n        <defs>\r\n          <linearGradient id={gradId} x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor={stops[0]} />\r\n            <stop offset=\"50%\" stopColor={stops[1]} />\r\n            <stop offset=\"100%\" stopColor={stops[2]} />\r\n          </linearGradient>\r\n\r\n          <linearGradient id={outlineGradId} x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor=\"#59330b\" />\r\n            <stop offset=\"20%\" stopColor=\"#b06b2f\" />\r\n            <stop offset=\"45%\" stopColor=\"#ffd39f\" />\r\n            <stop offset=\"70%\" stopColor=\"#c07a2f\" />\r\n            <stop offset=\"100%\" stopColor=\"#4b2a06\" />\r\n          </linearGradient>\r\n\r\n          <filter id={filterId} x=\"-30%\" y=\"-30%\" width=\"160%\" height=\"160%\" colorInterpolationFilters=\"sRGB\">\r\n            <feTurbulence ref={(el) => { turbRef.current = el; }} type=\"fractalNoise\" baseFrequency=\"0.015\" numOctaves={2} seed={2} result=\"noise\" />\r\n            <feDisplacementMap ref={(el) => { dispRef.current = el; }} in=\"SourceGraphic\" in2=\"noise\" scale=\"0\" xChannelSelector=\"R\" yChannelSelector=\"G\" />\r\n          </filter>\r\n        </defs>\r\n\r\n        <g>\r\n          <foreignObject x={0} y={0} width={100} height={100} style={{ overflow: 'visible' }}>\r\n            <div style={{ width: '100%', height: '100%', pointerEvents: 'none' }}>\r\n              <AreaFill pathD={HEART_PATH} percent={percent} size={100} fill={`url(#${gradId})`} fillGroupFilter={`url(#${filterId})`} />\r\n            </div>\r\n          </foreignObject>\r\n        </g>\r\n\r\n        <path d={HEART_PATH} fill=\"none\" stroke={`url(#${outlineGradId})`} strokeWidth={2.2} strokeLinejoin=\"round\" strokeLinecap=\"round\" />\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default HudIconHealth;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\hud-icon-hunger.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'ramp'. Either include it or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [percent, ramp]","fix":{"range":[2563,2572],"text":"[percent, ramp]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef, useState } from 'react';\r\nimport AreaFill from '@/components/ui/area-fill';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface HudIconHungerProps {\r\n  percent: number; // 0..1\r\n  size?: number;\r\n  className?: string;\r\n}\r\n\r\n// Drumstick / meat silhouette (approx) in 0..100 coords\r\nconst DRUM_PATH = 'M72 18 C84 22, 88 36, 76 48 C68 56, 56 62, 44 64 C36 65, 28 63, 22 58 C16 53, 18 40, 26 34 C34 28, 46 22, 58 18 C64 16, 70 16, 72 18 Z';\r\n\r\nfunction hexToRgb(hex: string) {\r\n  const m = hex.replace('#', '');\r\n  const v = parseInt(m, 16);\r\n  return [(v >> 16) & 255, (v >> 8) & 255, v & 255];\r\n}\r\nfunction rgbToHex(r: number, g: number, b: number) {\r\n  return '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('');\r\n}\r\nfunction mixHex(a: string, b: string, t: number) {\r\n  const A = hexToRgb(a);\r\n  const B = hexToRgb(b);\r\n  return rgbToHex(Math.round(A[0] + (B[0] - A[0]) * t), Math.round(A[1] + (B[1] - A[1]) * t), Math.round(A[2] + (B[2] - A[2]) * t));\r\n}\r\n\r\nexport function HudIconHunger({ percent, size = 48, className }: HudIconHungerProps) {\r\n  const id = useRef(`hunger-${Math.random().toString(36).slice(2, 9)}`).current;\r\n  const gradId = `dynGradHunger-${id}`;\r\n  const outlineGradId = `metalOutlineGradHunger-${id}`;\r\n  const filterId = `liquidFilterHunger-${id}`;\r\n  const turbRef = useRef<SVGFETurbulenceElement | null>(null);\r\n  const dispRef = useRef<SVGFEDisplacementMapElement | null>(null);\r\n\r\n  const ramp = [\r\n    { p: 100, s: ['#ffdca8', '#ffb36a', '#d9732b'] },\r\n    { p: 70, s: ['#ffd39f', '#ff9a4a', '#c96f25'] },\r\n    { p: 40, s: ['#ffc38a', '#ff7a2a', '#b35718'] },\r\n    { p: 15, s: ['#ff9a52', '#e65100', '#7a2f00'] },\r\n    { p: 0, s: ['#5c2a14', '#341306', '#1a0b03'] },\r\n  ];\r\n\r\n  const [stops, setStops] = useState<string[]>(ramp[0].s);\r\n  const lastPercent = useRef<number>(percent * 100);\r\n  const waveAnimRef = useRef<{ id: number } | null>(null);\r\n\r\n  useEffect(() => {\r\n    const p100 = Math.max(0, Math.min(100, Math.round(percent * 100)));\r\n    let lo = ramp[0], hi = ramp[ramp.length - 1];\r\n    for (let i = 0; i < ramp.length - 1; i++) {\r\n      const a = ramp[i], b = ramp[i + 1];\r\n      if (p100 <= a.p && p100 >= b.p) { lo = a; hi = b; break; }\r\n    }\r\n    const t = (p100 - hi.p) / (lo.p - hi.p || 1);\r\n    setStops([mixHex(hi.s[0], lo.s[0], t), mixHex(hi.s[1], lo.s[1], t), mixHex(hi.s[2], lo.s[2], t)]);\r\n\r\n    const delta = p100 - lastPercent.current;\r\n    if (Math.abs(delta) > 0.5) triggerWave(Math.abs(delta) / 100);\r\n    lastPercent.current = p100;\r\n  }, [percent]);\r\n\r\n  function triggerWave(mag: number) {\r\n    const dispEl = dispRef.current;\r\n    const turbEl = turbRef.current;\r\n    if (!dispEl || !turbEl) return;\r\n    if (waveAnimRef.current) cancelAnimationFrame(waveAnimRef.current.id);\r\n    const maxScale = 16 + mag * 40;\r\n    const baseFreq = 0.01 + mag * 0.02;\r\n    const duration = 900 + mag * 800;\r\n    const start = performance.now();\r\n    const anim = { id: 0 };\r\n    const dispNonNull = dispEl as SVGFEDisplacementMapElement;\r\n    const turbNonNull = turbEl as SVGFETurbulenceElement;\r\n    function step(now: number) {\r\n      const t = Math.min(1, (now - start) / duration);\r\n      const ease = 1 - Math.pow(1 - t, 3);\r\n      const scaleVal = maxScale * (1 - ease);\r\n      const freq = baseFreq * (1 + 0.5 * Math.sin(t * Math.PI * 2));\r\n      try { dispNonNull.setAttribute('scale', scaleVal.toFixed(2)); turbNonNull.setAttribute('baseFrequency', freq.toFixed(4)); } catch {}\r\n      if (t < 1) anim.id = requestAnimationFrame(step); else { try { dispNonNull.setAttribute('scale', '0'); turbNonNull.setAttribute('baseFrequency', '0.01'); } catch {} waveAnimRef.current = null; }\r\n    }\r\n    anim.id = requestAnimationFrame(step);\r\n    waveAnimRef.current = anim;\r\n  }\r\n\r\n  // Use exact requested size for consistent HUD icon sizing\r\n  const displayWidth = size;\r\n  const displayHeight = size;\r\n\r\n  return (\r\n    <div className={cn('inline-block', className)} style={{ width: displayWidth, height: displayHeight }}>\r\n      <svg viewBox={`0 0 100 100`} width={displayWidth} height={displayHeight} preserveAspectRatio=\"xMidYMid meet\">\r\n        <defs>\r\n          <linearGradient id={gradId} x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor={stops[0]} />\r\n            <stop offset=\"50%\" stopColor={stops[1]} />\r\n            <stop offset=\"100%\" stopColor={stops[2]} />\r\n          </linearGradient>\r\n\r\n          <linearGradient id={outlineGradId} x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor=\"#4b2a06\" />\r\n            <stop offset=\"30%\" stopColor=\"#c07a2f\" />\r\n            <stop offset=\"60%\" stopColor=\"#ffd39f\" />\r\n            <stop offset=\"100%\" stopColor=\"#592e0a\" />\r\n          </linearGradient>\r\n\r\n          <filter id={filterId} x=\"-30%\" y=\"-30%\" width=\"160%\" height=\"160%\" colorInterpolationFilters=\"sRGB\">\r\n            <feTurbulence ref={(el) => { turbRef.current = el; }} type=\"fractalNoise\" baseFrequency=\"0.01\" numOctaves={2} seed={13} result=\"noise\" />\r\n            <feDisplacementMap ref={(el) => { dispRef.current = el; }} in=\"SourceGraphic\" in2=\"noise\" scale=\"0\" xChannelSelector=\"R\" yChannelSelector=\"G\" />\r\n          </filter>\r\n        </defs>\r\n\r\n        <g>\r\n          <foreignObject x={0} y={0} width={100} height={100} style={{ overflow: 'visible' }}>\r\n            <div style={{ width: '100%', height: '100%', pointerEvents: 'none' }}>\r\n              <AreaFill pathD={DRUM_PATH} percent={percent} size={100} fill={`url(#${gradId})`} fillGroupFilter={`url(#${filterId})`} />\r\n            </div>\r\n          </foreignObject>\r\n        </g>\r\n\r\n        <path d={DRUM_PATH} fill=\"none\" stroke={`url(#${outlineGradId})`} strokeWidth={2} strokeLinejoin=\"round\" strokeLinecap=\"round\" />\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default HudIconHunger;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\hud-icon-mana.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stops' is assigned a value but never used.","line":44,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'ramp'. Either include it or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [percent, ramp]","fix":{"range":[2493,2502],"text":"[percent, ramp]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef, useState } from 'react';\r\nimport AreaFill from '@/components/ui/area-fill';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface HudIconManaProps {\r\n  percent: number; // 0..1\r\n  size?: number;\r\n  className?: string;\r\n}\r\n\r\n// Teardrop path provided by user in 0..1024 coords\r\nconst DROP_PATH = 'M512 64 C680 220 832 420 800 656 C768 900 256 900 224 656 C192 420 344 220 512 64 Z';\r\n\r\nfunction hexToRgb(hex: string) {\r\n  const m = hex.replace('#', '');\r\n  const v = parseInt(m, 16);\r\n  return [(v >> 16) & 255, (v >> 8) & 255, v & 255];\r\n}\r\nfunction rgbToHex(r: number, g: number, b: number) {\r\n  return '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('');\r\n}\r\nfunction mixHex(a: string, b: string, t: number) {\r\n  const A = hexToRgb(a);\r\n  const B = hexToRgb(b);\r\n  return rgbToHex(Math.round(A[0] + (B[0] - A[0]) * t), Math.round(A[1] + (B[1] - A[1]) * t), Math.round(A[2] + (B[2] - A[2]) * t));\r\n}\r\n\r\nexport function HudIconMana({ percent, size = 48, className }: HudIconManaProps) {\r\n  const id = useRef(`mana-${Math.random().toString(36).slice(2, 9)}`).current;\r\n  const gradId = `dynGradMana-${id}`;\r\n  const outlineGradId = `metalOutlineGradMana-${id}`;\r\n  const filterId = `liquidFilterMana-${id}`;\r\n  const turbRef = useRef<SVGFETurbulenceElement | null>(null);\r\n  const dispRef = useRef<SVGFEDisplacementMapElement | null>(null);\r\n\r\n  const ramp = [\r\n    { p: 100, s: ['#9be7ff', '#33c6ff', '#0078d4'] },\r\n    { p: 70, s: ['#7fe2ff', '#1fb6ff', '#0066c1'] },\r\n    { p: 40, s: ['#53d0ff', '#00aaff', '#0050a1'] },\r\n    { p: 15, s: ['#2aa8d6', '#0088c0', '#003d66'] },\r\n    { p: 0, s: ['#0c2a3a', '#071922', '#020a0f'] },\r\n  ];\r\n\r\n  const [stops, setStops] = useState<string[]>(ramp[0].s);\r\n  const lastPercent = useRef<number>(percent * 100);\r\n  const waveAnimRef = useRef<{ id: number } | null>(null);\r\n\r\n  useEffect(() => {\r\n    const p100 = Math.max(0, Math.min(100, Math.round(percent * 100)));\r\n    let lo = ramp[0], hi = ramp[ramp.length - 1];\r\n    for (let i = 0; i < ramp.length - 1; i++) {\r\n      const a = ramp[i], b = ramp[i + 1];\r\n      if (p100 <= a.p && p100 >= b.p) { lo = a; hi = b; break; }\r\n    }\r\n    const t = (p100 - hi.p) / (lo.p - hi.p || 1);\r\n    setStops([mixHex(hi.s[0], lo.s[0], t), mixHex(hi.s[1], lo.s[1], t), mixHex(hi.s[2], lo.s[2], t)]);\r\n\r\n    const delta = p100 - lastPercent.current;\r\n    if (Math.abs(delta) > 0.5) triggerWave(Math.abs(delta) / 100);\r\n    lastPercent.current = p100;\r\n  }, [percent]);\r\n\r\n  function triggerWave(mag: number) {\r\n    const dispEl = dispRef.current;\r\n    const turbEl = turbRef.current;\r\n    if (!dispEl || !turbEl) return;\r\n    if (waveAnimRef.current) cancelAnimationFrame(waveAnimRef.current.id);\r\n    const maxScale = 12 + mag * 40;\r\n    const baseFreq = 0.012 + mag * 0.02;\r\n    const duration = 800 + mag * 700;\r\n    const start = performance.now();\r\n    const anim = { id: 0 };\r\n    const dispNonNull = dispEl as SVGFEDisplacementMapElement;\r\n    const turbNonNull = turbEl as SVGFETurbulenceElement;\r\n    function step(now: number) {\r\n      const t = Math.min(1, (now - start) / duration);\r\n      const ease = 1 - Math.pow(1 - t, 3);\r\n      const scaleVal = maxScale * (1 - ease);\r\n      const freq = baseFreq * (1 + 0.6 * Math.sin(t * Math.PI * 2));\r\n      try { dispNonNull.setAttribute('scale', scaleVal.toFixed(2)); turbNonNull.setAttribute('baseFrequency', freq.toFixed(4)); } catch {}\r\n      if (t < 1) anim.id = requestAnimationFrame(step); else { try { dispNonNull.setAttribute('scale', '0'); turbNonNull.setAttribute('baseFrequency', '0.012'); } catch {} waveAnimRef.current = null; }\r\n    }\r\n    anim.id = requestAnimationFrame(step);\r\n    waveAnimRef.current = anim;\r\n  }\r\n\r\n  // Use exact requested size for consistent HUD icon sizing\r\n  const displayWidth = size;\r\n  const displayHeight = size;\r\n\r\n  // Use the user's provided gradients and filters (colors taken from the SVG they supplied)\r\n  const innerGradStops = ['#57d8d6', '#1fa6b2', '#08184a'];\r\n  const metalGradStops = ['#7b4a1a', '#d3a04a', '#ffd88a', '#8b5a22'];\r\n\r\n  return (\r\n    <div className={cn('inline-block', className)} style={{ width: displayWidth, height: displayHeight }}>\r\n      <svg viewBox={`0 0 1024 1024`} width={displayWidth} height={displayHeight} preserveAspectRatio=\"xMidYMid meet\">\r\n        <defs>\r\n          <linearGradient id={gradId} x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor={innerGradStops[0]} />\r\n            <stop offset=\"50%\" stopColor={innerGradStops[1]} />\r\n            <stop offset=\"100%\" stopColor={innerGradStops[2]} />\r\n          </linearGradient>\r\n\r\n          <linearGradient id={outlineGradId} x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor={metalGradStops[0]} />\r\n            <stop offset=\"30%\" stopColor={metalGradStops[1]} />\r\n            <stop offset=\"60%\" stopColor={metalGradStops[2]} />\r\n            <stop offset=\"100%\" stopColor={metalGradStops[3]} />\r\n          </linearGradient>\r\n\r\n          <radialGradient id={`goldShine-${id}`} cx=\"0.35\" cy=\"0.2\" r=\"0.9\">\r\n            <stop offset=\"0%\" stopColor=\"#ffffff\" stopOpacity=\"0.85\" />\r\n            <stop offset=\"35%\" stopColor=\"#fff8e6\" stopOpacity=\"0.35\" />\r\n            <stop offset=\"100%\" stopColor=\"#000000\" stopOpacity=\"0\" />\r\n          </radialGradient>\r\n\r\n          <filter id={`softBlur-${id}`} x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\r\n            <feGaussianBlur stdDeviation={6} />\r\n          </filter>\r\n\r\n          <filter id={`innerShadow-${id}`} x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\r\n            <feOffset dx=\"0\" dy=\"10\" result=\"off\" />\r\n            <feGaussianBlur in=\"off\" stdDeviation={18} result=\"blur\" />\r\n            <feComposite in=\"blur\" in2=\"SourceGraphic\" operator=\"out\" result=\"shadow\" />\r\n            <feColorMatrix in=\"shadow\" type=\"matrix\" values=\"0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0.45 0\" />\r\n            <feBlend in=\"SourceGraphic\" in2=\"shadow\" mode=\"normal\" />\r\n          </filter>\r\n\r\n          <filter id={filterId} x=\"-30%\" y=\"-30%\" width=\"160%\" height=\"160%\" colorInterpolationFilters=\"sRGB\">\r\n            <feTurbulence ref={(el) => { turbRef.current = el; }} type=\"fractalNoise\" baseFrequency=\"0.012\" numOctaves={2} seed={7} result=\"noise\" />\r\n            <feDisplacementMap ref={(el) => { dispRef.current = el; }} in=\"SourceGraphic\" in2=\"noise\" scale=\"0\" xChannelSelector=\"R\" yChannelSelector=\"G\" />\r\n          </filter>\r\n        </defs>\r\n\r\n        {/* Area-aware fill rendered by AreaFill (size=1024 -> matches path coordinates) */}\r\n        <g>\r\n          <foreignObject x={0} y={0} width={1024} height={1024} style={{ overflow: 'visible' }}>\r\n            <div style={{ width: '100%', height: '100%', pointerEvents: 'none' }}>\r\n              <AreaFill pathD={DROP_PATH} percent={percent} size={1024} fill={`url(#${gradId})`} fillGroupFilter={`url(#${filterId})`} />\r\n            </div>\r\n          </foreignObject>\r\n        </g>\r\n\r\n        {/* Metallic border */}\r\n        <path d={DROP_PATH} fill=\"none\" stroke={`url(#${outlineGradId})`} strokeWidth={56} strokeLinejoin=\"round\" strokeLinecap=\"round\" />\r\n\r\n        {/* Optional metallic highlight */}\r\n        <path d=\"M512 86 C666 244 796 424 770 642 C746 852 278 852 254 642 C230 432 358 252 512 86 Z\"\r\n          fill=\"none\" stroke={`url(#goldShine-${id})`} strokeWidth={22} strokeLinejoin=\"round\" opacity={0.65} filter={`url(#softBlur-${id})`} />\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default HudIconMana;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\hud-icon-progress.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":102,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":17},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has a missing dependency: 'computeHealthStops'. Either include it or remove the dependency array.","line":134,"column":6,"nodeType":"ArrayExpression","endLine":134,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [computeHealthStops, percent]","fix":{"range":[6211,6220],"text":"[computeHealthStops, percent]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"∩╗┐\"use client\";\r\n\r\nimport React from 'react';\r\nimport { cn } from '@/lib/utils';\r\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\r\n\r\ninterface HudIconProgressProps {\r\n  Icon?: React.ElementType;\r\n  value: number;\r\n  maxValue: number;\r\n  fillColor?: string;\r\n  statName?: string;\r\n  className?: string;\r\n}\r\n\r\nexport function HudIconProgress({ value, maxValue, statName, className }: HudIconProgressProps) {\r\n  // Keep API compatible with previous usage while providing the animated heart.\r\n  const nValue = Number(value);\r\n  const nMax = Number(maxValue);\r\n  const raw = (Number.isFinite(nValue) && Number.isFinite(nMax) && nMax !== 0) ? (nValue / nMax) * 100 : 0;\r\n  const percent = Math.max(0, Math.min(100, Number.isFinite(raw) ? raw : 0));\r\n\r\n  // HEART silhouette in 0..100 coordinate space\r\n  const HEART_PATH = 'M50 85 C20 60, 6 42, 20 26 A18 18 0 0 1 50 27 A18 18 0 0 1 80 26 C94 42, 80 60, 50 85 Z';\r\n\r\n  // color helpers\r\n  function hexToRgb(hex: string) { const m = hex.replace('#',''); const bigint = parseInt(m,16); return [(bigint>>16)&255, (bigint>>8)&255, bigint&255]; }\r\n  function rgbToHex(r:number,g:number,b:number){ return '#' + [r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }\r\n  function mixHex(a:string,b:string,t:number){ const A = hexToRgb(a), B = hexToRgb(b); const R = Math.round(A[0] + (B[0]-A[0])*t); const G = Math.round(A[1] + (B[1]-A[1])*t); const Bc = Math.round(A[2] + (B[2]-A[2])*t); return rgbToHex(R,G,Bc); }\r\n\r\n  function computeHealthStops(p: number) {\r\n    const ramp = [\r\n      { p:100, s:['#ff4d4d','#ff1a1a','#b20000'] },\r\n      { p:75,  s:['#ff6b6b','#ff3333','#c11616'] },\r\n      { p:50,  s:['#fff176','#ffd54d','#ffb74d'] },\r\n      { p:30,  s:['#ffb84d','#ff8c00','#cc6600'] },\r\n      { p:0,   s:['#7a0000','#4a0000','#2a0000'] },\r\n    ];\r\n    p = Math.max(0, Math.min(100, p));\r\n    let lo = ramp[0], hi = ramp[ramp.length-1];\r\n    for (let i=0;i<ramp.length-1;i++){\r\n      const a = ramp[i], b = ramp[i+1];\r\n      if (p <= a.p && p >= b.p) { lo = a; hi = b; break; }\r\n      if (p >= a.p && p <= b.p) { lo = a; hi = b; break; }\r\n    }\r\n    let t = 0; if (lo.p === hi.p) t = 0; else t = (p - lo.p) / (hi.p - lo.p);\r\n    t = Math.max(0, Math.min(1, t));\r\n    return [ mixHex(lo.s[0], hi.s[0], t), mixHex(lo.s[1], hi.s[1], t), mixHex(lo.s[2], hi.s[2], t) ];\r\n  }\r\n\r\n  // refs\r\n  const stopARef = React.useRef<SVGStopElement | null>(null);\r\n  const stopBRef = React.useRef<SVGStopElement | null>(null);\r\n  const stopCRef = React.useRef<SVGStopElement | null>(null);\r\n  const rectRef = React.useRef<SVGRectElement | null>(null);\r\n  const turbRef = React.useRef<SVGElement | null>(null);\r\n  const dispRef = React.useRef<SVGElement | null>(null);\r\n\r\n  // area lookup for perceptual fill mapping\r\n  const areaLookupRef = React.useRef<Array<{h:number, area:number}> | null>(null);\r\n\r\n  React.useEffect(() => {\r\n    // build lookup by rasterizing the HEART_PATH into a 200x200 canvas\r\n    let cancelled = false;\r\n    (async () => {\r\n      try {\r\n        const canvas = document.createElement('canvas');\r\n        const samples = 120;\r\n        canvas.width = 200; canvas.height = 200;\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) { areaLookupRef.current = null; return; }\r\n        const ctx2 = ctx as CanvasRenderingContext2D;\r\n        const scale = canvas.width / 100;\r\n\r\n        function drawHeart(){\r\n          ctx2.fillStyle = '#fff';\r\n          const p = new Path2D(HEART_PATH);\r\n          ctx2.fill(p);\r\n        }\r\n\r\n        ctx.save(); ctx.setTransform(scale,0,0,scale,0,0); ctx.clearRect(0,0,100,100); drawHeart(); ctx.restore();\r\n        const totalImg = ctx.getImageData(0,0,canvas.width,canvas.height).data;\r\n        let totalCount = 0;\r\n        for (let i=3;i<totalImg.length;i+=4) if (totalImg[i] > 10) totalCount++;\r\n        if (totalCount === 0) { areaLookupRef.current = null; return; }\r\n\r\n        const table: Array<{h:number,area:number}> = [];\r\n        for (let s=0;s<=samples;s++){\r\n          const hPercent = s / samples * 100;\r\n          ctx.save(); ctx.setTransform(scale,0,0,scale,0,0); ctx.clearRect(0,0,100,100); drawHeart();\r\n          ctx.globalCompositeOperation = 'destination-in';\r\n          // fillRect uses the 0..100 coordinate system\r\n          ctx.fillRect(0, 100 - hPercent, 100, hPercent);\r\n          ctx.restore();\r\n          const img = ctx.getImageData(0,0,canvas.width,canvas.height).data;\r\n          let c = 0;\r\n          for (let i=3;i<img.length;i+=4) if (img[i] > 10) c++;\r\n          table.push({h:hPercent, area: c / totalCount});\r\n        }\r\n        for (let i=1;i<table.length;i++) if (table[i].area < table[i-1].area) table[i].area = table[i-1].area;\r\n        if (!cancelled) areaLookupRef.current = table;\r\n      } catch (e) { areaLookupRef.current = null; }\r\n    })();\r\n    return () => { cancelled = true; };\r\n  }, []);\r\n\r\n  function heightForPercentByArea(pct:number){\r\n    const table = areaLookupRef.current;\r\n    if (!table) { const g = 1.22; return Math.pow(pct/100, g) * 100; }\r\n    const target = pct / 100;\r\n    if (target <= 0) return 0; if (target >= 1) return 100;\r\n    // binary search by area to find matching h\r\n    let lo = 0, hi = table.length - 1;\r\n    while (lo <= hi){ const mid = Math.floor((lo+hi)/2); if (table[mid].area < target) lo = mid+1; else hi = mid-1; }\r\n    const i = Math.max(0, hi);\r\n    const a = table[i], b = table[Math.min(table.length-1, i+1)];\r\n    if (!b) return a.h;\r\n    const t = (target - a.area) / (b.area - a.area || 1);\r\n    return a.h + (b.h - a.h) * t;\r\n  }\r\n\r\n  // update gradient stops and rect position\r\n  React.useEffect(() => {\r\n    const [cA, cB, cC] = computeHealthStops(percent);\r\n    if (stopARef.current) stopARef.current.setAttribute('stop-color', cA);\r\n    if (stopBRef.current) stopBRef.current.setAttribute('stop-color', cB);\r\n    if (stopCRef.current) stopCRef.current.setAttribute('stop-color', cC);\r\n\r\n    const required = heightForPercentByArea(percent);\r\n    const viewH = 100;\r\n    const h = (required/100) * viewH;\r\n    const y = viewH - h;\r\n    if (rectRef.current){ rectRef.current.setAttribute('y', String(y)); rectRef.current.setAttribute('height', String(h)); }\r\n  }, [percent]);\r\n\r\n  // wave animation when percent changes\r\n  const lastRef = React.useRef<number | null>(null);\r\n  React.useEffect(() => {\r\n    const prev = lastRef.current; lastRef.current = percent; if (prev === null) return;\r\n    const delta = percent - prev; if (Math.abs(delta) < 0.5) return;\r\n    const disp = dispRef.current; const turb = turbRef.current; if (!disp || !turb) return;\r\n    let rafId: number | null = null;\r\n    const start = performance.now();\r\n    const mag = Math.min(1, Math.abs(delta)/100);\r\n    const maxScale = 25 + mag * 60;\r\n    const baseFreq = 0.015 + mag * 0.02;\r\n    const duration = 1000 + mag * 800;\r\n    function step(now:number){\r\n      const t = Math.min(1, (now-start)/duration);\r\n      const ease = 1 - Math.pow(1 - t, 3);\r\n      const scaleVal = maxScale * (1 - ease);\r\n      const freq = baseFreq * (1 + 0.5 * Math.sin(t * Math.PI * 2));\r\n      if (disp) try { (disp as Element).setAttribute('scale', (scaleVal).toFixed(2)); } catch {};\r\n      if (turb) try { (turb as Element).setAttribute('baseFrequency', freq.toFixed(4)); } catch {};\r\n      if (t < 1) rafId = requestAnimationFrame(step); else {\r\n        try{ if (disp) (disp as Element).setAttribute('scale','0'); } catch {}\r\n        try{ if (turb) (turb as Element).setAttribute('baseFrequency','0.015'); } catch {}\r\n      }\r\n    }\r\n    rafId = requestAnimationFrame(step);\r\n    return () => { if (rafId) cancelAnimationFrame(rafId); };\r\n  }, [percent]);\r\n\r\n  return (\r\n    <TooltipProvider>\r\n      <Tooltip>\r\n        <TooltipTrigger asChild>\r\n          <div className={cn('relative w-10 h-10 flex items-center justify-center', className)} aria-label={`${statName ?? 'HP'}: ${Math.round(percent)}%`}>\r\n            <svg viewBox=\"0 0 100 100\" width=\"40\" height=\"40\" className=\"block\" aria-hidden>\r\n              <defs>\r\n                <linearGradient id=\"dynGrad\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n                  <stop ref={stopARef} offset=\"0%\" stopColor=\"#ff6eb4\" />\r\n                  <stop ref={stopBRef} offset=\"50%\" stopColor=\"#ff2d95\" />\r\n                  <stop ref={stopCRef} offset=\"100%\" stopColor=\"#a4006e\" />\r\n                </linearGradient>\r\n\r\n                <linearGradient id=\"metalOutlineGrad\" x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\r\n                  <stop offset=\"0%\" stopColor=\"#59330b\" />\r\n                  <stop offset=\"20%\" stopColor=\"#b06b2f\" />\r\n                  <stop offset=\"45%\" stopColor=\"#ffd39f\" />\r\n                  <stop offset=\"70%\" stopColor=\"#c07a2f\" />\r\n                  <stop offset=\"100%\" stopColor=\"#4b2a06\" />\r\n                </linearGradient>\r\n\r\n                <filter id=\"liquidFilter\" x=\"-30%\" y=\"-30%\" width=\"160%\" height=\"160%\" colorInterpolationFilters=\"sRGB\">\r\n                  <feTurbulence ref={turbRef as any} id=\"turb\" type=\"fractalNoise\" baseFrequency=\"0.015\" numOctaves={2} seed={2} result=\"noise\" />\r\n                  <feDisplacementMap ref={dispRef as any} id=\"disp\" in=\"SourceGraphic\" in2=\"noise\" scale=\"0\" xChannelSelector=\"R\" yChannelSelector=\"G\" />\r\n                </filter>\r\n\r\n                <filter id=\"metalSpec\" x=\"-40%\" y=\"-40%\" width=\"180%\" height=\"180%\" colorInterpolationFilters=\"sRGB\">\r\n                  <feGaussianBlur in=\"SourceAlpha\" stdDeviation={1} result=\"blur\"/>\r\n                  <feSpecularLighting in=\"blur\" surfaceScale={2} specularConstant={0.8} specularExponent={18} lightingColor=\"#ffffff\" result=\"specOut\">\r\n                    <fePointLight x={-50} y={-40} z={80} />\r\n                  </feSpecularLighting>\r\n                  <feComposite in=\"specOut\" in2=\"SourceAlpha\" operator=\"in\" result=\"specComp\" />\r\n                  <feMerge>\r\n                    <feMergeNode in=\"SourceGraphic\" />\r\n                    <feMergeNode in=\"specComp\" />\r\n                  </feMerge>\r\n                </filter>\r\n\r\n                <clipPath id=\"heartClip\">\r\n                  <path d={HEART_PATH} />\r\n                </clipPath>\r\n              </defs>\r\n\r\n              <g id=\"fillGroup\" clipPath=\"url(#heartClip)\" filter=\"url(#liquidFilter)\">\r\n                <rect ref={rectRef} id=\"fillRect\" x=\"0\" y=\"0\" width=\"100\" height=\"100\" fill=\"url(#dynGrad)\" />\r\n              </g>\r\n\r\n              <g filter=\"url(#metalSpec)\">\r\n                <path d={HEART_PATH} fill=\"none\" stroke=\"url(#metalOutlineGrad)\" strokeWidth={2.2} strokeLinejoin=\"round\" strokeLinecap=\"round\" />\r\n              </g>\r\n            </svg>\r\n          </div>\r\n        </TooltipTrigger>\r\n        <TooltipContent>\r\n          <p>{statName ?? 'Health'}: {Math.round(percent)}%</p>\r\n        </TooltipContent>\r\n      </Tooltip>\r\n    </TooltipProvider>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\hud-icon-stamina.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'ramp'. Either include it or remove the dependency array.","line":73,"column":6,"nodeType":"ArrayExpression","endLine":73,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [percent, ramp]","fix":{"range":[3339,3348],"text":"[percent, ramp]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":96,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":104,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef, useState } from 'react';\r\nimport AreaFill from '@/components/ui/area-fill';\r\nimport { cn } from '@/lib/utils';\r\n\r\ninterface HudIconStaminaProps {\r\n  percent: number; // 0..1\r\n  size?: number;\r\n  className?: string;\r\n}\r\n\r\n// Bolt silhouette path (1024 coordinate space) taken from the provided SVG\r\nconst BOLT_PATH = `M584.00,135.00Q702.00,135.00,710.50,140.50Q719.00,146.00,722.00,153.50Q725.00,161.00,722.50,171.50Q720.00,182.00,659.00,284.50Q598.00,387.00,652.00,387.50Q706.00,388.00,714.00,394.00Q722.00,400.00,724.50,405.50Q727.00,411.00,727.00,419.00Q727.00,427.00,724.50,433.50Q722.00,440.00,559.50,661.00Q397.00,882.00,392.00,885.00Q387.00,888.00,381.50,888.00Q376.00,888.00,370.00,884.50Q364.00,881.00,362.00,876.50Q360.00,872.00,360.00,866.50Q360.00,861.00,399.50,711.00Q439.00,561.00,387.50,560.50Q336.00,560.00,327.50,554.50Q319.00,549.00,315.50,537.50Q312.00,526.00,373.00,344.00Q434.00,162.00,441.00,152.00Q448.00,142.00,456.50,139.00Q465.00,136.00,465.50,135.50Q466.00,135.00,584.00,135.00Z`;\r\n\r\nfunction hexToRgb(hex: string) {\r\n  const m = hex.replace('#', '');\r\n  const v = parseInt(m, 16);\r\n  return [(v >> 16) & 255, (v >> 8) & 255, v & 255];\r\n}\r\nfunction rgbToHex(r: number, g: number, b: number) {\r\n  return (\r\n    '#' + [r, g, b].map((x) => Math.round(x).toString(16).padStart(2, '0')).join('')\r\n  );\r\n}\r\nfunction mixHex(a: string, b: string, t: number) {\r\n  const A = hexToRgb(a);\r\n  const B = hexToRgb(b);\r\n  return rgbToHex(Math.round(A[0] + (B[0] - A[0]) * t), Math.round(A[1] + (B[1] - A[1]) * t), Math.round(A[2] + (B[2] - A[2]) * t));\r\n}\r\n\r\nexport function HudIconStamina({ percent, size = 48, className }: HudIconStaminaProps) {\r\n  const id = useRef(`bolt-${Math.random().toString(36).slice(2, 9)}`).current;\r\n  const gradId = `dynGradBolt-${id}`;\r\n  const outlineGradId = `metalOutlineGradBolt-${id}`;\r\n  const filterId = `liquidFilterBolt-${id}`;\r\n  const turbRef = useRef<SVGFETurbulenceElement | null>(null);\r\n  const dispRef = useRef<SVGFEDisplacementMapElement | null>(null);\r\n\r\n  // Ramp similar to the HTML sample (percent in 0..100 scale)\r\n  const ramp = [\r\n    { p: 100, s: ['#ffd27a', '#ff9a1a', '#d94f00'] },\r\n    { p: 70, s: ['#ffc06a', '#ff8b00', '#c54a00'] },\r\n    { p: 40, s: ['#ff9a3a', '#ff6600', '#b23f00'] },\r\n    { p: 15, s: ['#ff7a2a', '#e65100', '#7a2f00'] },\r\n    { p: 0, s: ['#5c2a14', '#341306', '#1a0b03'] },\r\n  ];\r\n\r\n  const [stops, setStops] = useState<string[]>(ramp[0].s);\r\n  // For wave animation control\r\n  const lastPercent = useRef<number>(percent * 100);\r\n  const waveAnimRef = useRef<{ id: number } | null>(null);\r\n\r\n  useEffect(() => {\r\n    const p100 = Math.max(0, Math.min(100, Math.round(percent * 100)));\r\n    // pick range\r\n    let lo = ramp[0], hi = ramp[ramp.length - 1];\r\n    for (let i = 0; i < ramp.length - 1; i++) {\r\n      const a = ramp[i], b = ramp[i + 1];\r\n      if (p100 <= a.p && p100 >= b.p) {\r\n        lo = a;\r\n        hi = b;\r\n        break;\r\n      }\r\n    }\r\n    const t = (p100 - hi.p) / (lo.p - hi.p || 1);\r\n    setStops([mixHex(hi.s[0], lo.s[0], t), mixHex(hi.s[1], lo.s[1], t), mixHex(hi.s[2], lo.s[2], t)]);\r\n\r\n    // Trigger wave on change\r\n    const delta = p100 - lastPercent.current;\r\n    if (Math.abs(delta) > 0.5) {\r\n      triggerWave(Math.abs(delta) / 100);\r\n    }\r\n    lastPercent.current = p100;\r\n  }, [percent]);\r\n\r\n  // Wave animation: update disp.scale and turb.baseFrequency over time\r\n  function triggerWave(mag: number) {\r\n  const dispEl = dispRef.current;\r\n  const turbEl = turbRef.current;\r\n  if (!dispEl || !turbEl) return;\r\n  if (waveAnimRef.current) cancelAnimationFrame(waveAnimRef.current.id);\r\n  const dispNonNull = dispEl as SVGFEDisplacementMapElement;\r\n  const turbNonNull = turbEl as SVGFETurbulenceElement;\r\n    const maxScale = 18 + mag * 50;\r\n    const baseFreq = 0.015 + mag * 0.03;\r\n    const duration = 900 + mag * 900;\r\n    const start = performance.now();\r\n    const anim = { id: 0 };\r\n    function step(now: number) {\r\n      const t = Math.min(1, (now - start) / duration);\r\n      const ease = 1 - Math.pow(1 - t, 3);\r\n      const scaleVal = maxScale * (1 - ease);\r\n      const freq = baseFreq * (1 + 0.6 * Math.sin(t * Math.PI * 2));\r\n      try {\r\n        dispNonNull.setAttribute('scale', scaleVal.toFixed(2));\r\n        turbNonNull.setAttribute('baseFrequency', freq.toFixed(4));\r\n      } catch (e) {\r\n        /* ignore */\r\n      }\r\n      if (t < 1) anim.id = requestAnimationFrame(step);\r\n      else {\r\n        try {\r\n          dispNonNull.setAttribute('scale', '0');\r\n          turbNonNull.setAttribute('baseFrequency', '0.015');\r\n        } catch (e) {}\r\n        waveAnimRef.current = null;\r\n      }\r\n    }\r\n    anim.id = requestAnimationFrame(step);\r\n    waveAnimRef.current = anim;\r\n  }\r\n\r\n  // Display ratio tweaks: use the provided 1024 viewBox path; keep visual\r\n  // scaling consistent with other icons by mapping `size` ΓåÆ display px.\r\n  // Use exact requested size for consistent HUD icon sizing\r\n  const displayWidth = size;\r\n  const displayHeight = size;\r\n\r\n  return (\r\n    <div className={cn('inline-block', className)} style={{ width: displayWidth, height: displayHeight }}>\r\n      {/* Use the 1024x1024 coordinate system to match the provided path */}\r\n      <svg viewBox={`0 0 1024 1024`} width={displayWidth} height={displayHeight} preserveAspectRatio=\"xMidYMid meet\">\r\n        <defs>\r\n          <linearGradient id={gradId} x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor={stops[0]} />\r\n            <stop offset=\"50%\" stopColor={stops[1]} />\r\n            <stop offset=\"100%\" stopColor={stops[2]} />\r\n          </linearGradient>\r\n\r\n          {/* Metallic outline gradient (from the provided sample) */}\r\n          <linearGradient id={outlineGradId} x1=\"0\" y1=\"0\" x2=\"1\" y2=\"1\">\r\n            <stop offset=\"0%\" stopColor=\"#7b4a1a\" />\r\n            <stop offset=\"30%\" stopColor=\"#d3a04a\" />\r\n            <stop offset=\"60%\" stopColor=\"#ffd88a\" />\r\n            <stop offset=\"100%\" stopColor=\"#8b5a22\" />\r\n          </linearGradient>\r\n\r\n          <filter id={filterId} x=\"-30%\" y=\"-30%\" width=\"160%\" height=\"160%\" colorInterpolationFilters=\"sRGB\">\r\n            <feTurbulence ref={(el) => { turbRef.current = el; }} type=\"fractalNoise\" baseFrequency=\"0.015\" numOctaves={2} seed={42} result=\"noise\" />\r\n            <feDisplacementMap ref={(el) => { dispRef.current = el; }} in=\"SourceGraphic\" in2=\"noise\" scale=\"0\" xChannelSelector=\"R\" yChannelSelector=\"G\" />\r\n          </filter>\r\n        </defs>\r\n\r\n        {/* Use AreaFill to compute area-aware fill; pass gradient url and filter on the filled group */}\r\n        <g>\r\n          <foreignObject x={0} y={0} width={1024} height={1024} style={{ overflow: 'visible', filter: 'drop-shadow(0px 6px 8px rgba(0,0,0,0.18))' }}>\r\n            {/* AreaFill will render its own SVG; we want fill to reference our gradient and apply filter */}\r\n            <div style={{ width: '100%', height: '100%', pointerEvents: 'none' }}>\r\n              {/* Pass size=1024 to match the path coordinate space */}\r\n              <AreaFill pathD={BOLT_PATH} percent={percent} size={1024} innerScale={0.965} fill={`url(#${gradId})`} fillGroupFilter={`url(#${filterId})`} />\r\n            </div>\r\n          </foreignObject>\r\n        </g>\r\n\r\n        {/* Metallic outline on top (thicker stroke appropriate for 1024 coords) */}\r\n        <path d={BOLT_PATH} fill=\"none\" stroke={`url(#${outlineGradId})`} strokeWidth={28} strokeLinejoin=\"round\" strokeLinecap=\"round\" />\r\n      </svg>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default HudIconStamina;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\icons.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\inventory-popup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ItemCategory' is defined but never used.","line":16,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":99,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n\"use client\";\r\n\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogHeader,\r\n  DialogTitle,\r\n  DialogDescription,\r\n} from \"@/components/ui/dialog\";\r\nimport { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator, DropdownMenuLabel } from \"@/components/ui/dropdown-menu\";\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport type { PlayerItem, ItemDefinition, Chunk, ItemCategory, PlayerAttributes, TranslatableString, ItemEffect } from \"@/lib/game/types\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\nimport { cn, getTranslatedText } from \"@/lib/utils\";\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\nimport { IconRenderer } from \"@/components/ui/icon-renderer\";\r\n\r\ninterface InventoryPopupProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  items: PlayerItem[];\r\n  itemDefinitions?: Record<string, ItemDefinition> | null;\r\n  enemy: Chunk['enemy'];\r\n  onUseItem: (itemName: TranslatableString, target: TranslatableString | 'player') => void;\r\n  onEquipItem: (itemName: string) => void;\r\n}\r\n\r\nconst categoryEmojis = {\r\n  Weapon: 'ΓÜö∩╕Å',\r\n  Tool: '≡ƒ¢á∩╕Å',\r\n  Material: '≡ƒº▒',\r\n  Food: '≡ƒì┤',\r\n  Support: 'Γ¥ñ∩╕Å',\r\n  Magic: 'Γ£¿',\r\n  Equipment: '≡ƒ¢í∩╕Å',\r\n  'Energy Source': 'ΓÜí',\r\n  Data: '≡ƒô£',\r\n  Fusion: '≡ƒîÇ',\r\n  Armor: '≡ƒ¢í∩╕Å',\r\n  Accessory: '≡ƒÆì',\r\n  Consumable: '≡ƒÿï',\r\n  Potion: '≡ƒº¬',\r\n  Utility: 'ΓÜÖ∩╕Å',\r\n  Misc: 'Γ¥ô',\r\n} as const;\r\n\r\nconst attributeLabels: Record<keyof PlayerAttributes, TranslationKey> = {\r\n    physicalAttack: 'physicalAttack',\r\n    magicalAttack: 'magicalAttack',\r\n    critChance: 'critChance',\r\n    attackSpeed: 'attackSpeed',\r\n    cooldownReduction: 'cooldownReduction',\r\n    physicalDefense: 'physicalDefense',\r\n    magicalDefense: 'magicalDefense',\r\n};\r\n\r\n\r\nexport function InventoryPopup({ open, onOpenChange, items, itemDefinitions, enemy, onUseItem, onEquipItem }: InventoryPopupProps) {\r\n  const { t, language } = useLanguage();\r\n  const pickIcon = (definition: any, item: any) => {\r\n    if (definition?.emoji && typeof definition.emoji === 'object' && definition.emoji.type === 'image') return definition.emoji;\r\n    if (definition && (definition as any).image) return (definition as any).image;\r\n    if (item?.emoji && typeof item.emoji === 'object' && item.emoji.type === 'image') return item.emoji;\r\n    return definition?.emoji ?? item?.emoji ?? 'Γ¥ô';\r\n  };\r\n\r\n  const handleAction = (callback: () => void) => {\r\n    // Close the popup first to ensure any modal overlay is removed before\r\n    // executing the action callback which may trigger toasts, state updates\r\n    // or other UI that could be affected by an overlay still present.\r\n    // This ordering avoids transient UI-blocking issues where a dialog\r\n    // overlay remains in the DOM while other components update.\r\n    onOpenChange(false);\r\n    try {\r\n      callback();\r\n    } catch (e) {\r\n      // swallow to avoid breaking UI; errors should still be visible in console\r\n      // but don't leave the popup open or block further interactions.\r\n       \r\n      console.error('Inventory action callback failed', e);\r\n    } finally {\r\n      // Safety: some third-party floating/dismiss layers temporarily set\r\n      // document.body.style.pointerEvents = 'none' to block outside clicks.\r\n      // If a library failed to restore that style (e.g. due to an exception\r\n      // or an interrupted lifecycle) the whole UI will become unclickable.\r\n      // Clear any residual pointer-events on the root elements here as a\r\n      // low-risk recovery measure.\r\n      try {\r\n        if (typeof document !== 'undefined' && document?.body) {\r\n          document.body.style.pointerEvents = '';\r\n        }\r\n        if (typeof document !== 'undefined' && document?.documentElement) {\r\n          document.documentElement.style.pointerEvents = '';\r\n        }\r\n      } catch (e) {\r\n        // ignore; defensive best-effort only\r\n      }\r\n    }\r\n  }\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent className=\"sm:max-w-[425px]\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"font-headline\">{t('inventoryPopupTitle')}</DialogTitle>\r\n          <DialogDescription>\r\n            {t('inventoryPopupDesc')}\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n        <Separator />\r\n        <ScrollArea className=\"h-60\">\r\n            <div className=\"p-4\">\r\n              {items.length > 0 ? (\r\n                <ul className=\"space-y-2\">\r\n                  {items.map((item, index) => {\r\n                    // Resolve using helper which supports both keys and display names\r\n                    const definition = resolveItemDef(getTranslatedText(item.name, 'en'), itemDefinitions || undefined);\r\n                    const isUsableOnSelf = !!(definition && definition.effects && definition.effects.length > 0);\r\n                    const isUsableOnEnemy = !!(enemy && definition && enemy.diet && enemy.diet.includes(getTranslatedText(item.name, 'en')));\r\n                    const isEquippable = definition && definition.equipmentSlot;\r\n                    const isInteractable = isUsableOnSelf || isUsableOnEnemy || isEquippable;\r\n\r\n                    const itemCategory = definition?.category;\r\n                    const categoryEmoji = itemCategory ? categoryEmojis[itemCategory as keyof typeof categoryEmojis] : 'Γ¥ô';\r\n\r\n                    return (\r\n                      <li key={index}>\r\n                        <DropdownMenu>\r\n                            <DropdownMenuTrigger asChild>\r\n                                <button\r\n                                    className={cn(\r\n                                        \"w-full flex justify-between items-center p-2 bg-muted rounded-md text-left text-sm cursor-pointer hover:bg-accent/20\"\r\n                                    )}\r\n                                >\r\n                                    <div className=\"flex items-center gap-2 flex-wrap\">\r\n                                        <IconRenderer icon={pickIcon(definition, item)} size={typeof pickIcon(definition, item) === 'object' ? 45 : 30} alt={getTranslatedText(item.name, language)} />\r\n                                        <div className=\"flex flex-col items-start\">\r\n                                            <span className=\"text-foreground\">{getTranslatedText(item.name, language)}</span>\r\n                                            <div className=\"flex items-center gap-2\">\r\n                                              <span className=\"text-xs px-1.5 py-0.5 rounded-full bg-primary/10 text-primary-foreground font-semibold\">{t('tier', { tier: item.tier })}</span>\r\n                                              {definition && definition.category && <span title={t(definition.category)} className=\"text-xs px-1.5 py-0.5 rounded-full bg-accent/80 text-accent-foreground flex items-center gap-1\">{categoryEmoji}</span>}\r\n                                            </div>\r\n                                        </div>\r\n                                    </div>\r\n                                    <span className=\"font-mono text-sm font-bold text-foreground\">x{item.quantity}</span>\r\n                                </button>\r\n                            </DropdownMenuTrigger>\r\n                            \r\n                            <DropdownMenuContent className=\"w-64\">\r\n                <DropdownMenuLabel className=\"font-normal\">\r\n                  <p className=\"font-bold flex items-center gap-2\">\r\n                    <IconRenderer icon={pickIcon(definition, item)} size={typeof pickIcon(definition, item) === 'object' ? 45 : 30} alt={getTranslatedText(item.name, language)} />\r\n                    {getTranslatedText(item.name, language)}\r\n                  </p>\r\n                  {!definition ? (\r\n                    <p className=\"text-xs text-red-500 whitespace-normal\">Item definition not found!</p>\r\n                  ) : (\r\n                    <p className=\"text-xs text-muted-foreground whitespace-normal\">{getTranslatedText(definition?.description ?? '', language)}</p>\r\n                  )}\r\n                </DropdownMenuLabel>\r\n                                \r\n                                {isInteractable && (\r\n                                  <>\r\n                                    {(definition?.effects?.length > 0 || definition?.attributes) && <DropdownMenuSeparator />}\r\n                                    \r\n                                    {definition?.attributes && (\r\n                                        <div className=\"px-2 py-1.5 text-xs space-y-1\">\r\n                                            <p className=\"font-semibold text-muted-foreground\">{t('attributes')}:</p>\r\n                                            {Object.entries(definition.attributes).map(([key, value]) => {\r\n                                                if (typeof value !== 'number' || value === 0) return null;\r\n                                                const sign = value > 0 ? '+' : '';\r\n                                                return (\r\n                                                    <p key={key} className={cn(\"ml-2\", value > 0 ? \"text-green-500\" : \"text-red-500\")}>\r\n                                                        {sign}{value}{key.includes('Reduction') || key.includes('Chance') ? '%' : ''} {t(attributeLabels[key as keyof PlayerAttributes])}\r\n                                                    </p>\r\n                                                )\r\n                                            })}\r\n                                        </div>\r\n                                    )}\r\n\r\n                                    {definition?.effects?.length > 0 && (\r\n                                        <div className=\"px-2 py-1.5 text-xs space-y-1\">\r\n                                            <p className=\"font-semibold text-muted-foreground\">{t('effects')}:</p>\r\n                                            {definition.effects.map((effect: ItemEffect, i) => (\r\n                                                <p key={i} className=\"text-green-500 ml-2\">\r\n                                                    {effect.type === 'HEAL' && `+${effect.amount} ${t('healthShort')}`}\r\n                                                    {effect.type === 'RESTORE_STAMINA' && `+${effect.amount} ${t('staminaShort')}`}\r\n                                                </p>\r\n                                            ))}\r\n                                        </div>\r\n                                    )}\r\n\r\n                                    <DropdownMenuSeparator />\r\n                                    {isUsableOnSelf && <DropdownMenuItem onClick={() => handleAction(() => onUseItem(item.name, 'player'))}>{t('useOnSelf')}</DropdownMenuItem>}\r\n                                    {isUsableOnEnemy && <DropdownMenuItem onClick={() => handleAction(() => onUseItem(item.name, enemy?.type ?? 'player'))}>{t('useOnTarget', { target: enemy?.type ? getTranslatedText(enemy.type, language, t) : t('no_enemy_found') })}</DropdownMenuItem>}\r\n                                    {isEquippable && <DropdownMenuItem onClick={() => handleAction(() => onEquipItem(getTranslatedText(item.name, 'en')))}>{t('equipItem')}</DropdownMenuItem>}\r\n                                  </>\r\n                                )}\r\n                            </DropdownMenuContent>\r\n                        </DropdownMenu>\r\n                      </li>\r\n                    );\r\n                  })}\r\n                </ul>\r\n              ) : (\r\n                <p className=\"text-center text-muted-foreground\">{t('inventoryEmpty')}</p>\r\n              )}\r\n            </div>\r\n        </ScrollArea>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\language-selector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\minimap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\pwa-install-popup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\settings-popup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Theme' is defined but never used.","line":15,"column":73,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":78},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Home' is defined but never used.","line":23,"column":104,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":108},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isInGame' is defined but never used. Allowed unused args must match /^_/u.","line":34,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n\"use client\";\r\n\r\nimport { useState, useEffect, useMemo } from \"react\";\r\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from \"@/components/ui/dialog\";\r\nimport { Label } from \"@/components/ui/label\";\r\nimport { RadioGroup, RadioGroupItem } from \"@/components/ui/radio-group\";\r\nimport { Switch } from \"@/components/ui/switch\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport { useSettings } from \"@/context/settings-context\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport { usePwaInstall } from \"@/context/pwa-install-context\";\r\nimport { useAuth } from \"@/context/auth-context\";\r\nimport type { DiceType, AiModel, NarrativeLength, FontFamily, FontSize, Theme } from \"@/lib/game/types\";\r\nimport { Language } from \"@/lib/i18n\";\r\nimport { Button } from \"../ui/button\";\r\nimport { Textarea } from \"../ui/textarea\";\r\nimport { Slider } from \"../ui/slider\";\r\nimport { useAudio } from \"@/lib/audio/useAudio\";\r\nimport { BACKGROUND_MUSIC, MENU_MUSIC } from \"@/lib/audio/assets\";\r\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from \"@/components/ui/tooltip\";\r\nimport { Settings, BrainCircuit, Dice6, Bot, Feather, Languages, Download, LogIn, LogOut, UserCircle2, Home, Palette, Type, BookOpen } from \"./icons\";\r\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\r\n\r\n\r\ninterface SettingsPopupProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  isInGame: boolean;\r\n    currentBiome?: string | null;\r\n}\r\n\r\nexport function SettingsPopup({ open, onOpenChange, isInGame, currentBiome }: SettingsPopupProps) {\r\n    const { t, language, setLanguage } = useLanguage();\r\n  const { settings, setSettings, applyMods, clearMods } = useSettings();\r\n  const { installPrompt, setInstallPrompt } = usePwaInstall();\r\n  const { user, login, logout, isFirebaseConfigured } = useAuth();\r\n  const [modInput, setModInput] = useState(() => {\r\n    if (typeof window !== 'undefined') {\r\n        return localStorage.getItem('gameMods') || '';\r\n    }\r\n    return '';\r\n  });\r\n\r\n  const handleInstallClick = () => {\r\n    if (!installPrompt) return;\r\n    installPrompt.prompt();\r\n    installPrompt.userChoice.then((choiceResult: any) => {\r\n      if (choiceResult.outcome === 'accepted') {\r\n        console.log('User accepted the PWA installation');\r\n      } else {\r\n        console.log('User dismissed the PWA installation');\r\n      }\r\n      setInstallPrompt(null);\r\n    });\r\n  };\r\n\r\n  const handleApplyMods = () => {\r\n      applyMods(modInput);\r\n      alert(t('modsApplied'));\r\n  }\r\n  \r\n  const handleClearMods = () => {\r\n      clearMods();\r\n      setModInput('');\r\n      alert(t('modsCleared'));\r\n  }\r\n\r\n        const handleLanguageChange = (value: string) => setLanguage(value as Language, currentBiome ?? undefined);\r\n  const handleGameModeChange = (checked: boolean) => setSettings({ gameMode: checked ? 'ai' : 'offline' });\r\n  const handleDiceTypeChange = (value: string) => setSettings({ diceType: value as DiceType });\r\n  const handleAiModelChange = (value: string) => setSettings({ aiModel: value as AiModel });\r\n  const handleNarrativeLengthChange = (value: string) => setSettings({ narrativeLength: value as NarrativeLength });\r\n  const handleThemeChange = (checked: boolean) => setSettings({ theme: checked ? 'dark' : 'light' });\r\n  const handleFontFamilyChange = (value: string) => setSettings({ fontFamily: value as FontFamily });\r\n  const handleFontSizeChange = (value: string) => setSettings({ fontSize: value as FontSize });\r\n    const [isDesktop, setIsDesktop] = useState(false);\r\n        const audio = useAudio();\r\n        const allBackground = useMemo(() => BACKGROUND_MUSIC.concat(MENU_MUSIC), []);\r\n        const [selectedTrack, setSelectedTrack] = useState<string | undefined>(allBackground[0]);\r\n\r\n    useEffect(() => {\r\n        const onResize = () => setIsDesktop(typeof window !== 'undefined' && window.innerWidth >= 768);\r\n        onResize();\r\n        window.addEventListener('resize', onResize);\r\n        return () => window.removeEventListener('resize', onResize);\r\n    }, []);\r\n\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent className=\"sm:max-w-md\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"font-headline flex items-center gap-2\"><Settings /> {t('gameSettings')}</DialogTitle>\r\n          <DialogDescription>{t('gameSettingsDesc')}</DialogDescription>\r\n        </DialogHeader>\r\n        \r\n        <Tabs defaultValue=\"general\" className=\"w-full\">\r\n            <TabsList className=\"grid w-full grid-cols-3\">\r\n                <TabsTrigger value=\"general\">{t('settingsTabGeneral')}</TabsTrigger>\r\n                <TabsTrigger value=\"gameplay\">{t('settingsTabGameplay')}</TabsTrigger>\r\n                <TabsTrigger value=\"mods\">{t('settingsTabMods')}</TabsTrigger>\r\n            </TabsList>\r\n            \r\n            <div className=\"max-h-[70vh] overflow-y-auto pr-4 mt-4\">\r\n\r\n            <TabsContent value=\"general\" className=\"space-y-6\">\r\n                 <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><UserCircle2 /> {t('accountSync')}</Label>\r\n                    {isFirebaseConfigured ? (\r\n                    <>\r\n                        <p className=\"text-sm leading-snug text-muted-foreground\">{t('accountSyncDesc')}</p>\r\n                        {user ? (\r\n                        <div className=\"flex items-center justify-between\">\r\n                            <span className=\"text-sm text-foreground truncate\">{user.displayName || user.email}</span>\r\n                            <Button variant=\"ghost\" onClick={logout}><LogOut className=\"mr-2\" />{t('logout')}</Button>\r\n                        </div>\r\n                        ) : (\r\n                        <Button onClick={login} className=\"w-full\"><LogIn className=\"mr-2\" />{t('loginWithGoogle')}</Button>\r\n                        )}\r\n                    </>\r\n                    ) : (\r\n                    <p className=\"text-sm leading-snug text-destructive\">{t('firebaseNotConfigured')}</p>\r\n                    )}\r\n                </div>\r\n                \r\n                <Separator />\r\n\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Languages /> {t('language')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('languageDesc')}</p>\r\n                    <RadioGroup value={language} onValueChange={handleLanguageChange} className=\"grid grid-cols-2 gap-4\">\r\n                        <div><RadioGroupItem value=\"vi\" id=\"vi\" className=\"sr-only peer\" /><Label htmlFor=\"vi\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">Tiß║┐ng Viß╗çt</Label></div>\r\n                        <div><RadioGroupItem value=\"en\" id=\"en\" className=\"sr-only peer\" /><Label htmlFor=\"en\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">English</Label></div>\r\n                    </RadioGroup>\r\n                </div>\r\n\r\n                <Separator />\r\n          \r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Palette /> {t('theme')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('themeDesc')}</p>\r\n                    <div className=\"flex items-center justify-between rounded-lg border p-3 shadow-sm\">\r\n                    <Label htmlFor=\"theme-switch\" className=\"flex flex-col space-y-1\"><span>{settings.theme === 'dark' ? t('darkTheme') : t('lightTheme')}</span></Label>\r\n                    <Switch id=\"theme-switch\" checked={settings.theme === 'dark'} onCheckedChange={handleThemeChange}/>\r\n                    </div>\r\n                </div>\r\n\r\n                <Separator />\r\n                \r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Type /> {t('fontFamily')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('fontFamilyDesc')}</p>\r\n                    <RadioGroup value={settings.fontFamily} onValueChange={handleFontFamilyChange} className=\"grid grid-cols-3 gap-2\">\r\n                        <div><RadioGroupItem value=\"literata\" id=\"literata\" className=\"sr-only peer\" /><Label htmlFor=\"literata\" className=\"flex h-full text-center items-center justify-center rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer font-literata\">{t('fontLiterata')}</Label></div>\r\n                        <div><RadioGroupItem value=\"inter\" id=\"inter\" className=\"sr-only peer\" /><Label htmlFor=\"inter\" className=\"flex h-full text-center items-center justify-center rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer font-inter\">{t('fontInter')}</Label></div>\r\n                        <div><RadioGroupItem value=\"source_code_pro\" id=\"source-code-pro\" className=\"sr-only peer\" /><Label htmlFor=\"source-code-pro\" className=\"flex h-full text-center items-center justify-center rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer font-source-code-pro\">{t('fontSourceCodePro')}</Label></div>\r\n                    </RadioGroup>\r\n                </div>\r\n\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Type /> {t('fontSize')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('fontSizeDesc')}</p>\r\n                    <RadioGroup value={settings.fontSize} onValueChange={handleFontSizeChange} className=\"grid grid-cols-3 gap-4\">\r\n                        <div><RadioGroupItem value=\"sm\" id=\"sm\" className=\"sr-only peer\" /><Label htmlFor=\"sm\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">{t('fontSizeSmall')}</Label></div>\r\n                        <div><RadioGroupItem value=\"base\" id=\"base\" className=\"sr-only peer\" /><Label htmlFor=\"base\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">{t('fontSizeMedium')}</Label></div>\r\n                        <div><RadioGroupItem value=\"lg\" id=\"lg\" className=\"sr-only peer\" /><Label htmlFor=\"lg\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">{t('fontSizeLarge')}</Label></div>\r\n                    </RadioGroup>\r\n                </div>\r\n                <Separator />\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\">≡ƒöè ├ém thanh</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">─Éiß╗üu chß╗ënh nhß║íc nß╗ün v├á hiß╗çu ß╗⌐ng ├óm thanh.</p>\r\n                    <div className=\"rounded-lg border p-3 shadow-sm\">\r\n                        <div className=\"mb-3\">\r\n                            <div className=\"flex items-center justify-between mb-2\">\r\n                                <div className=\"font-medium\">Nhß║íc</div>\r\n                                <div className=\"flex gap-2\">\r\n                                    <Button variant=\"ghost\" size=\"sm\" onClick={() => audio.setMuted(!audio.muted)}>\r\n                                        {audio.muted ? 'Bß║¡t ├óm' : 'Tß║»t ├óm'}\r\n                                    </Button>\r\n                                </div>\r\n                            </div>\r\n                            <div className=\"mb-2\">\r\n                                <label className=\"text-xs text-muted-foreground\">Chß╗ìn b├ái</label>\r\n                                <select className=\"w-full mt-1 p-1 rounded bg-popover\" value={selectedTrack} onChange={(e) => setSelectedTrack(e.target.value)}>\r\n                                    {allBackground.map(ti => (<option key={ti} value={ti}>{ti}</option>))}\r\n                                </select>\r\n                            </div>\r\n                            <div className=\"flex items-center gap-2\">\r\n                                <Button size=\"sm\" onClick={() => audio.playMusic(selectedTrack)}>{'Ph├ít'}</Button>\r\n                                <Button size=\"sm\" onClick={() => audio.pauseMusic()}>Tß║ím dß╗½ng</Button>\r\n                                <Button size=\"sm\" onClick={() => audio.stopMusic()}>Dß╗½ng</Button>\r\n                            </div>\r\n                            <div className=\"mt-3\">\r\n                                <div className=\"text-xs text-muted-foreground mb-1\">├ém l╞░ß╗úng nhß║íc</div>\r\n                                <Slider value={[audio.musicVolume]} onValueChange={(v) => audio.setMusicVolume(v[0] ?? 0.5)} step={0.01} min={0} max={1} />\r\n                            </div>\r\n                            {/* Autoplay safety CTA: if browser blocked autoplay, allow the user to retry */}\r\n                            {audio.autoplayBlocked && (\r\n                                <div className=\"mt-3 p-2 border rounded bg-yellow-50\">\r\n                                    <div className=\"text-sm font-medium\">Autoplay bß╗ï chß║╖n</div>\r\n                                    <div className=\"text-xs text-muted-foreground mb-2\">Tr├¼nh duyß╗çt ─æ├ú chß║╖n tß╗▒ ─æß╗Öng ph├ít nhß║íc menu. Nhß║Ñn \"Bß║¡t ├óm\" ─æß╗â cho ph├⌐p ph├ít ngay khi bß║ín t╞░╞íng t├íc.</div>\r\n                                    <div className=\"flex gap-2\">\r\n                                        <Button size=\"sm\" onClick={() => audio.tryEnableAutoplay()}>Bß║¡t ├óm</Button>\r\n                                        <Button size=\"sm\" variant=\"ghost\" onClick={() => { try { localStorage.setItem('dl_auto_menu', '0'); audio.setMuted(true); } catch {} }}>Tß║ím ho├ún</Button>\r\n                                    </div>\r\n                                </div>\r\n                            )}\r\n                        </div>\r\n\r\n                        <div className=\"mt-4\">\r\n                            <div className=\"text-xs text-muted-foreground mb-1\">Hiß╗çu ß╗⌐ng (SFX)</div>\r\n                            <Slider value={[audio.sfxVolume]} onValueChange={(v) => audio.setSfxVolume(v[0] ?? 0.9)} step={0.01} min={0} max={1} />\r\n                            <div className=\"flex gap-2 mt-3\">\r\n                                <Button size=\"sm\" onClick={() => audio.playSfx('Menu_Select_00.mp3')}>Play select</Button>\r\n                                <Button size=\"sm\" onClick={() => audio.playSfx('Pickup_Gold_00.mp3')}>Play pickup</Button>\r\n                            </div>\r\n                        </div>\r\n\r\n                        <div className=\"mt-4\">\r\n                            <div className=\"text-xs text-muted-foreground mb-1\">Tß║ºn suß║Ñt nhß║íc nß╗ün</div>\r\n                            <div className=\"flex items-center gap-4 mb-2\">\r\n                                <label className=\"flex items-center gap-1\">\r\n                                    <input type=\"radio\" name=\"playbackMode\" checked={audio.playbackMode === 'off'} onChange={() => audio.setPlaybackMode('off')} />\r\n                                    <span className=\"ml-1\">Kh├┤ng</span>\r\n                                </label>\r\n                                <label className=\"flex items-center gap-1\">\r\n                                    <input type=\"radio\" name=\"playbackMode\" checked={audio.playbackMode === 'occasional'} onChange={() => audio.setPlaybackMode('occasional')} />\r\n                                    <span className=\"ml-1\">Thß╗ënh thoß║úng</span>\r\n                                </label>\r\n                                <label className=\"flex items-center gap-1\">\r\n                                    <input type=\"radio\" name=\"playbackMode\" checked={audio.playbackMode === 'always'} onChange={() => audio.setPlaybackMode('always')} />\r\n                                    <span className=\"ml-1\">Lu├┤n lu├┤n</span>\r\n                                </label>\r\n                            </div>\r\n                            {audio.playbackMode === 'occasional' && (\r\n                                <div className=\"flex items-center gap-2\">\r\n                                    <label className=\"text-xs text-muted-foreground\">Khoß║úng (ph├║t)</label>\r\n                                    <input type=\"number\" min={1} value={audio.playbackIntervalMinutes} onChange={(e) => audio.setPlaybackIntervalMinutes(Number(e.target.value) || 1)} className=\"w-20 p-1 rounded bg-popover\" />\r\n                                    <div className=\"text-xs text-muted-foreground\">Mß╗Öt b├ái sß║╜ tß╗▒ ph├ít sau mß╗ùi khoß║úng ─æ├ú chß╗ìn.</div>\r\n                                </div>\r\n                            )}\r\n                            {audio.playbackMode === 'always' && (\r\n                                <div className=\"text-xs text-muted-foreground\">Lu├┤n ph├ít li├¬n tiß║┐p: sau khi 1 b├ái kß║┐t th├║c sß║╜ ph├ít tiß║┐p sau 5 gi├óy.</div>\r\n                            )}\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            </TabsContent>\r\n\r\n            <TabsContent value=\"gameplay\" className=\"space-y-6\">\r\n                <div className=\"flex items-center justify-between space-x-4\">\r\n                    <Label htmlFor=\"game-mode\" className=\"flex flex-col space-y-1\">\r\n                        <span className=\"font-semibold flex items-center gap-2\"><BrainCircuit /> {t('aiStoryteller')}</span>\r\n                        <span className=\"font-normal leading-snug text-muted-foreground\">{t('aiStorytellerDesc')}</span>\r\n                    </Label>\r\n                    <Switch id=\"game-mode\" checked={settings.gameMode === 'ai'} onCheckedChange={handleGameModeChange}/>\r\n                </div>\r\n                <Separator />\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Dice6 /> {t('diceType')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('diceTypeDesc')}</p>\r\n                    <RadioGroup value={settings.diceType} onValueChange={handleDiceTypeChange} className=\"grid grid-cols-3 gap-4\">\r\n                        <div><RadioGroupItem value=\"d20\" id=\"d20\" className=\"sr-only peer\" /><Label htmlFor=\"d20\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">D20</Label></div>\r\n                        <div><RadioGroupItem value=\"d12\" id=\"d12\" className=\"sr-only peer\" /><Label htmlFor=\"d12\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">D12</Label></div>\r\n                        <div><RadioGroupItem value=\"2d6\" id=\"2d6\" className=\"sr-only peer\" /><Label htmlFor=\"2d6\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">2D6</Label></div>\r\n                    </RadioGroup>\r\n                </div>\r\n                <Separator />\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Bot /> {t('aiModelPreference')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('aiModelPreferenceDesc')}</p>\r\n                    <RadioGroup value={settings.aiModel} onValueChange={handleAiModelChange} className=\"grid grid-cols-2 gap-4\">\r\n                        <div><RadioGroupItem value=\"balanced\" id=\"balanced\" className=\"sr-only peer\" /><Label htmlFor=\"balanced\" className=\"flex h-full cursor-pointer flex-col items-start justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary\"><span className=\"font-semibold\">{t('modelChronicler')}</span><span className=\"mt-2 text-xs text-muted-foreground\">{t('modelChroniclerDesc')}</span></Label></div>\r\n                        <div><RadioGroupItem value=\"quality\" id=\"quality\" className=\"sr-only peer\" /><Label htmlFor=\"quality\" className=\"flex h-full cursor-pointer flex-col items-start justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary\"><span className=\"font-semibold\">{t('modelOracle')}</span><span className=\"mt-2 text-xs text-muted-foreground\">{t('modelOracleDesc')}</span></Label></div>\r\n                        <div><RadioGroupItem value=\"creative\" id=\"creative\" className=\"sr-only peer\" /><Label htmlFor=\"creative\" className=\"flex h-full cursor-pointer flex-col items-start justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary\"><span className=\"font-semibold\">{t('modelDreamer')}</span><span className=\"mt-2 text-xs text-muted-foreground\">{t('modelDreamerDesc')}</span></Label></div>\r\n                        <div><RadioGroupItem value=\"fast\" id=\"fast\" className=\"sr-only peer\" /><Label htmlFor=\"fast\" className=\"flex h-full cursor-pointer flex-col items-start justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary\"><span className=\"font-semibold\">{t('modelImp')}</span><span className=\"mt-2 text-xs text-muted-foreground\">{t('modelImpDesc')}</span></Label></div>\r\n                    </RadioGroup>\r\n                </div>\r\n                <Separator />\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Feather /> {t('narrativeLength')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('narrativeLengthDesc')}</p>\r\n                    <RadioGroup value={settings.narrativeLength} onValueChange={handleNarrativeLengthChange} className=\"grid grid-cols-3 gap-4\">\r\n                        <div><RadioGroupItem value=\"short\" id=\"short\" className=\"sr-only peer\" /><Label htmlFor=\"short\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">{t('lengthShort')}</Label></div>\r\n                        <div><RadioGroupItem value=\"medium\" id=\"medium\" className=\"sr-only peer\" /><Label htmlFor=\"medium\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">{t('lengthMedium')}</Label></div>\r\n                        <div><RadioGroupItem value=\"long\" id=\"long\" className=\"sr-only peer\" /><Label htmlFor=\"long\" className=\"flex flex-col items-center justify-between rounded-md border-2 border-muted bg-popover p-4 hover:bg-accent hover:text-accent-foreground peer-data-[state=checked]:border-primary [&:has([data-state=checked])]:border-primary cursor-pointer\">{t('lengthLong')}</Label></div>\r\n                    </RadioGroup>\r\n                </div>\r\n                <Separator />\r\n                <div className=\"flex items-center justify-between space-x-4\">\r\n                    <Label htmlFor=\"controls-scroll-switch\" className=\"flex flex-col space-y-1\">\r\n                        <span className=\"font-semibold\">{t('preventControlsScroll') || 'Prevent controls auto-scroll'}</span>\r\n                        <span className=\"font-normal leading-snug text-muted-foreground\">{t('preventControlsScrollDesc') || 'When enabled, focusing the controls input on desktop will avoid auto-scrolling the controls panel.'}</span>\r\n                    </Label>\r\n                    <Switch id=\"controls-scroll-switch\" checked={settings.controlsPreventScroll ?? true} onCheckedChange={(v) => setSettings({ controlsPreventScroll: !!v })} />\r\n                </div>\r\n                <div>\r\n                    <Label className=\"font-semibold mt-4\">{t('keyBindings') || 'Key bindings'}</Label>\r\n                    <p className=\"text-sm text-muted-foreground mb-2\">{t('keyBindingsDesc') || 'Customize keyboard shortcuts for movement and common actions.'}</p>\r\n                    <KeyBindingsEditor settings={settings} setSettings={setSettings} />\r\n                </div>\r\n                {isDesktop && (\r\n                <>\r\n                <Separator />\r\n                <div className=\"flex items-center justify-between space-x-4\">\r\n                    <Label htmlFor=\"legacy-layout-switch\" className=\"flex flex-col space-y-1\">\r\n                        <span className=\"font-semibold\">{t('useLegacyLayout') || 'Use legacy layout'}</span>\r\n                        <span className=\"font-normal leading-snug text-muted-foreground\">{t('useLegacyLayoutDesc') || 'Show the mobile-style bottom action bar on desktop (legacy).'} </span>\r\n                    </Label>\r\n                    <Switch id=\"legacy-layout-switch\" checked={!!settings.useLegacyLayout} onCheckedChange={(v) => setSettings({ useLegacyLayout: !!v })} />\r\n                </div>\r\n                </>\r\n                )}\r\n            </TabsContent>\r\n            \r\n            <TabsContent value=\"mods\" className=\"space-y-6\">\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><BookOpen /> {t('modsTitle')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('modsDesc')}</p>\r\n                    <Textarea \r\n                        placeholder={t('modsPlaceholder')}\r\n                        value={modInput}\r\n                        onChange={(e) => setModInput(e.target.value)}\r\n                        rows={8}\r\n                    />\r\n                    <div className=\"grid grid-cols-2 gap-2\">\r\n                        <Button variant=\"destructive\" onClick={handleClearMods}>{t('modsClear')}</Button>\r\n                        <Button onClick={handleApplyMods}>{t('modsApply')}</Button>\r\n                    </div>\r\n                     <p className=\"text-xs leading-snug text-muted-foreground pt-2\">{t('modsWarning')}</p>\r\n                </div>\r\n                 <Separator />\r\n                <div className=\"space-y-3\">\r\n                    <Label className=\"font-semibold flex items-center gap-2\"><Download /> {t('installAppTitle')}</Label>\r\n                    <p className=\"text-sm leading-snug text-muted-foreground\">{t('installAppSettingDesc')}</p>\r\n                    <TooltipProvider>\r\n                        <Tooltip>\r\n                            <TooltipTrigger asChild><span className=\"inline-block w-full\"><Button onClick={handleInstallClick} className=\"w-full\" disabled={!installPrompt}><Download className=\"mr-2 h-4 w-4\" />{t('install')}</Button></span></TooltipTrigger>\r\n                            {!installPrompt && (<TooltipContent><p>{t('installNotAvailableTooltip')}</p></TooltipContent>)}\r\n                        </Tooltip>\r\n                    </TooltipProvider>\r\n                </div>\r\n            </TabsContent>\r\n\r\n            </div>\r\n        </Tabs>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n\r\n// Simple key bindings editor used inside SettingsPopup. It listens for a single key press\r\n// when the user clicks \"Change\" and persists the result into settings via setSettings.\r\nfunction KeyBindingsEditor({ settings, setSettings }: { settings: any; setSettings: (s: any) => void }) {\r\n    const { t } = useLanguage();\r\n    const [listeningFor, setListeningFor] = useState<string | null>(null);\r\n\r\n    useEffect(() => {\r\n        if (!listeningFor) return;\r\n        const handler = (e: KeyboardEvent) => {\r\n            e.preventDefault?.();\r\n            const key = e.key;\r\n            // update the specific binding\r\n            setSettings({ keyBindings: { ...(settings.keyBindings || {}), [listeningFor]: [key] } });\r\n            setListeningFor(null);\r\n        };\r\n        const cancel = (e: KeyboardEvent) => {\r\n            if (e.key === 'Escape') setListeningFor(null);\r\n        };\r\n        window.addEventListener('keydown', handler, { capture: true });\r\n        window.addEventListener('keydown', cancel);\r\n        return () => {\r\n            window.removeEventListener('keydown', handler, { capture: true });\r\n            window.removeEventListener('keydown', cancel);\r\n        };\r\n    }, [listeningFor, setSettings, settings.keyBindings]);\r\n\r\n    const getLabel = (k: string) => {\r\n        const val = settings?.keyBindings?.[k];\r\n        if (!val) return '(unset)';\r\n        return Array.isArray(val) ? val.join(', ') : String(val);\r\n    };\r\n\r\n    const resetDefaults = () => {\r\n        localStorage.removeItem('gameSettings');\r\n        // Reload page so SettingsProvider rehydrates defaults\r\n        window.location.reload();\r\n    };\r\n\r\n    return (\r\n        <div className=\"space-y-2\">\r\n            {[\r\n                { key: 'moveUp', label: t('moveUp') || 'Move Up' },\r\n                { key: 'moveDown', label: t('moveDown') || 'Move Down' },\r\n                { key: 'moveLeft', label: t('moveLeft') || 'Move Left' },\r\n                { key: 'moveRight', label: t('moveRight') || 'Move Right' },\r\n                { key: 'attack', label: t('attack') || 'Attack' },\r\n                { key: 'openInventory', label: t('inventoryShort') || 'Inventory' },\r\n                { key: 'openStatus', label: t('statusShort') || 'Status' },\r\n                { key: 'openMap', label: t('minimap') || 'Map' },\r\n                { key: 'pickUp', label: t('pickUpItems') || 'Pick up items' },\r\n                { key: 'hot1', label: 'Hotkey 1' },\r\n                { key: 'hot2', label: 'Hotkey 2' },\r\n                { key: 'hot3', label: 'Hotkey 3' },\r\n                { key: 'hot4', label: 'Hotkey 4' },\r\n                { key: 'hot5', label: 'Hotkey 5' },\r\n            ].map((row) => (\r\n                <div key={row.key} className=\"flex items-center justify-between\">\r\n                    <div className=\"text-sm\">{row.label}</div>\r\n                    <div className=\"flex items-center gap-2\">\r\n                        <div className=\"text-xs text-muted-foreground\">{getLabel(row.key)}</div>\r\n                        <Button size=\"sm\" onClick={() => setListeningFor(row.key)}>{listeningFor === row.key ? (t('pressAnyKey') || 'Press any key...') : (t('change') || 'Change')}</Button>\r\n                    </div>\r\n                </div>\r\n            ))}\r\n            <div className=\"flex gap-2\">\r\n                <Button variant=\"ghost\" onClick={() => setSettings({ keyBindings: settings.keyBindings })}>{t('save') || 'Save'}</Button>\r\n                <Button variant=\"destructive\" onClick={resetDefaults}>{t('resetToDefaults') || 'Reset to defaults'}</Button>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\status-popup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslationKey' is defined but never used.","line":20,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":76,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n\"use client\";\r\n\r\nimport { useState } from \"react\";\r\nimport {\r\n  Dialog,\r\n  DialogContent,\r\n  DialogHeader,\r\n  DialogTitle,\r\n  DialogDescription,\r\n} from \"@/components/ui/dialog\";\r\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from \"@/components/ui/accordion\";\r\nimport { Progress } from \"@/components/ui/progress\";\r\nimport { ScrollArea } from \"@/components/ui/scroll-area\";\r\nimport { Separator } from \"@/components/ui/separator\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport type { PlayerStatus, Skill, EquipmentSlot } from \"@/lib/game/types\";\r\nimport { skillDefinitions } from \"@/lib/game/skills\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\nimport { cn, getTranslatedText } from \"@/lib/utils\";\r\nimport { Heart, Loader2, Book, Star, Sparkles, SwordIcon } from \"./icons\";\r\nimport { Button } from \"../ui/button\";\r\nimport { IconRenderer } from \"@/components/ui/icon-renderer\";\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\n\r\ninterface StatusPopupProps {\r\n  open: boolean;\r\n  onOpenChange: (open: boolean) => void;\r\n  stats: PlayerStatus;\r\n  itemDefinitions?: Record<string, any>;\r\n  onRequestHint: (questText: string) => Promise<void>;\r\n  onUnequipItem: (slot: EquipmentSlot) => void;\r\n}\r\n\r\nconst clamp = (num: number, min: number, max: number) => Math.min(Math.max(num, min), max);\r\nconst normalizeTemp = (temp: number) => {\r\n    const minTemp = 20;\r\n    const maxTemp = 50;\r\n    return clamp(((temp - minTemp) / (maxTemp - minTemp)) * 100, 0, 100);\r\n}\r\n\r\ntype HintFetchStatus = {\r\n  isLoading: boolean;\r\n  error?: string;\r\n}\r\n\r\nconst getNextUnlockableSkills = (currentSkills: Skill[]): Skill[] => {\r\n    const currentSkillNames = new Set(currentSkills.map(s => getTranslatedText(s.name, 'en')));\r\n    return skillDefinitions.filter(\r\n        skillDef => !currentSkillNames.has(getTranslatedText(skillDef.name, 'en')) && skillDef.unlockCondition\r\n    );\r\n};\r\n\r\n\r\nexport function StatusPopup({ open, onOpenChange, stats, itemDefinitions, onRequestHint, onUnequipItem }: StatusPopupProps) {\r\n  const { t, language } = useLanguage();\r\n  const quests = stats.quests;\r\n  const pets = stats.pets || [];\r\n  const bodyTemp = stats.bodyTemperature ?? 37.0;\r\n  const mana = stats.mana ?? 0;\r\n\r\n  const [hintFetchStatus, setHintFetchStatus] = useState<Record<string, HintFetchStatus>>({});\r\n\r\n  const handleQuestClick = async (questText: string) => {\r\n    // Don't re-fetch if hint exists or is already loading\r\n    if (stats.questHints?.[questText] || hintFetchStatus[questText]?.isLoading) {\r\n      return;\r\n    }\r\n\r\n    setHintFetchStatus(prev => ({ ...prev, [questText]: { isLoading: true } }));\r\n    \r\n    try {\r\n        await onRequestHint(questText);\r\n        setHintFetchStatus(prev => ({ ...prev, [questText]: { isLoading: false } }));\r\n    } catch (e) {\r\n        setHintFetchStatus(prev => ({ ...prev, [questText]: { isLoading: false, error: t('suggestionError') } }));\r\n    }\r\n  };\r\n\r\n  const nextUnlockableSkills = getNextUnlockableSkills(stats.skills);\r\n\r\n  return (\r\n    <Dialog open={open} onOpenChange={onOpenChange}>\r\n      <DialogContent className=\"sm:max-w-[425px]\">\r\n        <DialogHeader>\r\n          <DialogTitle className=\"font-headline\">{t('playerStatus')}</DialogTitle>\r\n          <DialogDescription>\r\n            {t('playerStatusDesc')}\r\n          </DialogDescription>\r\n        </DialogHeader>\r\n        <Separator />\r\n        \r\n        <ScrollArea className=\"max-h-[70vh] pr-6\">\r\n          <div className=\"grid gap-4 py-4\">\r\n            <div className=\"space-y-2\">\r\n              <label htmlFor=\"hp\" className=\"text-sm font-medium\">{t('health', { hp: stats.hp })}</label>\r\n              <Progress id=\"hp\" value={stats.hp} className=\"h-4\" indicatorClassName=\"bg-destructive\" />\r\n            </div>\r\n            <div className=\"space-y-2\">\r\n              <label htmlFor=\"mana\" className=\"text-sm font-medium\">{t('mana', { mana })}</label>\r\n              <Progress id=\"mana\" value={(mana / 50) * 100} className=\"h-4\" indicatorClassName=\"bg-gradient-to-r from-blue-500 to-purple-600\" />\r\n            </div>\r\n            <div className=\"space-y-2\">\r\n              <label htmlFor=\"stamina\" className=\"text-sm font-medium\">{t('stamina', { stamina: stats.stamina.toFixed(0) })}</label>\r\n              <Progress id=\"stamina\" value={stats.stamina} className=\"h-4\" indicatorClassName=\"bg-gradient-to-r from-yellow-400 to-orange-500\" />\r\n            </div>\r\n             <div className=\"space-y-2\">\r\n              <label htmlFor=\"bodyTemp\" className=\"text-sm font-medium\">{t('bodyTemperature', { temp: bodyTemp.toFixed(1) })}</label>\r\n              <p className=\"text-xs text-muted-foreground px-1\">{t('bodyTempDesc')}</p>\r\n              <div className=\"relative h-4 w-full overflow-hidden rounded-full bg-gradient-to-r from-blue-400 via-green-400 to-red-600 mt-2\">\r\n                  <div \r\n                      className=\"absolute top-0 h-full w-1 bg-white/80 border-x border-black/50\" \r\n                      style={{ left: `${normalizeTemp(bodyTemp)}%` }}\r\n                      title={`Current: ${bodyTemp.toFixed(1)}┬░C`}\r\n                  />\r\n                  <div \r\n                      className=\"absolute top-0 h-full w-0.5 bg-white/50\" \r\n                      style={{ left: `${normalizeTemp(37)}%` }}\r\n                       title=\"Ideal: 37┬░C\"\r\n                  />\r\n              </div>\r\n            </div>\r\n          </div>\r\n          <Separator />\r\n            <div className=\"py-4\">\r\n                <h3 className=\"mb-2 font-headline font-semibold\">{t('equipment')}</h3>\r\n                <div className=\"space-y-2 text-sm bg-muted p-2 rounded-md\">\r\n                    {stats.equipment && Object.entries(stats.equipment).map(([slot, item]) => (\r\n                    <div key={slot} className=\"flex justify-between items-center\">\r\n                        <span className=\"capitalize text-muted-foreground\">{t(slot)}:</span>\r\n                        {item ? (\r\n                        <div className=\"flex items-center gap-2\">\r\n                            <span className=\"font-semibold text-foreground flex items-center gap-1\">\r\n                                <IconRenderer icon={resolveItemDef(getTranslatedText(item.name, 'en'), itemDefinitions)?.emoji || item.emoji} size={18} alt={getTranslatedText(item.name, language)} />\r\n                                {getTranslatedText(item.name, language, t)}\r\n                            </span>\r\n                            <Button variant=\"ghost\" size=\"sm\" onClick={() => onUnequipItem(slot as EquipmentSlot)}>\r\n                            {t('unequipItem')}\r\n                            </Button>\r\n                        </div>\r\n                        ) : (\r\n                        <span className=\"text-foreground italic\">{t('emptySlot')}</span>\r\n                        )}\r\n                    </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n          <Separator />\r\n          <div className=\"py-4\">\r\n            <h3 className=\"mb-2 font-headline font-semibold flex items-center gap-2\"><SwordIcon /> {t('combatStats')}</h3>\r\n            <div className=\"grid grid-cols-2 gap-x-4 gap-y-2 text-sm text-muted-foreground\">\r\n              <span>{t('physicalAttack')}:</span>\r\n              <span className=\"font-medium text-right text-foreground\">{stats.attributes.physicalAttack}</span>\r\n              \r\n              <span>{t('magicalAttack')}:</span>\r\n              <span className=\"font-medium text-right text-foreground\">{stats.attributes.magicalAttack}</span>\r\n\r\n              <span>{t('critChance')}:</span>\r\n              <span className=\"font-medium text-right text-foreground\">{stats.attributes.critChance}%</span>\r\n\r\n              <span>{t('attackSpeed')}:</span>\r\n              <span className=\"font-medium text-right text-foreground\">{stats.attributes.attackSpeed.toFixed(1)}</span>\r\n\r\n              <span>{t('cooldownReduction')}:</span>\r\n              <span className=\"font-medium text-right text-foreground\">{stats.attributes.cooldownReduction}%</span>\r\n            </div>\r\n          </div>\r\n          <Separator />\r\n          <div className=\"py-4\">\r\n            <h3 className=\"mb-2 font-headline font-semibold flex items-center gap-2\">\r\n              <Star className=\"h-4 w-4\" /> {t('skillUnlockProgressTitle')}\r\n            </h3>\r\n             <div className=\"p-2 bg-muted rounded-md text-sm\">\r\n                <div className=\"grid grid-cols-2 gap-x-4 gap-y-1\">\r\n                    <span className=\"text-muted-foreground\">{t('moves')}:</span>\r\n                    <span className=\"font-medium text-right text-foreground\">{stats.unlockProgress.moves ?? 0}</span>\r\n                    <span className=\"text-muted-foreground\">{t('kills')}:</span>\r\n                    <span className=\"font-medium text-right text-foreground\">{stats.unlockProgress.kills}</span>\r\n                    <span className=\"text-muted-foreground\">{t('damageSpells')}:</span>\r\n                    <span className=\"font-medium text-right text-foreground\">{stats.unlockProgress.damageSpells}</span>\r\n                </div>\r\n                {nextUnlockableSkills.length > 0 && (\r\n                    <>\r\n                        <Separator className=\"my-2\" />\r\n                        <div className=\"space-y-1\">\r\n              {nextUnlockableSkills.map(skill => (\r\n                <div key={String(skill.name)}>\r\n                  <p className=\"text-xs text-accent-foreground font-semibold\">{t(skill.name)}</p>\r\n                  <p className=\"text-xs text-muted-foreground\">({t('unlockCondition')}: {skill.unlockCondition!.count} {t(skill.unlockCondition!.type)})</p>\r\n                </div>\r\n              ))}\r\n                        </div>\r\n                    </>\r\n                )}\r\n            </div>\r\n          </div>\r\n          <Separator />\r\n          <div className=\"py-4\">\r\n            <h3 className=\"mb-2 font-headline font-semibold flex items-center gap-2\">\r\n              <Heart className=\"h-4 w-4\" /> {t('companions')}\r\n            </h3>\r\n            {pets.length > 0 ? (\r\n              <ul className=\"space-y-2\">\r\n                {pets.map((pet, index) => (\r\n                  <li key={`${pet.name}-${pet.type}-${index}`} className=\"p-2 bg-muted rounded-md text-muted-foreground\">\r\n                    <div className=\"font-semibold text-foreground\">{pet.name || t(pet.type)}</div>\r\n                    <div className=\"text-xs\">{t('levelLabel')} {pet.level} {t(pet.type)}</div>\r\n                  </li>\r\n                ))}\r\n              </ul>\r\n            ) : (\r\n              <p className=\"text-center text-muted-foreground\">{t('noCompanions')}</p>\r\n            )}\r\n          </div>\r\n          <Separator />\r\n          <div className=\"py-4\">\r\n            <h3 className=\"mb-2 font-headline font-semibold\">{t('quests')}</h3>\r\n            {quests.length > 0 ? (\r\n              <Accordion type=\"single\" collapsible className=\"w-full space-y-2\">\r\n                {quests.map((quest, index) => {\r\n                  const questText = t(quest);\r\n                  const isLegendary = questText.startsWith('[Legendary]') || questText.startsWith('[Huyß╗ün thoß║íi]');\r\n                  return (\r\n                    <AccordionItem value={`item-${index}`} key={index} className=\"p-2 bg-muted rounded-md border-none\">\r\n                      <AccordionTrigger onClick={() => handleQuestClick(questText)} className=\"py-0 text-left hover:no-underline text-muted-foreground\">\r\n                        <div className=\"flex items-center gap-2\">\r\n                          {isLegendary && <Sparkles className=\"h-4 w-4 text-yellow-400 flex-shrink-0\" />}\r\n                          <span className={cn(isLegendary && \"text-yellow-300/90\")}>{questText}</span>\r\n                        </div>\r\n                      </AccordionTrigger>\r\n                      <AccordionContent className=\"pt-2 text-accent-foreground italic\">\r\n                        {hintFetchStatus[questText]?.isLoading && (\r\n                          <div className=\"flex items-center gap-2\">\r\n                            <Loader2 className=\"h-4 w-4 animate-spin\"/>\r\n                            <span>{t('suggesting')}...</span>\r\n                          </div>\r\n                        )}\r\n                        {hintFetchStatus[questText]?.error && <p className=\"text-destructive\">{hintFetchStatus[questText]?.error}</p>}\r\n                        {stats.questHints?.[questText] && <p>\"{stats.questHints[questText]}\"</p>}\r\n                      </AccordionContent>\r\n                    </AccordionItem>\r\n                  );\r\n                })}\r\n              </Accordion>\r\n            ) : (\r\n              <p className=\"text-center text-muted-foreground\">{t('noQuests')}</p>\r\n            )}\r\n          </div>\r\n          <Separator />\r\n          <div className=\"py-4\">\r\n            <h3 className=\"mb-2 font-headline font-semibold flex items-center gap-2\">\r\n              <Book className=\"h-4 w-4\" /> {t('journal')}\r\n            </h3>\r\n            {stats.journal && Object.keys(stats.journal).length > 0 ? (\r\n              <Accordion type=\"single\" collapsible className=\"w-full space-y-2\">\r\n                {Object.entries(stats.journal).reverse().map(([day, entry]) => (\r\n                  <AccordionItem value={`day-${day}`} key={day} className=\"p-2 bg-muted rounded-md border-none\">\r\n                    <AccordionTrigger className=\"py-0 text-left hover:no-underline text-muted-foreground\">\r\n                      {t('dayX', { day })}\r\n                    </AccordionTrigger>\r\n                      <AccordionContent className=\"pt-2 text-accent-foreground/90 italic whitespace-pre-line\">\r\n                      {String(entry)}\r\n                    </AccordionContent>\r\n                  </AccordionItem>\r\n                ))}\r\n              </Accordion>\r\n            ) : (\r\n              <p className=\"text-center text-muted-foreground\">{t('noJournalEntries')}</p>\r\n            )}\r\n          </div>\r\n        </ScrollArea>\r\n      </DialogContent>\r\n    </Dialog>\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\tutorial-popup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\game\\world-setup.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GeneratedItem' is defined but never used.","line":14,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Terrain' is defined but never used.","line":14,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":111,"column":65,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":70},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parseError' is defined but never used.","line":180,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":180,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n\"use client\";\r\n\r\nimport { useState, useEffect } from \"react\";\r\nimport { Button } from \"@/components/ui/button\";\r\nimport { Textarea } from \"@/components/ui/textarea\";\r\nimport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from \"@/components/ui/card\";\r\nimport { useToast } from \"@/hooks/use-toast\";\r\nimport { suggestKeywords } from \"@/ai/flows/suggest-keywords\";\r\nimport { Skeleton } from \"../ui/skeleton\";\r\nimport { Separator } from \"../ui/separator\";\r\nimport { useLanguage } from \"@/context/language-context\";\r\nimport type { Skill, PlayerItem, GeneratedItem, Terrain, WorldConcept } from \"@/lib/game/types\";\r\nimport { premadeWorlds } from \"@/lib/game/data/premade-worlds\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\nimport { SettingsPopup } from \"./settings-popup\";\r\nimport { Tooltip, TooltipProvider, TooltipTrigger, TooltipContent } from \"../ui/tooltip\";\r\nimport { Sparkles, ArrowRight, BrainCircuit, Loader2, Settings, ArrowLeft, ChevronLeft, ChevronRight, BookOpen, Map, WandSparkles, BaggageClaim, ListTodo } from \"./icons\";\r\nimport { ScrollArea } from \"../ui/scroll-area\";\r\nimport { cn, getTranslatedText, convertItemArrayToRecord } from \"@/lib/utils\";\r\nimport type { GenerateWorldSetupOutput } from \"@/ai/flows/generate-world-setup\";\r\nimport { resolveItemDef } from '@/lib/game/item-utils';\r\n\r\ninterface WorldSetupProps {\r\n    onWorldCreated: (worldSetupData: GenerateWorldSetupOutput) => void;\r\n}\r\n\r\ntype Selection = {\r\n    worldName: number;\r\n    initialNarrative: number;\r\n    startingBiome: number;\r\n    playerInventory: number;\r\n    initialQuests: number;\r\n    startingSkill: number;\r\n};\r\n\r\n// Component to render a selectable card in the new mix-and-match UI\r\nconst SelectionCard = ({\r\n  label,\r\n  icon,\r\n  options,\r\n  selectedIndex,\r\n  onSelect,\r\n  renderOption,\r\n  className = ''\r\n}: {\r\n  label: string;\r\n  icon: React.ReactNode;\r\n  options: any[];\r\n  selectedIndex: number;\r\n  onSelect: (index: number) => void;\r\n  renderOption: (option: any) => React.ReactNode;\r\n  className?: string;\r\n}) => (\r\n  <Card className={cn(\"flex flex-col\", className)}>\r\n    <CardHeader className=\"flex flex-row items-center justify-between pb-2\">\r\n      <CardTitle className=\"text-sm font-medium flex items-center gap-2\">{icon} {label}</CardTitle>\r\n      <div className=\"flex items-center gap-1\">\r\n        <Button variant=\"ghost\" size=\"icon\" className=\"h-6 w-6\" onClick={() => onSelect((selectedIndex - 1 + options.length) % options.length)}>\r\n          <ChevronLeft className=\"h-4 w-4\" />\r\n        </Button>\r\n        <span className=\"text-xs text-muted-foreground tabular-nums\">{selectedIndex + 1}/{options.length}</span>\r\n        <Button variant=\"ghost\" size=\"icon\" className=\"h-6 w-6\" onClick={() => onSelect((selectedIndex + 1) % options.length)}>\r\n          <ChevronRight className=\"h-4 w-4\" />\r\n        </Button>\r\n      </div>\r\n    </CardHeader>\r\n    <CardContent className=\"flex-grow flex items-center justify-center text-center p-4 pt-0 min-h-[90px]\">\r\n      {renderOption(options[selectedIndex])}\r\n    </CardContent>\r\n  </Card>\r\n);\r\n\r\n\r\nexport function WorldSetup({ onWorldCreated }: WorldSetupProps): JSX.Element {\r\n    const { t, language } = useLanguage();\r\n    \r\n    const [step, setStep] = useState(0);\r\n    const [userInput, setUserInput] = useState(\"\");\r\n    const [isSuggesting, setIsSuggesting] = useState(false);\r\n    const [suggestedKeywords, setSuggestedKeywords] = useState<string[]>([]);\r\n    const [examplePrompts, setExamplePrompts] = useState<{text: string; keyword: string | null}[]>([]);\r\n    const [worldDescription, setWorldDescription] = useState(\"\");\r\n    \r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [generatedData, setGeneratedData] = useState<GenerateWorldSetupOutput | null>(null);\r\n    const [isPremade, setIsPremade] = useState(false);\r\n    \r\n    const [selection, setSelection] = useState<Selection>({\r\n        worldName: 0,\r\n        initialNarrative: 0,\r\n        startingBiome: 0,\r\n        playerInventory: 0,\r\n        initialQuests: 0,\r\n        startingSkill: 0,\r\n    });\r\n    \r\n    const [isSettingsOpen, setSettingsOpen] = useState(false);\r\n\r\n    const { toast } = useToast();\r\n\r\n    useEffect(() => {\r\n        const allExampleKeys: TranslationKey[] = [\r\n            'example1', 'example2', 'example3', 'example4', 'example5', \r\n            'example6', 'example7', 'example8', 'example9', 'example10',\r\n            'example11', 'example12'\r\n        ];\r\n    \r\n        const shuffled = [...allExampleKeys].sort(() => 0.5 - Math.random());\r\n        const selectedExamples = shuffled.slice(0, 6).map((key, index) => {\r\n            const text = t(key);\r\n            const match = text.match(/\\(Thß╗¡: '([^']+)'\\)|\\(Try: '([^']+)'\\)/);\r\n            const keyword = match ? (match[1] || match[2]) : null;\r\n            return {\r\n                text: text.replace(/\\s\\(Thß╗¡: '([^']+)'\\)|\\s\\(Try: '([^']+)'\\)/, ''),\r\n                keyword: keyword\r\n            };\r\n        });\r\n        setExamplePrompts(selectedExamples);\r\n\r\n        const descriptionKeys: TranslationKey[] = [\r\n            'worldSetupDesc1',\r\n            'worldSetupDesc2',\r\n            'worldSetupDesc3',\r\n            'worldSetupDesc4',\r\n        ];\r\n        const randomKey = descriptionKeys[Math.floor(Math.random() * descriptionKeys.length)];\r\n        setWorldDescription(t(randomKey));\r\n\r\n    }, [t]);\r\n\r\n    const handleSuggest = async () => {\r\n        if (!userInput.trim()) return;\r\n        setIsSuggesting(true);\r\n        try {\r\n            const result = await suggestKeywords({ userInput, language });\r\n            setSuggestedKeywords(result.keywords);\r\n        } catch (error) {\r\n            console.error(\"Failed to suggest keywords:\", error);\r\n            toast({ title: t('error'), description: t('suggestionError'), variant: \"destructive\" });\r\n        } finally {\r\n            setIsSuggesting(false);\r\n        }\r\n    };\r\n\r\n    const handleGenerate = async () => {\r\n        if (!userInput.trim()) {\r\n            toast({ title: t('noIdeaError'), description: t('noIdeaErrorDesc'), variant: \"destructive\" });\r\n            return;\r\n        }\r\n\r\n        const lowerInput = userInput.trim().toLowerCase();\r\n        \r\n        setIsLoading(true);\r\n        setGeneratedData(null);\r\n        setStep(1);\r\n\r\n        if (premadeWorlds[lowerInput]) {\r\n            setGeneratedData(premadeWorlds[lowerInput]);\r\n            setIsPremade(true);\r\n            setIsLoading(false);\r\n            return;\r\n        }\r\n        \r\n        setIsPremade(false);\r\n\r\n        try {\r\n            const response = await fetch('/api/generate-world', {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({ userInput, language }),\r\n            });\r\n\r\n            let data;\r\n            try {\r\n                data = await response.json();\r\n            } catch (parseError) {\r\n                if (!response.ok) {\r\n                    throw new Error(`Server error (${response.status}): ${response.statusText}`);\r\n                }\r\n                throw new Error('Invalid response from server');\r\n            }\r\n\r\n            if (!response.ok) {\r\n                if (data.error) {\r\n                    throw new Error(`${data.error}${data.details ? `: ${data.details}` : ''}`);\r\n                }\r\n                throw new Error('Failed to generate world');\r\n            }\r\n            \r\n            setGeneratedData(data);\r\n        } catch (error) {\r\n            console.error(\"Failed to generate world:\", error);\r\n            toast({ title: t('worldGenError'), description: String(error), variant: \"destructive\" });\r\n            setStep(0);\r\n        } finally {\r\n            setIsLoading(false);\r\n        }\r\n    };\r\n\r\n    const handleStartGame = () => {\r\n        if (!generatedData) return;\r\n        \r\n        const finalConcept: WorldConcept = {\r\n            worldName: generatedData.concepts[selection.worldName].worldName,\r\n            initialNarrative: generatedData.concepts[selection.initialNarrative].initialNarrative,\r\n            startingBiome: generatedData.concepts[selection.startingBiome].startingBiome,\r\n            playerInventory: generatedData.concepts[selection.playerInventory].playerInventory.map(item => {\r\n                const itemName = typeof item.name === 'object' && 'en' in item.name ? item.name[language] : item.name;\r\n                const itemDef = resolveItemDef(typeof itemName === 'string' ? itemName : itemName.key, convertItemArrayToRecord(generatedData.customItemCatalog));\r\n                return {\r\n                    name: itemName,\r\n                    quantity: item.quantity,\r\n                    tier: 1,\r\n                    emoji: itemDef?.emoji || '≡ƒôª'\r\n                };\r\n            }),\r\n            initialQuests: generatedData.concepts[selection.initialQuests].initialQuests,\r\n            startingSkill: generatedData.concepts[selection.startingSkill].startingSkill,\r\n            customStructures: generatedData.customStructures, // Shared across concepts\r\n        };\r\n        \r\n        const finalOutput: GenerateWorldSetupOutput = {\r\n            customItemCatalog: generatedData.customItemCatalog,\r\n            customStructures: generatedData.customStructures,\r\n            concepts: [finalConcept as any],\r\n        };\r\n\r\n        onWorldCreated(finalOutput);\r\n    };\r\n    \r\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLTextAreaElement>) => {\r\n        if (e.key === 'Enter' && !e.shiftKey) {\r\n          e.preventDefault();\r\n          handleGenerate();\r\n        }\r\n    };\r\n    \r\n    const handleExampleClick = (prompt: {text: string, keyword: string | null}) => {\r\n        setUserInput(prompt.keyword || prompt.text);\r\n    };\r\n\r\n    const renderStep0 = () => (\r\n        <>\r\n            <CardHeader>\r\n                <CardTitle className=\"font-headline text-3xl flex items-center gap-3\"><Sparkles /> {t('worldSetupTitle')}</CardTitle>\r\n                <CardDescription>{worldDescription}</CardDescription>\r\n            </CardHeader>\r\n            <CardContent className=\"space-y-6\">\r\n                <Textarea\r\n                    placeholder={t('worldSetupPlaceholder')}\r\n                    value={userInput}\r\n                    onChange={(e) => setUserInput(e.target.value)}\r\n                    onKeyDown={handleKeyDown}\r\n                    rows={4}\r\n                    className=\"text-base\"\r\n                />\r\n                <div className=\"space-y-2\">\r\n                    <Button onClick={handleSuggest} disabled={isSuggesting || !userInput.trim()} variant=\"outline\" type=\"button\">\r\n                        {isSuggesting ? <Loader2 className=\"animate-spin mr-2\" /> : <BrainCircuit className=\"mr-2\"/>}\r\n                        {isSuggesting ? t('suggesting') : t('suggestKeywords')}\r\n                    </Button>\r\n                    {suggestedKeywords.length > 0 && (\r\n                        <div className=\"flex flex-wrap gap-2 pt-2\">\r\n                            {suggestedKeywords.map((keyword, i) => (\r\n                                <button\r\n                                    key={i}\r\n                                    type=\"button\"\r\n                                    onClick={() => setUserInput(prev => `${prev} ${keyword}`)}\r\n                                    className=\"px-3 py-1 rounded-full bg-accent/20 text-accent-foreground text-sm hover:bg-accent/40 transition-colors\"\r\n                                >\r\n                                    + {keyword}\r\n                                </button>\r\n                            ))}\r\n                        </div>\r\n                    )}\r\n                </div>\r\n                 <Separator />\r\n                <div className=\"text-sm text-muted-foreground\">\r\n                    <h4 className=\"font-semibold mb-2\">{t('tryTheseIdeas')}</h4>\r\n                    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-2\">\r\n                        {examplePrompts.map((prompt, index) => (\r\n                            <button\r\n                                key={`${prompt.text}-${index}`}\r\n                                type=\"button\"\r\n                                onClick={() => handleExampleClick(prompt)}\r\n                                className=\"text-left p-2 rounded-md hover:bg-muted transition-colors text-accent text-sm flex items-center gap-2\"\r\n                            >\r\n                                &raquo; {prompt.text} {prompt.keyword && <span title=\"Pre-made World\">Γ¡É</span>}\r\n                            </button>\r\n                        ))}\r\n                    </div>\r\n                </div>\r\n            </CardContent>\r\n            <CardFooter className=\"flex justify-end gap-2\">\r\n                <Button onClick={handleGenerate} type=\"button\">\r\n                    {t('generateWorlds')} <ArrowRight className=\"ml-2\"/>\r\n                </Button>\r\n            </CardFooter>\r\n        </>\r\n    );\r\n\r\n    const renderStep1 = () => (\r\n        <>\r\n            <CardHeader>\r\n                 <CardTitle className=\"font-headline text-3xl flex items-center gap-3\"><Sparkles /> {t('worldGenResultTitle')}</CardTitle>\r\n                 <CardDescription>{isPremade ? t('premadeWorldSelectDesc') : t('worldGenResultDesc')}</CardDescription>\r\n            </CardHeader>\r\n            <CardContent>\r\n                {isLoading ? (\r\n                    <div className=\"space-y-4 py-10\">\r\n                        <div className=\"text-center\">\r\n                          <Loader2 className=\"h-12 w-12 animate-spin text-primary mx-auto\" />\r\n                          <p className=\"mt-4 text-muted-foreground\">{t('generatingUniverses')}</p>\r\n                        </div>\r\n                        <Skeleton className=\"h-20 w-full\" />\r\n                        <Skeleton className=\"h-20 w-full\" />\r\n                        <Skeleton className=\"h-20 w-full\" />\r\n                    </div>\r\n                ) : (\r\n                    generatedData && (\r\n                      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\r\n                        <div className=\"lg:col-span-2\">\r\n                            <SelectionCard\r\n                                label={t('worldName')}\r\n                                icon={<Sparkles />}\r\n                                options={generatedData.concepts.map(c => ({\r\n                                    ...c,\r\n                                    playerInventory: c.playerInventory.map(item => ({\r\n                                        ...item,\r\n                                        tier: 1,\r\n                                        emoji: '≡ƒôª'\r\n                                    }))\r\n                                })).map(c => c.worldName)}\r\n                                selectedIndex={selection.worldName}\r\n                                onSelect={(index) => setSelection(s => ({...s, worldName: index}))}\r\n                                renderOption={(option) => <p className=\"text-xl font-bold font-headline\">{getTranslatedText(option, language, t)}</p>}\r\n                            />\r\n                        </div>\r\n                        <SelectionCard\r\n                            label={t('openingNarrative')}\r\n                            icon={<BookOpen />}\r\n                            options={generatedData.concepts.map(c => ({\r\n                                ...c,\r\n                                playerInventory: c.playerInventory.map(item => ({\r\n                                    ...item,\r\n                                    tier: 1,\r\n                                    emoji: '≡ƒôª'\r\n                                }))\r\n                            })).map(c => c.initialNarrative)}\r\n                            selectedIndex={selection.initialNarrative}\r\n                            onSelect={(index) => setSelection(s => ({...s, initialNarrative: index}))}\r\n                            renderOption={(option) => <ScrollArea className=\"h-24\"><p className=\"text-sm italic text-muted-foreground\">{getTranslatedText(option, language, t)}</p></ScrollArea>}\r\n                        />\r\n                        <SelectionCard\r\n                            label={t('startingBiome')}\r\n                            icon={<Map />}\r\n                            options={generatedData.concepts.map(c => ({\r\n                                ...c,\r\n                                playerInventory: c.playerInventory.map(item => ({\r\n                                    ...item,\r\n                                    tier: 1,\r\n                                    emoji: '≡ƒôª'\r\n                                }))\r\n                            })).map(c => c.startingBiome)}\r\n                            selectedIndex={selection.startingBiome}\r\n                            onSelect={(index) => setSelection(s => ({...s, startingBiome: index}))}\r\n                            renderOption={(option) => <p className=\"font-semibold text-lg\">{t(option)}</p>}\r\n                        />\r\n                         <SelectionCard\r\n                            label={t('startingSkill')}\r\n                            icon={<WandSparkles />}\r\n                            options={generatedData.concepts.map(c => ({\r\n                                ...c,\r\n                                playerInventory: c.playerInventory.map(item => ({\r\n                                    ...item,\r\n                                    tier: 1,\r\n                                    emoji: '≡ƒôª'\r\n                                }))\r\n                            })).map(c => c.startingSkill)}\r\n                            selectedIndex={selection.startingSkill}\r\n                            onSelect={(index) => setSelection(s => ({...s, startingSkill: index}))}\r\n                            renderOption={(option: Skill) => \r\n                                <div>\r\n                                    <p className=\"font-semibold\">{getTranslatedText(option.name, language, t)}</p>\r\n                                    <p className=\"text-xs text-muted-foreground\">{getTranslatedText(option.description, language, t)}</p>\r\n                                </div>\r\n                            }\r\n                        />\r\n                         <SelectionCard\r\n                            label={t('startingEquipment')}\r\n                            icon={<BaggageClaim />}\r\n                            options={generatedData.concepts.map(c => ({\r\n                                ...c,\r\n                                playerInventory: c.playerInventory.map(item => ({\r\n                                    ...item,\r\n                                    tier: 1,\r\n                                    emoji: '≡ƒôª'\r\n                                }))\r\n                            })).map(c => c.playerInventory)}\r\n                            selectedIndex={selection.playerInventory}\r\n                            onSelect={(index) => setSelection(s => ({...s, playerInventory: index}))}\r\n                            renderOption={(option) => \r\n                                <div className=\"flex flex-wrap gap-x-4 gap-y-2 justify-center text-sm\">\r\n                                    {(option as PlayerItem[]).map((item: PlayerItem, i: number) => {\r\n                                        const allItems = [...(premadeWorlds[userInput.toLowerCase()]?.customItemCatalog || []), ...(generatedData?.customItemCatalog || [])];\r\n                                        const def = allItems.find(d => getTranslatedText(d.name, 'en') === getTranslatedText(item.name, 'en'));\r\n                                        const emoji = def?.emoji || '≡ƒôª';\r\n                                        return <span key={i} className=\"flex items-center gap-1\">{typeof emoji === 'string' ? emoji : '≡ƒôª'} {getTranslatedText(item.name, language, t)} x{item.quantity}</span>\r\n                                    })}\r\n                                </div>\r\n                            }\r\n                        />\r\n                        <div className=\"lg:col-span-2\">\r\n                          <SelectionCard\r\n                              label={t('firstQuest')}\r\n                              icon={<ListTodo />}\r\n                              options={generatedData.concepts.map(c => ({\r\n                                  ...c,\r\n                                  playerInventory: c.playerInventory.map(item => ({\r\n                                      ...item,\r\n                                      tier: 1,\r\n                                      emoji: '≡ƒôª'\r\n                                  }))\r\n                              })).map(c => c.initialQuests)}\r\n                              selectedIndex={selection.initialQuests}\r\n                              onSelect={(index) => setSelection(s => ({...s, initialQuests: index}))}\r\n                              renderOption={(option: string[]) => \r\n                                  <ul className=\"space-y-1 text-sm text-muted-foreground list-disc list-inside\">\r\n                                      {option.map((q, i) => <li key={i}>{getTranslatedText(q, language, t)}</li>)}\r\n                                  </ul>\r\n                              }\r\n                          />\r\n                        </div>\r\n                      </div>\r\n                    )\r\n                )}\r\n            </CardContent>\r\n            <CardFooter className=\"flex flex-col-reverse sm:flex-row sm:justify-between gap-2 pt-6\">\r\n                <Button variant=\"ghost\" onClick={() => { setStep(0); setGeneratedData(null); }} type=\"button\">\r\n                    <ArrowLeft className=\"mr-2\"/> {t('backAndEdit')}\r\n                </Button>\r\n                <Button onClick={handleStartGame} disabled={isLoading || !generatedData} type=\"button\" size=\"lg\">\r\n                    {t('startAdventure')} <ArrowRight className=\"ml-2\"/>\r\n                </Button>\r\n            </CardFooter>\r\n        </>\r\n    )\r\n\r\n    return (\r\n        <TooltipProvider>\r\n            <div className=\"flex items-center justify-center min-h-dvh bg-background text-foreground p-4 md:p-8 font-body\">\r\n                <Card className=\"w-full max-w-5xl shadow-2xl animate-in fade-in duration-500 relative\">\r\n                     <div className=\"absolute top-4 right-4 z-10\">\r\n                        <Tooltip>\r\n                            <TooltipTrigger asChild>\r\n                                <Button onClick={() => setSettingsOpen(true)} variant=\"ghost\" size=\"icon\" type=\"button\">\r\n                                    <Settings className=\"h-5 w-5\" />\r\n                                </Button>\r\n                            </TooltipTrigger>\r\n                            <TooltipContent>\r\n                                <p>{t('gameSettings')}</p>\r\n                            </TooltipContent>\r\n                        </Tooltip>\r\n                    </div>\r\n                    {step === 0 ? renderStep0() : renderStep1()}\r\n                </Card>\r\n                <SettingsPopup open={isSettingsOpen} onOpenChange={setSettingsOpen} isInGame={false} />\r\n            </div>\r\n        </TooltipProvider>\r\n    );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\accordion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\alert-dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\alert.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\animated-icon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\area-fill-image.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\area-fill.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\audio-controls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\calendar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\carousel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\collapsible.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\form.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\icon-renderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\menubar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\scroll-area.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\separator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\sheet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\table.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\toast.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\toaster.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\components\\ui\\tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\context\\auth-context.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Loader2' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":39,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';\r\n// Note: firebase is dynamically imported at runtime to avoid inflating the client bundle\r\n// when Firebase is not configured or when auth features are not used.\r\nimport { Loader2 } from 'lucide-react';\r\n\r\ninterface AuthContextType {\r\n  user: any | null;\r\n  loading: boolean;\r\n  login: () => Promise<void>;\r\n  logout: () => Promise<void>;\r\n  isFirebaseConfigured: boolean;\r\n}\r\n\r\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\r\n\r\nexport const AuthProvider = ({ children }: { children: ReactNode }) => {\r\n  const [user, setUser] = useState<any | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [isFirebaseConfigured, setIsFirebaseConfigured] = useState(false);\r\n\r\n  useEffect(() => {\r\n    let unsub: (() => void) | undefined;\r\n    const init = async () => {\r\n      try {\r\n        const fc = await import('@/lib/firebase-config');\r\n        if (!fc || !fc.auth) {\r\n          setIsFirebaseConfigured(false);\r\n          setLoading(false);\r\n          return;\r\n        }\r\n        setIsFirebaseConfigured(true);\r\n        const { onAuthStateChanged } = await import('firebase/auth');\r\n        unsub = onAuthStateChanged(fc.auth as any, (u: any) => {\r\n          setUser(u);\r\n          setLoading(false);\r\n        });\r\n      } catch (e) {\r\n        // If anything fails, treat as not configured\r\n        setLoading(false);\r\n      }\r\n    };\r\n    init();\r\n    return () => {\r\n      try { if (typeof unsub === 'function') unsub(); } catch {};\r\n    };\r\n  }, []);\r\n\r\n  const login = async () => {\r\n    try {\r\n      const fc = await import('@/lib/firebase-config');\r\n      if (!fc || !fc.auth || !fc.googleProvider) {\r\n        console.error('Firebase is not configured. Cannot log in.');\r\n        return;\r\n      }\r\n      const { signInWithPopup } = await import('firebase/auth');\r\n      await signInWithPopup(fc.auth as any, fc.googleProvider as any);\r\n    } catch (error) {\r\n      console.error('Error during sign-in:', error);\r\n    }\r\n  };\r\n\r\n  const logout = async () => {\r\n    try {\r\n      const fc = await import('@/lib/firebase-config');\r\n      if (!fc || !fc.auth) {\r\n        console.error('Firebase is not configured. Cannot log out.');\r\n        return;\r\n      }\r\n      const { signOut } = await import('firebase/auth');\r\n      await signOut(fc.auth as any);\r\n    } catch (error) {\r\n      console.error('Error during sign-out:', error);\r\n    }\r\n  };\r\n\r\n  return (\r\n    <AuthContext.Provider value={{ user, loading, login, logout, isFirebaseConfigured }}>\r\n      {children}\r\n    </AuthContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useAuth = () => {\r\n  const context = useContext(AuthContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAuth must be used within an AuthProvider');\r\n  }\r\n  return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\context\\language-context.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'logger' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":62,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":65,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n'use client';\r\n\r\nimport React, { createContext, useState, useContext, ReactNode, useEffect } from 'react';\r\nimport { translations, Language, TranslationKey } from '@/lib/i18n';\r\nimport type { TranslatableString } from '@/lib/game/types';\r\nimport { logger } from '@/lib/logger';\r\n\r\n// A type for our t function to handle replacements\r\ntype TFunction = (key: TranslationKey | TranslatableString, replacements?: { [key: string]: string | number }) => string;\r\n\r\ninterface LanguageContextType {\r\n  language: Language;\r\n  // Optionally accept a currentBiome so the purge can preserve bundles for the current biome.\r\n  setLanguage: (language: Language, currentBiome?: string) => void;\r\n  t: TFunction;\r\n}\r\n\r\nconst LanguageContext = createContext<LanguageContextType | undefined>(undefined);\r\n\r\nexport const LanguageProvider = ({ children }: { children: ReactNode }) => {\r\n  // Default to 'en' on server, will be corrected by useEffect on client.\r\n  // This prevents hydration mismatches.\r\n  const [language, setLanguageState] = useState<Language>('en');\r\n\r\n  useEffect(() => {\r\n    // On mount, check localStorage for a saved language preference.\r\n    const savedLanguage = localStorage.getItem('gameLanguage') as Language;\r\n    if (savedLanguage && (savedLanguage === 'en' || savedLanguage === 'vi')) {\r\n      setLanguageState(savedLanguage);\r\n    }\r\n  }, []);\r\n\r\n  const setLanguage = (lang: Language, currentBiome?: string) => {\r\n    localStorage.setItem('gameLanguage', lang);\r\n    setLanguageState(lang);\r\n\r\n    // Lazy-clear precomputed bundles for other locales to free cache and avoid keeping\r\n    // unused language bundles in memory. We'll perform this asynchronously so it\r\n    // doesn't block rendering. Also attempt to prefetch a small 'default' bundle\r\n    // for the newly selected language.\r\n    (async () => {\r\n      try {\r\n        // lazy-require to avoid adding IndexedDB code to server bundles\r\n         \r\n        const cache = require('@/lib/narrative/cache').default as { keys: () => Promise<string[]>; del: (k: string) => Promise<boolean> };\r\n        const loader = require('@/lib/narrative/loader') as any;\r\n        const keys = await cache.keys();\r\n        for (const k of keys) {\r\n          // our cache keys are in the shape 'nl_precomputed_v1:biome:locale'\r\n          const parts = k.split(':');\r\n          const localePart = parts[parts.length - 1];\r\n          const biomePart = parts.length >= 3 ? parts[parts.length - 2] : undefined;\r\n          // Delete if the key is for a different locale AND not for the current biome (if provided).\r\n          if (localePart && localePart !== lang && biomePart !== currentBiome) {\r\n            await cache.del(k);\r\n          }\r\n        }\r\n        // warm a default bundle for the language; non-blocking\r\n        try {\r\n          loader.loadPrecomputedBundle('default', lang).catch(() => {});\r\n        } catch (_e) {\r\n          // ignore\r\n        }\r\n      } catch (_e) {\r\n        // ignore any cache errors\r\n      }\r\n    })();\r\n  };\r\n  \r\n  const t: TFunction = (key, replacements) => {\r\n    // If key is an object-shaped TranslatableString, return the matching language variant.\r\n    if (typeof key !== 'string') {\r\n      if (key && typeof key === 'object' && 'en' in key && 'vi' in key) {\r\n        return (key as any)[language] || (key as any)['en'] || '';\r\n      }\r\n      // Unknown object shape -> coerce to string to satisfy callers that expect a string\r\n      return String(key);\r\n    }\r\n\r\n    // At this point TS knows `key` is a string (TranslationKey)\r\n    const k = key as TranslationKey;\r\n    const primaryTranslation = (translations[language] as any)[k];\r\n    const fallbackTranslation = (translations.en as any)[k];\r\n    const translationPool = primaryTranslation || fallbackTranslation;\r\n\r\n    if (process.env.NODE_ENV === 'development') {\r\n      if (!translationPool || translationPool === k) {\r\n        console.warn(`[TRANSLATION_DEBUG] Key not found in any language: '${k}'`);\r\n      }\r\n    }\r\n\r\n    let translation: string = '';\r\n    if (Array.isArray(translationPool)) {\r\n      translation = translationPool[Math.floor(Math.random() * translationPool.length)];\r\n    } else if (typeof translationPool === 'string') {\r\n      translation = translationPool;\r\n    } else if (translationPool && typeof translationPool === 'object' && replacements && replacements.subKey) {\r\n      translation = (translationPool as any)[replacements.subKey] || '';\r\n    } else {\r\n      translation = k;\r\n    }\r\n\r\n    if (replacements) {\r\n      Object.entries(replacements).forEach(([replaceKey, value]) => {\r\n        translation = translation.replace(`{${replaceKey}}`, String(value));\r\n      });\r\n    }\r\n\r\n    return translation;\r\n  };\r\n\r\n  return (\r\n    <LanguageContext.Provider value={{ language, setLanguage, t }}>\r\n      {children}\r\n    </LanguageContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useLanguage = () => {\r\n  const context = useContext(LanguageContext);\r\n  if (context === undefined) {\r\n    throw new Error('useLanguage must be used within a LanguageProvider');\r\n  }\r\n  return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\context\\pwa-install-context.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\context\\settings-context.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_mods' is assigned a value but never used.","line":115,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport React, { createContext, useState, useContext, ReactNode, useEffect, useCallback } from 'react';\r\nimport type { GameSettings, FontFamily, FontSize, Theme, ModBundle } from '@/lib/game/types';\r\n\r\ninterface SettingsContextType {\r\n  settings: GameSettings;\r\n  setSettings: (settings: Partial<GameSettings>) => void;\r\n  applyMods: (modCode: string) => void;\r\n  clearMods: () => void;\r\n}\r\n\r\nconst SettingsContext = createContext<SettingsContextType | undefined>(undefined);\r\n\r\nconst defaultSettings = {\r\n  gameMode: 'ai',\r\n  diceType: 'd20',\r\n  aiModel: 'balanced',\r\n  narrativeLength: 'medium',\r\n  fontFamily: 'literata',\r\n  fontSize: 'base',\r\n  theme: 'dark',\r\n  mods: null,\r\n  controlsPreventScroll: true,\r\n  useLegacyLayout: false,\r\n  startTime: 360, // 6 AM\r\n  dayDuration: 1440, // 24 hours\r\n  timePerTurn: 5, // 5 minutes per turn\r\n  keyBindings: {\r\n    moveUp: ['w', 'ArrowUp'],\r\n    moveDown: ['s', 'ArrowDown'],\r\n    moveLeft: ['a', 'ArrowLeft'],\r\n    moveRight: ['d', 'ArrowRight'],\r\n    attack: [' '],\r\n    openInventory: ['e'],\r\n    openStatus: ['p'],\r\n    openMap: ['m'],\r\n    customAction: ['/'],\r\n    pickUp: ['Tab'],\r\n    hot1: ['1'],\r\n    hot2: ['2'],\r\n    hot3: ['3'],\r\n    hot4: ['4'],\r\n    hot5: ['5']\r\n  }\r\n} as GameSettings;\r\n\r\nexport const SettingsProvider = ({ children }: { children: ReactNode }) => {\r\n  const [settings, setSettingsState] = useState<GameSettings>(defaultSettings);\r\n\r\n  useEffect(() => {\r\n    try {\r\n      const savedSettings = localStorage.getItem('gameSettings');\r\n      if (savedSettings) {\r\n        const parsed = JSON.parse(savedSettings);\r\n\r\n        // --- VALIDATION START ---\r\n        const validThemes: Theme[] = ['light', 'dark'];\r\n        if (!validThemes.includes(parsed.theme)) parsed.theme = defaultSettings.theme;\r\n        \r\n        const validFonts: FontFamily[] = ['literata', 'inter', 'source_code_pro'];\r\n        if (!validFonts.includes(parsed.fontFamily)) parsed.fontFamily = defaultSettings.fontFamily;\r\n        \r\n        const validFontSizes: FontSize[] = ['sm', 'base', 'lg'];\r\n        if (!validFontSizes.includes(parsed.fontSize)) parsed.fontSize = defaultSettings.fontSize;\r\n        \r\n  // Ensure time settings are numbers\r\n  if (typeof parsed.startTime !== 'number') parsed.startTime = (defaultSettings as any).startTime;\r\n  if (typeof parsed.dayDuration !== 'number') parsed.dayDuration = (defaultSettings as any).dayDuration;\r\n  if (typeof parsed.timePerTurn !== 'number') parsed.timePerTurn = (defaultSettings as any).timePerTurn;\r\n\r\n        // Also load mods from localStorage\r\n        const savedMods = localStorage.getItem('gameMods');\r\n        if (savedMods) {\r\n          try {\r\n            parsed.mods = JSON.parse(savedMods);\r\n          } catch {\r\n            parsed.mods = null;\r\n          }\r\n        }\r\n        // --- VALIDATION END ---\r\n  // Ensure controlsPreventScroll is a boolean (backwards compatibility)\r\n  if (typeof parsed.controlsPreventScroll !== 'boolean') parsed.controlsPreventScroll = defaultSettings.controlsPreventScroll;\r\n  // Ensure useLegacyLayout is a boolean (backwards compatibility)\r\n  if (typeof parsed.useLegacyLayout !== 'boolean') parsed.useLegacyLayout = defaultSettings.useLegacyLayout;\r\n\r\n        // Validate keyBindings shape if present\r\n        if (parsed.keyBindings && typeof parsed.keyBindings === 'object') {\r\n          const kb = parsed.keyBindings;\r\n          const ensureList = (v: any) => (Array.isArray(v) ? v : (typeof v === 'string' ? [v] : undefined));\r\n          parsed.keyBindings = {\r\n            moveUp: ensureList(kb.moveUp) ?? (defaultSettings as any).keyBindings.moveUp,\r\n            moveDown: ensureList(kb.moveDown) ?? (defaultSettings as any).keyBindings.moveDown,\r\n            moveLeft: ensureList(kb.moveLeft) ?? (defaultSettings as any).keyBindings.moveLeft,\r\n            moveRight: ensureList(kb.moveRight) ?? (defaultSettings as any).keyBindings.moveRight,\r\n            attack: ensureList(kb.attack) ?? (defaultSettings as any).keyBindings.attack,\r\n            openInventory: ensureList(kb.openInventory) ?? (defaultSettings as any).keyBindings.openInventory,\r\n            openStatus: ensureList(kb.openStatus) ?? (defaultSettings as any).keyBindings.openStatus,\r\n            openMap: ensureList(kb.openMap) ?? (defaultSettings as any).keyBindings.openMap,\r\n            customAction: ensureList(kb.customAction) ?? (defaultSettings as any).keyBindings.customAction,\r\n          };\r\n        }\r\n\r\n  setSettingsState(_prev => ({...defaultSettings, ...parsed}));\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to load game settings from localStorage\", error);\r\n    }\r\n  }, []);\r\n\r\n  const setSettings = useCallback((newSettings: Partial<GameSettings>) => {\r\n    setSettingsState(prevSettings => {\r\n      const updatedSettings = { ...prevSettings, ...newSettings };\r\n      try {\r\n    const { mods: _mods, ...settingsToSave } = updatedSettings;\r\n        localStorage.setItem('gameSettings', JSON.stringify(settingsToSave));\r\n      } catch (error) {\r\n        console.error(\"Failed to save game settings to localStorage\", error);\r\n      }\r\n      return updatedSettings;\r\n    });\r\n  }, []);\r\n\r\n  const applyMods = useCallback((modCode: string) => {\r\n    try {\r\n        const parsedMods: ModBundle = JSON.parse(modCode);\r\n        // Basic validation\r\n        if (typeof parsedMods !== 'object' || !parsedMods.id) {\r\n            throw new Error(\"Invalid mod format: must be an object with an 'id' property.\");\r\n        }\r\n        localStorage.setItem('gameMods', modCode);\r\n        setSettings({ mods: parsedMods });\r\n    } catch (error) {\r\n        console.error(\"Failed to apply mods:\", error);\r\n        alert(`Error applying mods: ${error instanceof Error ? error.message : String(error)}`);\r\n    }\r\n  }, [setSettings]);\r\n\r\n  const clearMods = useCallback(() => {\r\n    localStorage.removeItem('gameMods');\r\n    setSettings({ mods: null });\r\n  }, [setSettings]);\r\n\r\n  // Effect to apply theme and font settings to the document\r\n  useEffect(() => {\r\n    if (typeof window !== 'undefined') {\r\n      const root = document.documentElement;\r\n      const body = document.body;\r\n\r\n      // Theme\r\n      root.classList.remove('light', 'dark');\r\n      root.classList.add(settings.theme);\r\n\r\n      // Font Family\r\n      body.classList.remove('font-literata', 'font-inter', 'font-source-code-pro');\r\n      body.classList.add(`font-${settings.fontFamily.replace(/_/g, '-')}`);\r\n\r\n      // Font Size\r\n      body.classList.remove('text-sm', 'text-base', 'text-lg');\r\n      body.classList.add(`text-${settings.fontSize}`);\r\n    }\r\n  }, [settings.theme, settings.fontFamily, settings.fontSize]);\r\n\r\n  return (\r\n    <SettingsContext.Provider value={{ settings, setSettings, applyMods, clearMods }}>\r\n      {children}\r\n    </SettingsContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useSettings = () => {\r\n  const context = useContext(SettingsContext);\r\n  if (context === undefined) {\r\n    throw new Error('useSettings must be used within a SettingsProvider');\r\n  }\r\n  return context;\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\engines\\creature-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":146,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":146,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":245,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":245,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'playerStats' is defined but never used. Allowed unused args must match /^_/u.","line":256,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":256,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Enemy, Chunk, PlayerStatusDefinition } from '@/lib/game/types';\r\nimport defaultGameConfig from '@/lib/config/game-config';\r\nimport { GridPosition } from '../values/grid-position';\r\n\r\n/**\r\n * Interface for creature state during simulation.\r\n * Extends Enemy with additional runtime properties.\r\n */\r\ninterface CreatureState extends Enemy {\r\n    /** Current position of the creature */\r\n    position: GridPosition;\r\n    /** Current chunk the creature is in */\r\n    currentChunk: Chunk;\r\n    /** Last time the creature moved (in game ticks) */\r\n    lastMoveTick: number;\r\n    /** Current target position for movement */\r\n    targetPosition?: GridPosition;\r\n    /** Current behavior state */\r\n    currentBehavior: 'idle' | 'moving' | 'hunting' | 'fleeing' | 'eating';\r\n}\r\n\r\n/**\r\n * Engine responsible for simulating creature behavior, movement, and AI.\r\n * Handles hunger mechanics, movement patterns, and behavior-based actions.\r\n */\r\nexport class CreatureEngine {\r\n    private creatures: Map<string, CreatureState> = new Map();\r\n\r\n    private config = defaultGameConfig;\r\n\r\n    constructor(private t: (key: string, params?: any) => string, config?: Partial<typeof defaultGameConfig>) {\r\n        if (config) {\r\n            this.config = {\r\n                ...this.config,\r\n                ...config,\r\n                plant: { ...this.config.plant, ...(config as any).plant },\r\n                creature: { ...this.config.creature, ...(config as any).creature }\r\n            } as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a creature in the simulation.\r\n     * @param creatureId Unique identifier for the creature\r\n     * @param creature The creature definition\r\n     * @param position Initial position\r\n     * @param chunk The chunk containing the creature\r\n     */\r\n    registerCreature(creatureId: string, creature: Enemy, position: GridPosition, chunk: Chunk): void {\r\n        const creatureState: CreatureState = {\r\n            ...creature,\r\n            position: new GridPosition(position.x, position.y),\r\n            currentChunk: chunk,\r\n            // lastMoveTick is measured in game ticks (not Date.now)\r\n            lastMoveTick: 0,\r\n            currentBehavior: 'idle'\r\n        };\r\n        this.creatures.set(creatureId, creatureState);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a creature from the simulation.\r\n     * @param creatureId Unique identifier for the creature\r\n     */\r\n    unregisterCreature(creatureId: string): void {\r\n        this.creatures.delete(creatureId);\r\n    }\r\n\r\n    /**\r\n     * Updates all registered creatures for the current game tick.\r\n     * @param currentTick Current game tick\r\n     * @param playerPosition Current player position\r\n     * @param playerStats Current player stats\r\n     * @param chunks Available chunks for movement\r\n     * @returns Array of narrative messages from creature actions\r\n     */\r\n    updateCreatures(\r\n        currentTick: number,\r\n        playerPosition: GridPosition,\r\n        playerStats: PlayerStatusDefinition,\r\n        chunks: Map<string, Chunk>\r\n    ): Array<{ text: string; type: 'narrative' | 'system' }> {\r\n        const messages: Array<{ text: string; type: 'narrative' | 'system' }> = [];\r\n\r\n        for (const [creatureId, creature] of this.creatures) {\r\n            const updateResult = this.updateCreature(creature, currentTick, playerPosition, playerStats, chunks);\r\n            if (updateResult.message) {\r\n                messages.push(updateResult.message);\r\n            }\r\n\r\n            // Update the creature state\r\n            this.creatures.set(creatureId, updateResult.creature);\r\n        }\r\n\r\n        return messages;\r\n    }\r\n\r\n    /**\r\n     * Updates a single creature for the current tick.\r\n     */\r\n    private updateCreature(\r\n        creature: CreatureState,\r\n        currentTick: number,\r\n        playerPosition: GridPosition,\r\n        playerStats: PlayerStatusDefinition,\r\n        chunks: Map<string, Chunk>\r\n    ): { creature: CreatureState; message?: { text: string; type: 'narrative' | 'system' } } {\r\n        const updatedCreature = { ...creature };\r\n        const messages: Array<{ text: string; type: 'narrative' | 'system' }> = [];\r\n\r\n        // Update hunger/satiation\r\n        const wasHungry = updatedCreature.satiation < updatedCreature.maxSatiation * 0.3;\r\n        this.updateHunger(updatedCreature, currentTick);\r\n        const isHungry = updatedCreature.satiation < updatedCreature.maxSatiation * 0.3;\r\n\r\n        // Generate hunger message if creature became hungry\r\n        if (!wasHungry && isHungry) {\r\n            const creatureName = (updatedCreature as any).name?.en || updatedCreature.type || 'creature';\r\n            messages.push({\r\n                text: this.t('creatureHungry', { creature: creatureName }),\r\n                type: 'narrative'\r\n            });\r\n        }\r\n\r\n    // Update behavior based on current state and surroundings\r\n    this.updateBehavior(updatedCreature, playerPosition, playerStats);\r\n\r\n        // If creature is hunting the player and is in melee range, perform an attack\r\n        try {\r\n            const searchRange = (updatedCreature as any).trophicRange ?? 2; // default 2 -> 5x5 area\r\n            const inSearchSquare = this.isWithinSquareRange(updatedCreature.position, playerPosition, searchRange);\r\n            const isAdjacent = this.isWithinSquareRange(updatedCreature.position, playerPosition, 1);\r\n\r\n            if (updatedCreature.currentBehavior === 'hunting' && inSearchSquare) {\r\n                // If creature is a carnivore (or aggressive predator) and is adjacent, attack the player\r\n                if ((updatedCreature.trophic === 'carnivore' || updatedCreature.behavior === 'aggressive') && isAdjacent) {\r\n                    // Apply damage to player\r\n                    const damage = updatedCreature.damage || 0;\r\n                    playerStats.hp = Math.max(0, (playerStats.hp || 0) - damage);\r\n\r\n                    const creatureName = (updatedCreature as any).name?.en || updatedCreature.type || 'creature';\r\n                    const attackText = `${creatureName} ${this.t('creatureHunting', { creature: creatureName })} and attacks you (-${damage} HP).`;\r\n                    messages.push({ text: attackText, type: 'narrative' });\r\n                }\r\n            }\r\n        } catch (err) {\r\n            // ignore attack errors\r\n        }\r\n\r\n        // Execute movement if needed\r\n        if (this.shouldMove(updatedCreature, currentTick)) {\r\n            const moveResult = this.executeMovement(updatedCreature, chunks, playerPosition, currentTick);\r\n            if (moveResult.message) {\r\n                messages.push(moveResult.message);\r\n            }\r\n        }\r\n\r\n        // After movement, if creature is hungry and allowed to eat plants, attempt to eat\r\n        try {\r\n            const eatResult = this.attemptEatPlants(updatedCreature);\r\n            if (eatResult && eatResult.message) {\r\n                messages.push(eatResult.message);\r\n            }\r\n        } catch (err) {\r\n            // swallow errors in optional behaviour\r\n            console.warn('CreatureEngine: eating attempt failed', err);\r\n        }\r\n\r\n        return { creature: updatedCreature, message: messages[0] };\r\n    }\r\n\r\n    /**\r\n     * Updates creature hunger and satiation levels.\r\n     */\r\n    private updateHunger(creature: CreatureState, currentTick: number): void {\r\n        // Hunger decay every 10 ticks\r\n\r\n        if (currentTick % this.config.creature.hungerDecayInterval === 0) {\r\n            creature.satiation = Math.max(0, creature.satiation - this.config.creature.hungerDecayPerTick);\r\n\r\n            // If very hungry, creature becomes more aggressive\r\n            if (creature.satiation < creature.maxSatiation * 0.2) {\r\n                if (creature.behavior === 'passive') {\r\n                    creature.behavior = 'territorial';\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if the creature is allowed to eat plants based on trophic tag or diet keywords.\r\n     */\r\n    private canEatPlants(creature: CreatureState): boolean {\r\n        if (creature.trophic === 'herbivore') return true;\r\n        if (creature.trophic === 'carnivore') return false;\r\n        if (creature.trophic === 'omnivore') return true;\r\n\r\n        // Fallback: look for plant-like keywords in diet\r\n        const plantKeywords = ['plant', 'berry', 'grass', 'herb', 'leaf'];\r\n        if (Array.isArray(creature.diet)) {\r\n            for (const d of creature.diet) {\r\n                if (!d) continue;\r\n                const lower = d.toString().toLowerCase();\r\n                if (plantKeywords.some(k => lower.includes(k))) return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Attempt to eat plants in the creature's current chunk. Returns narrative info when eating occurs.\r\n     */\r\n    private attemptEatPlants(creature: CreatureState): { eaten: boolean; message?: { text: string; type: 'narrative' | 'system' } } | null {\r\n        try {\r\n            if (!this.canEatPlants(creature)) return null;\r\n\r\n            // Only attempt eating when hungry\r\n            const hungry = creature.satiation < (creature.maxSatiation * 0.6);\r\n            if (!hungry) return null;\r\n\r\n            const chunk = creature.currentChunk;\r\n            if (!chunk || typeof chunk.vegetationDensity !== 'number') return null;\r\n\r\n            const veg = chunk.vegetationDensity;\r\n            if (veg <= 0) return null;\r\n\r\n            // Chance to eat\r\n            if (Math.random() > (this.config.plant.eatChance ?? 0.6)) return null;\r\n\r\n            const amount = Math.min(veg, this.config.plant.consumptionPerEat ?? 5);\r\n            if (amount <= 0) return null;\r\n\r\n            // Apply consumption\r\n            chunk.vegetationDensity = Math.max(0, veg - amount);\r\n\r\n            // Increase satiation based on plantNutrition per vegetation unit\r\n            const nutritionPerUnit = this.config.plant.plantNutrition ?? 0.5;\r\n            const satiationGain = amount * nutritionPerUnit;\r\n            creature.satiation = Math.min(creature.maxSatiation, creature.satiation + satiationGain);\r\n\r\n            const creatureName = (creature as any).name?.en || creature.type || 'creature';\r\n            const text = this.t('creatureEating', { creature: creatureName });\r\n            return { eaten: true, message: { text, type: 'narrative' } };\r\n        } catch (err) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates creature behavior based on current state and player proximity.\r\n     */\r\n    private updateBehavior(\r\n        creature: CreatureState,\r\n        playerPosition: GridPosition,\r\n        playerStats: PlayerStatusDefinition\r\n    ): void {\r\n        // Use per-creature search radius when available. Default to 2 tiles (5x5 area) for predators.\r\n        const searchRange = (creature as any).trophicRange ?? 2;\r\n        const inSquareRange = this.isWithinSquareRange(creature.position, playerPosition, searchRange);\r\n\r\n        switch (creature.behavior) {\r\n            case 'aggressive':\r\n                if (inSquareRange) {\r\n                    creature.currentBehavior = 'hunting';\r\n                    creature.targetPosition = new GridPosition(playerPosition.x, playerPosition.y);\r\n                } else if (creature.satiation < creature.maxSatiation * 0.5) {\r\n                    // If hungry, expand hunting scope (still prefer local player if in range)\r\n                    creature.currentBehavior = 'hunting';\r\n                    creature.targetPosition = new GridPosition(playerPosition.x, playerPosition.y);\r\n                } else {\r\n                    creature.currentBehavior = 'idle';\r\n                }\r\n                break;\r\n\r\n            case 'passive':\r\n                // Passive creatures try to flee if the player gets too close (use smaller radius)\r\n                if (this.isWithinSquareRange(creature.position, playerPosition, 2)) {\r\n                    creature.currentBehavior = 'fleeing';\r\n                    creature.targetPosition = new GridPosition(playerPosition.x, playerPosition.y);\r\n                } else {\r\n                    creature.currentBehavior = 'idle';\r\n                }\r\n                break;\r\n\r\n            case 'defensive':\r\n                if (this.isWithinSquareRange(creature.position, playerPosition, 2)) {\r\n                    creature.currentBehavior = 'idle'; // Stand ground\r\n                } else {\r\n                    creature.currentBehavior = 'idle';\r\n                }\r\n                break;\r\n\r\n            case 'territorial':\r\n                if (inSquareRange) {\r\n                    creature.currentBehavior = 'hunting';\r\n                } else {\r\n                    creature.currentBehavior = 'idle';\r\n                }\r\n                break;\r\n\r\n            case 'ambush':\r\n                if (this.isWithinSquareRange(creature.position, playerPosition, 1)) {\r\n                    creature.currentBehavior = 'hunting';\r\n                    creature.targetPosition = new GridPosition(playerPosition.x, playerPosition.y);\r\n                } else {\r\n                    creature.currentBehavior = 'idle';\r\n                }\r\n                break;\r\n\r\n            case 'immobile':\r\n            default:\r\n                creature.currentBehavior = 'idle';\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return true if two positions are within a square (Chebyshev) distance <= range.\r\n     * This models an N x N tile search box centered on the creature (e.g., range=2 -> 5x5).\r\n     */\r\n    private isWithinSquareRange(a: GridPosition, b: GridPosition, range: number): boolean {\r\n        const dx = Math.abs(a.x - b.x);\r\n        const dy = Math.abs(a.y - b.y);\r\n        return Math.max(dx, dy) <= range;\r\n    }\r\n\r\n    /**\r\n     * Determines if the creature should move this tick.\r\n     */\r\n    private shouldMove(creature: CreatureState, currentTick: number): boolean {\r\n        // Move every 5 ticks if not idle\r\n        return creature.currentBehavior !== 'idle' && (currentTick - creature.lastMoveTick) >= 5;\r\n    }\r\n\r\n    /**\r\n     * Executes movement for the creature.\r\n     */\r\n    private executeMovement(\r\n        creature: CreatureState,\r\n        chunks: Map<string, Chunk>,\r\n        playerPosition: GridPosition,\r\n        currentTick: number\r\n    ): { moved: boolean; message?: { text: string; type: 'narrative' | 'system' } } {\r\n        let newPosition: GridPosition;\r\n\r\n        switch (creature.currentBehavior) {\r\n            case 'fleeing':\r\n                // Move away from target (usually player)\r\n                newPosition = this.calculateFleePosition(creature, creature.targetPosition ?? playerPosition);\r\n                break;\r\n\r\n            case 'hunting':\r\n                // Move towards target (player or food)\r\n                newPosition = this.calculateHuntPosition(creature, creature.targetPosition ?? playerPosition);\r\n                break;\r\n\r\n            case 'moving':\r\n            case 'idle':\r\n            default:\r\n                // Random movement\r\n                newPosition = this.calculateRandomPosition(creature);\r\n                break;\r\n        }\r\n\r\n        // Check if movement is valid\r\n        if (this.isValidMove(newPosition, chunks)) {\r\n            creature.position = newPosition;\r\n            // Record tick at which movement happened\r\n            creature.lastMoveTick = currentTick;\r\n\r\n            // Update current chunk if moved to a different one\r\n            const newChunkKey = `${newPosition.x},${newPosition.y}`;\r\n            const newChunk = chunks.get(newChunkKey);\r\n            if (newChunk) {\r\n                creature.currentChunk = newChunk;\r\n            }\r\n\r\n            const creatureName = (creature as any).name?.en || creature.type || 'creature';\r\n            let messageText: string;\r\n\r\n            switch (creature.currentBehavior) {\r\n                case 'fleeing':\r\n                    messageText = this.t('creatureFleeing', { creature: creatureName });\r\n                    break;\r\n                case 'hunting':\r\n                    messageText = this.t('creatureHunting', { creature: creatureName });\r\n                    break;\r\n                case 'moving':\r\n                    messageText = this.t('creatureMoving', { creature: creatureName });\r\n                    break;\r\n                default:\r\n                    messageText = this.t('creatureMoving', { creature: creatureName });\r\n                    break;\r\n            }\r\n\r\n            return {\r\n                moved: true,\r\n                message: {\r\n                    text: messageText,\r\n                    type: 'narrative'\r\n                }\r\n            };\r\n        }\r\n\r\n        return { moved: false };\r\n    }\r\n\r\n    /**\r\n     * Calculates a position for fleeing behavior.\r\n     */\r\n    private calculateFleePosition(creature: CreatureState, threatPosition: GridPosition): GridPosition {\r\n        // Move away from the threat position (player or predator)\r\n        const dx = creature.position.x - threatPosition.x;\r\n        const dy = creature.position.y - threatPosition.y;\r\n        const nx = Math.sign(dx) || (Math.random() < 0.5 ? -1 : 1);\r\n        const ny = Math.sign(dy) || (Math.random() < 0.5 ? -1 : 1);\r\n        return new GridPosition(creature.position.x + nx, creature.position.y + ny);\r\n    }\r\n\r\n    /**\r\n     * Calculates a position for hunting behavior.\r\n     */\r\n    private calculateHuntPosition(creature: CreatureState, targetPosition: GridPosition): GridPosition {\r\n        // Move towards the target position (player or food)\r\n        const dx = targetPosition.x - creature.position.x;\r\n        const dy = targetPosition.y - creature.position.y;\r\n        const nx = Math.sign(dx) || (Math.random() < 0.5 ? -1 : 1);\r\n        const ny = Math.sign(dy) || (Math.random() < 0.5 ? -1 : 1);\r\n        return new GridPosition(creature.position.x + nx, creature.position.y + ny);\r\n    }\r\n\r\n    /**\r\n     * Calculates a random movement position.\r\n     */\r\n    private calculateRandomPosition(creature: CreatureState): GridPosition {\r\n        const directions = [\r\n            { x: -1, y: 0 }, { x: 1, y: 0 }, { x: 0, y: -1 }, { x: 0, y: 1 },\r\n            { x: -1, y: -1 }, { x: -1, y: 1 }, { x: 1, y: -1 }, { x: 1, y: 1 }\r\n        ];\r\n        const randomDir = directions[Math.floor(Math.random() * directions.length)];\r\n        return new GridPosition(\r\n            creature.position.x + randomDir.x,\r\n            creature.position.y + randomDir.y\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks if a move to the given position is valid.\r\n     */\r\n    private isValidMove(position: GridPosition, chunks: Map<string, Chunk>): boolean {\r\n        const chunkKey = `${position.x},${position.y}`;\r\n        const chunk = chunks.get(chunkKey);\r\n\r\n        // Basic validation: chunk exists and is not blocked\r\n        return chunk !== undefined && chunk.travelCost < 100; // High travel cost indicates blocked\r\n    }\r\n\r\n    /**\r\n     * Calculates distance between two positions.\r\n     */\r\n    private calculateDistance(pos1: GridPosition, pos2: GridPosition): number {\r\n        const dx = pos1.x - pos2.x;\r\n        const dy = pos1.y - pos2.y;\r\n        return Math.sqrt(dx * dx + dy * dy);\r\n    }\r\n\r\n    /**\r\n     * Gets all registered creatures.\r\n     */\r\n    getCreatures(): Map<string, CreatureState> {\r\n        return new Map(this.creatures);\r\n    }\r\n\r\n    /**\r\n     * Gets a specific creature by ID.\r\n     */\r\n    getCreature(creatureId: string): CreatureState | undefined {\r\n        return this.creatures.get(creatureId);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\engines\\effect-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'effect' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'effect' is defined but never used. Allowed unused args must match /^_/u.","line":173,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":173,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":173,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":173,"endColumn":63},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'effect' is defined but never used. Allowed unused args must match /^_/u.","line":177,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":177,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":177,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":177,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'effect' is defined but never used. Allowed unused args must match /^_/u.","line":181,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":181,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'effect' is defined but never used. Allowed unused args must match /^_/u.","line":209,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":209,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is defined but never used. Allowed unused args must match /^_/u.","line":209,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":209,"endColumn":57}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export type { Effect } from '../types/effects';\r\nimport { Effect, EffectType, EffectCondition, EffectTarget } from '../types/effects';\r\nimport { GridCell } from '../entities/world';\r\nimport { Character, CharacterStats } from '../entities/character';\r\n\r\nexport class EffectEngine {\r\n    private activeEffects: Map<string, Effect[]> = new Map();\r\n    private customEffectHandlers: Map<string, (effect: Effect, target: any) => void> = new Map();\r\n\r\n    // Register a custom effect handler from mods\r\n    registerEffectHandler(\r\n        effectType: string,\r\n        handler: (effect: Effect, target: any) => void\r\n    ) {\r\n        this.customEffectHandlers.set(effectType, handler);\r\n    }\r\n\r\n    applyEffect(effect: Effect, target: any): void {\r\n        // Check if effect can be applied\r\n        if (!this.canApplyEffect(effect, target)) {\r\n            return;\r\n        }\r\n\r\n        // Get existing effects of same type\r\n        const existingEffects = this.activeEffects.get(effect.id) || [];\r\n\r\n        // Handle stacking\r\n        if (effect.stackable) {\r\n            if (!effect.maxStacks || existingEffects.length < effect.maxStacks) {\r\n                existingEffects.push(effect);\r\n            }\r\n        } else {\r\n            // Replace existing effect\r\n            existingEffects.length = 0;\r\n            existingEffects.push(effect);\r\n        }\r\n\r\n        this.activeEffects.set(effect.id, existingEffects);\r\n        this.processEffect(effect, target);\r\n    }\r\n\r\n    private canApplyEffect(effect: Effect, target: any): boolean {\r\n        if (!effect.conditions) return true;\r\n\r\n        return effect.conditions.every(condition => \r\n            this.checkCondition(condition, target));\r\n    }\r\n\r\n    private checkCondition(condition: EffectCondition, target: any): boolean {\r\n        const value = this.getValueForCondition(condition, target);\r\n        const checkValue = condition.value;\r\n\r\n        switch (condition.operator) {\r\n            case '>': return value > checkValue;\r\n            case '<': return value < checkValue;\r\n            case '>=': return value >= checkValue;\r\n            case '<=': return value <= checkValue;\r\n            case '==': return value === checkValue;\r\n            case '!=': return value !== checkValue;\r\n            default: return false;\r\n        }\r\n    }\r\n\r\n    private getValueForCondition(condition: EffectCondition, target: any): any {\r\n        switch (condition.type) {\r\n            case 'stat':\r\n                return target.stats?.[condition.target || ''];\r\n            case 'skill':\r\n                return target.skills?.[condition.target || ''];\r\n            case 'status':\r\n                return target.statuses?.has(condition.target);\r\n            case 'time':\r\n                return target.time || Date.now();\r\n            case 'location':\r\n                return target.position;\r\n            case 'weather':\r\n                return target.weather?.type;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    private processEffect(effect: Effect, target: any): void {\r\n        // Check for custom handler first\r\n        const customHandler = this.customEffectHandlers.get(effect.type);\r\n        if (customHandler) {\r\n            customHandler(effect, target);\r\n            return;\r\n        }\r\n\r\n        // Default handlers\r\n        switch (effect.type) {\r\n            case EffectType.BUFF:\r\n            case EffectType.DEBUFF:\r\n                this.processStatModification(effect, target);\r\n                break;\r\n            case EffectType.STATUS:\r\n                this.processStatusEffect(effect, target);\r\n                break;\r\n            case EffectType.DAMAGE_OVER_TIME:\r\n            case EffectType.HEALING_OVER_TIME:\r\n                this.processOverTimeEffect(effect, target);\r\n                break;\r\n            case EffectType.MODIFY_MOVEMENT:\r\n                this.processMovementModification(effect, target);\r\n                break;\r\n            case EffectType.MODIFY_VISION:\r\n                this.processVisionModification(effect, target);\r\n                break;\r\n            case EffectType.MODIFY_TERRAIN:\r\n                this.processTerrainModification(effect, target);\r\n                break;\r\n            case EffectType.TEMPERATURE:\r\n                this.processTemperatureEffect(effect, target);\r\n                break;\r\n            case EffectType.HYPOTHERMIA:\r\n                this.processHypothermiaEffect(effect, target);\r\n                break;\r\n            case EffectType.HEATSTROKE:\r\n                this.processHeatstrokeEffect(effect, target);\r\n                break;\r\n            case EffectType.TRIGGER_ABILITY:\r\n                this.processTriggerAbility(effect, target);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private processStatModification(effect: Effect, target: Character): void {\r\n        const stat = effect.target.toString();\r\n        if (!target.stats || !Object.prototype.hasOwnProperty.call(target.stats, stat)) return;\r\n\r\n        switch (effect.modifier.type) {\r\n            case 'flat':\r\n                target.stats[stat as keyof CharacterStats] += effect.modifier.value;\r\n                break;\r\n            case 'percentage':\r\n                target.stats[stat as keyof CharacterStats] *= (1 + effect.modifier.value);\r\n                break;\r\n            case 'multiply':\r\n                target.stats[stat as keyof CharacterStats] *= effect.modifier.value;\r\n                break;\r\n            case 'set':\r\n                target.stats[stat as keyof CharacterStats] = effect.modifier.value;\r\n                break;\r\n        }\r\n    }\r\n\r\n    private processSkillModification(effect: Effect, target: Character): void {\r\n        // Similar to stat modification but for skills\r\n    }\r\n\r\n    private processStatusEffect(effect: Effect, target: Character): void {\r\n        if (!target.hasStatus(effect.id)) target.addStatus(effect.id);\r\n    }\r\n\r\n    private processOverTimeEffect(effect: Effect, target: Character): void {\r\n        const interval = setInterval(() => {\r\n            if (effect.type === EffectType.DAMAGE_OVER_TIME) {\r\n                target.takeDamage(effect.value);\r\n            } else {\r\n                target.heal(effect.value);\r\n            }\r\n        }, effect.tickRate || 1000);\r\n\r\n        if (effect.duration) {\r\n            setTimeout(() => {\r\n                clearInterval(interval);\r\n                this.removeEffect(effect.id);\r\n            }, effect.duration * 1000);\r\n        }\r\n    }\r\n\r\n    private processMovementModification(effect: Effect, target: Character): void {\r\n        // Modify movement speed or cost\r\n    }\r\n\r\n    private processVisionModification(effect: Effect, target: Character): void {\r\n        // Modify vision range or lighting\r\n    }\r\n\r\n    private processTerrainModification(effect: Effect, target: GridCell): void {\r\n        // Modify terrain attributes\r\n    }\r\n\r\n    private processTemperatureEffect(effect: Effect, target: Character): void {\r\n        if (target.modifyBodyTemperature) {\r\n            target.modifyBodyTemperature(effect.value);\r\n        }\r\n    }\r\n\r\n    private processHypothermiaEffect(effect: Effect, target: Character): void {\r\n        // Hypothermia: Apply damage over time and movement debuff\r\n        target.takeDamage(effect.value);\r\n        // Could also apply movement speed reduction here\r\n        if (target.stats) {\r\n            target.stats.dexterity = Math.max(1, target.stats.dexterity - 2); // Reduce dexterity\r\n        }\r\n    }\r\n\r\n    private processHeatstrokeEffect(effect: Effect, target: Character): void {\r\n        // Heatstroke: Apply damage over time and stamina drain\r\n        target.takeDamage(effect.value);\r\n        // Could also apply stamina reduction here\r\n        if (target.stats) {\r\n            target.stats.vitality = Math.max(1, target.stats.vitality - 2); // Reduce vitality\r\n        }\r\n    }\r\n\r\n    private processTriggerAbility(effect: Effect, target: Character): void {\r\n        // Trigger special abilities\r\n    }\r\n\r\n    updateEffects(gameTime: number): void {\r\n        for (const [id, effects] of this.activeEffects.entries()) {\r\n            effects.forEach(effect => {\r\n                if (effect.duration) {\r\n                    if (gameTime >= effect.duration) {\r\n                        this.removeEffect(id);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    removeEffect(effectId: string): void {\r\n        this.activeEffects.delete(effectId);\r\n    }\r\n\r\n    getActiveEffects(targetId?: string): Effect[] {\r\n        if (targetId) {\r\n            return this.activeEffects.get(targetId) || [];\r\n        }\r\n        return Array.from(this.activeEffects.values()).flat();\r\n    }\r\n\r\n    /**\r\n     * Checks a character's body temperature and applies long-term temperature effects if necessary.\r\n     * @param character - The character to check.\r\n     */\r\n    checkTemperatureStatusEffects(character: Character): void {\r\n        if (!character.bodyTemperature) return;\r\n\r\n        const bodyTemp = character.bodyTemperature;\r\n        const hypothermiaId = `hypothermia_${character.id}`;\r\n        const heatstrokeId = `heatstroke_${character.id}`;\r\n\r\n        // Check for hypothermia (body temperature too low)\r\n        if (bodyTemp < 35) {\r\n            // Check if hypothermia effect is already active\r\n            if (!this.activeEffects.has(hypothermiaId)) {\r\n                const hypothermiaEffect: Effect = {\r\n                    id: hypothermiaId,\r\n                    name: { key: 'effect.hypothermia.name' },\r\n                    description: { key: 'effect.hypothermia.description' },\r\n                    type: EffectType.HYPOTHERMIA,\r\n                    target: EffectTarget.SELF,\r\n                    value: 2, // Damage per tick\r\n                    modifier: { type: 'flat', value: 1 },\r\n                    duration: 30, // Lasts 30 seconds, can be reapplied\r\n                    tickRate: 5000 // Apply every 5 seconds\r\n                };\r\n                this.applyEffect(hypothermiaEffect, character);\r\n            }\r\n        } else {\r\n            // Remove hypothermia if body temperature is normal\r\n            this.removeEffect(hypothermiaId);\r\n        }\r\n\r\n        // Check for heatstroke (body temperature too high)\r\n        if (bodyTemp > 40) {\r\n            // Check if heatstroke effect is already active\r\n            if (!this.activeEffects.has(heatstrokeId)) {\r\n                const heatstrokeEffect: Effect = {\r\n                    id: heatstrokeId,\r\n                    name: { key: 'effect.heatstroke.name' },\r\n                    description: { key: 'effect.heatstroke.description' },\r\n                    type: EffectType.HEATSTROKE,\r\n                    target: EffectTarget.SELF,\r\n                    value: 3, // Damage per tick\r\n                    modifier: { type: 'flat', value: 1 },\r\n                    duration: 30, // Lasts 30 seconds, can be reapplied\r\n                    tickRate: 5000 // Apply every 5 seconds\r\n                };\r\n                this.applyEffect(heatstrokeEffect, character);\r\n            }\r\n        } else {\r\n            // Remove heatstroke if body temperature is normal\r\n            this.removeEffect(heatstrokeId);\r\n        }\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\engines\\plant-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\engines\\weather-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'intensity' is defined but never used. Allowed unused args must match /^_/u.","line":115,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Weather } from '../entities/weather';\r\nimport { WeatherType, WeatherIntensity, WeatherCondition, RegionalWeather } from '../types/weather';\r\nimport { EffectEngine } from '../engines/effect-engine';\r\nimport { GridPosition } from '../values/grid-position';\r\nimport { GridCell } from '../entities/world';\r\nimport { Character } from '../entities/character';\r\nimport { Effect, EffectType, EffectTarget } from '../types/effects';\r\n\r\n\r\nexport class WeatherEngine {\r\n    private currentWeather: Weather;\r\n    private gameTime: number = 0;\r\n    private lastUpdate: number = 0;\r\n    \r\n    constructor(\r\n        private readonly effectEngine: EffectEngine,\r\n        private readonly weatherData: Map<WeatherType, WeatherCondition>,\r\n        initialWeather?: Weather\r\n    ) {\r\n        // Start with clear weather if none specified\r\n        this.currentWeather = initialWeather || this.createWeather(WeatherType.CLEAR, WeatherIntensity.MILD);\r\n    }\r\n\r\n    update(newGameTime: number): void {\r\n        this.gameTime = newGameTime;\r\n        const timeDelta = this.gameTime - this.lastUpdate;\r\n\r\n        // Update current weather\r\n        this.currentWeather.update(this.gameTime);\r\n\r\n        // Check for weather transitions\r\n        this.checkWeatherTransitions();\r\n\r\n        // Update regional variations\r\n        this.updateRegionalWeather(timeDelta);\r\n\r\n        this.lastUpdate = this.gameTime;\r\n    }\r\n\r\n    private checkWeatherTransitions(): void {\r\n        if (this.currentWeather.remainingDuration() <= 0) {\r\n            // Defensive: getPossibleTransitions may return WeatherTransition[] or WeatherType[]\r\n            const possibleTransitions = this.currentWeather.getPossibleTransitions?.() || [];\r\n            // If transitions have probability and toType, treat as WeatherTransition[]\r\n            if (possibleTransitions.length > 0 && typeof possibleTransitions[0] === 'object' && 'probability' in possibleTransitions[0] && 'toType' in possibleTransitions[0]) {\r\n                const totalProb = possibleTransitions.reduce((sum: number, t: any) => sum + (t.probability || 0), 0);\r\n                let random = Math.random() * totalProb;\r\n                for (const transition of possibleTransitions) {\r\n                    random -= transition.probability || 0;\r\n                    if (random <= 0) {\r\n                        this.transitionTo(transition.toType);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private updateRegionalWeather(_timeDelta: number): void {\r\n        // Update each regional variation\r\n        // This could include:\r\n        // - Expanding/contracting weather areas\r\n        // - Changing intensities\r\n        // - Moving weather systems\r\n    }\r\n\r\n    getWeatherAt(position: GridPosition): WeatherCondition {\r\n        const weather = this.currentWeather.getWeatherAtPosition(position);\r\n        // Fallback to a default WeatherCondition if null\r\n        return weather ? weather.getPrimaryCondition() : this.weatherData.get(WeatherType.CLEAR)!;\r\n    }\r\n\r\n    applyWeatherEffects(cell: GridCell, character?: Character): void {\r\n        const weather = this.getWeatherAt(cell.position);\r\n\r\n        weather.effects.forEach(effect => {\r\n            this.effectEngine.applyEffect(effect, cell);\r\n        });\r\n\r\n        // Apply temperature effects to character if present\r\n        if (character) {\r\n            const environmentalTemp = this.getEnvironmentalTemperature(cell.position);\r\n            const idealTemp = 37; // Normal human body temperature\r\n            const tempDifference = environmentalTemp - idealTemp;\r\n\r\n            // Create a temperature effect based on the difference\r\n            // Scale the effect to prevent instant temperature changes\r\n            const tempEffectValue = tempDifference * 0.01; // Small incremental change\r\n\r\n            if (Math.abs(tempEffectValue) > 0.001) { // Only apply if there's a meaningful difference\r\n                const tempEffect: Effect = {\r\n                    id: `environmental_temperature_${cell.position.x}_${cell.position.y}`,\r\n                    name: { key: 'effect.environmental_temperature.name' },\r\n                    description: { key: 'effect.environmental_temperature.description' },\r\n                    type: EffectType.TEMPERATURE,\r\n                    target: EffectTarget.SELF,\r\n                    value: tempEffectValue,\r\n                    modifier: { type: 'flat', value: 1 },\r\n                    duration: 1, // Apply every game tick\r\n                    tickRate: 1000 // Apply every second\r\n                };\r\n\r\n                this.effectEngine.applyEffect(tempEffect, character);\r\n            }\r\n\r\n            // Check for long-term temperature effects\r\n            this.effectEngine.checkTemperatureStatusEffects(character);\r\n        }\r\n    }\r\n\r\n    createRegionalWeather(\r\n        centerPosition: GridPosition,\r\n        radius: number,\r\n        weatherType: WeatherType,\r\n        intensity: WeatherIntensity\r\n    ): void {\r\n        const regionalWeather: RegionalWeather = {\r\n            primaryCondition: this.weatherData.get(weatherType)!,\r\n            localVariations: new Map(),\r\n            affectedArea: {\r\n                center: { x: centerPosition.x, y: centerPosition.y },\r\n                radius\r\n            }\r\n        };\r\n\r\n        const regionType = regionalWeather.primaryCondition.type ?? 'CLEAR';\r\n        this.currentWeather.addRegionalVariation(String(regionType), 1);\r\n    }\r\n\r\n    private createWeather(type: WeatherType, intensity: WeatherIntensity): Weather {\r\n        const condition = this.weatherData.get(type);\r\n        if (!condition) {\r\n            throw new Error(`No weather data found for type: ${type}`);\r\n        }\r\n\r\n        // Use a Weather factory or implementation as needed\r\n        // Placeholder: return an object matching the Weather interface\r\n        return {\r\n            getType: () => type,\r\n            getIntensity: () => intensity,\r\n            getConditions: () => [condition],\r\n            getEffects: () => condition.effects,\r\n            getCoverage: () => [],\r\n            getDuration: () => condition.duration || 0,\r\n            remainingDuration: () => condition.duration || 0,\r\n            getPossibleTransitions: () => condition.transitions || [],\r\n            update: () => {},\r\n            getWeatherAtPosition: () => null,\r\n            addRegionalVariation: () => {},\r\n            getPrimaryCondition: () => condition\r\n        };\r\n    }\r\n\r\n    transitionTo(newType: WeatherType): void {\r\n        this.currentWeather = this.createWeather(newType, WeatherIntensity.NORMAL);\r\n    }\r\n\r\n    // Helper methods for weather transitions\r\n    private getCurrentSeason(): string {\r\n        // This would be implemented based on your game's time system\r\n        return 'summer';\r\n    }\r\n\r\n    private getAverageTemperature(): number {\r\n        // Calculate the average temperature across the world\r\n        // This is a simplified implementation - in a full game, this would iterate over all cells\r\n        // For now, we'll use a default baseline temperature\r\n        return 20;\r\n    }\r\n\r\n    /**\r\n     * Calculates the environmental temperature at a specific position, considering terrain, weather, and time of day.\r\n     * @param position - The grid position to calculate temperature for.\r\n     * @returns The environmental temperature in Celsius.\r\n     */\r\n    getEnvironmentalTemperature(position: GridPosition): number {\r\n        // Get terrain temperature as base\r\n        const weatherCondition = this.getWeatherAt(position);\r\n        const baseTerrainTemp = weatherCondition.temperature || 20; // Default if no terrain data\r\n\r\n        // Apply weather modifiers\r\n        let weatherModifier = 0;\r\n        const weatherType = this.currentWeather.getType();\r\n        const intensity = this.currentWeather.getIntensity();\r\n\r\n        switch (weatherType) {\r\n            case WeatherType.CLEAR:\r\n                weatherModifier = 0;\r\n                break;\r\n            case WeatherType.CLOUDY:\r\n                weatherModifier = -2;\r\n                break;\r\n            case WeatherType.RAIN:\r\n                weatherModifier = -5;\r\n                break;\r\n            case WeatherType.SNOW:\r\n                weatherModifier = -10;\r\n                break;\r\n            case WeatherType.HEATWAVE:\r\n                weatherModifier = 10;\r\n                break;\r\n            default:\r\n                weatherModifier = 0;\r\n        }\r\n\r\n        // Apply intensity modifier\r\n        const intensityMultiplier = intensity === WeatherIntensity.SEVERE ? 1.5 :\r\n                                   intensity === WeatherIntensity.MILD ? 0.5 : 1.0;\r\n        weatherModifier *= intensityMultiplier;\r\n\r\n        // Apply day/night cycle modifier\r\n        const dayNightModifier = this.getDayNightTemperatureModifier();\r\n\r\n        // Calculate final temperature\r\n        const environmentalTemp = baseTerrainTemp + weatherModifier + dayNightModifier;\r\n\r\n        return Math.round(environmentalTemp);\r\n    }\r\n\r\n    /**\r\n     * Calculates temperature modifier based on time of day.\r\n     * @returns Temperature modifier for day/night cycle.\r\n     */\r\n    private getDayNightTemperatureModifier(): number {\r\n        // Simplified day/night cycle - in a full implementation, this would use gameTime\r\n        // For now, assume daytime (warmer) during most of the game\r\n        const hourOfDay = (this.gameTime / 3600) % 24; // Convert gameTime to hours\r\n\r\n        if (hourOfDay >= 6 && hourOfDay <= 18) {\r\n            // Daytime: +5┬░C\r\n            return 5;\r\n        } else {\r\n            // Nighttime: -5┬░C\r\n            return -5;\r\n        }\r\n    }\r\n\r\n    private getAverageHumidity(): number {\r\n        // This would calculate the average humidity across the world\r\n        return 50;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\character.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslatableString' is defined but never used.","line":3,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Effect } from '../types/effects';\r\nimport { Item } from '../types/items';\r\nimport type { TranslatableString } from '../types/i18n';\r\nimport { Skill } from './skill';\r\n\r\n/**\r\n * Character statistics representing core attributes that influence a character's capabilities.\r\n */\r\nexport interface CharacterStats {\r\n    /** Physical power and melee damage. Higher strength increases physical attack power. */\r\n    strength: number;\r\n    /** Agility and accuracy. Higher dexterity improves hit chance and evasion. */\r\n    dexterity: number;\r\n    /** Magical power and mana capacity. Higher intelligence increases magical attack and mana pool. */\r\n    intelligence: number;\r\n    /** Health and defense. Higher vitality increases maximum health and physical defense. */\r\n    vitality: number;\r\n    /** Critical hits and rare item finds. Higher luck increases critical hit chance and improves loot quality. */\r\n    luck: number;\r\n}\r\n\r\n/**\r\n * Represents possible character actions in the game, detailing the type of action and its target/parameters.\r\n */\r\nexport type CharacterAction = {\r\n    /** The type of action being performed (e.g., 'move', 'attack', 'cast', 'use_item', 'interact'). */\r\n    type: 'move' | 'attack' | 'cast' | 'use_item' | 'interact';\r\n    /** Optional: Position (x, y) or entity ID for the action target. */\r\n    target?: { x: number; y: number } | string;\r\n    /** Optional: Item ID when the action involves using an item. */\r\n    item?: string;\r\n    /** Optional: Skill ID when the action involves casting a skill. */\r\n    skill?: string;\r\n};\r\n\r\n/**\r\n * Main character class representing both Non-Player Characters (NPCs) and player characters.\r\n * This class manages character stats, inventory, skills, and status effects.\r\n */\r\nexport class Character {\r\n    /** Unique identifier for the character. */\r\n    id: string;\r\n    /** Character's display name. */\r\n    name: string;\r\n    /** Current character level. */\r\n    level: number;\r\n    /** Current health points. */\r\n    health: number;\r\n    /** Maximum health points the character can have. */\r\n    maxHealth: number;\r\n    /** Current mana points. */\r\n    mana: number;\r\n    /** Maximum mana points the character can have. */\r\n    maxMana: number;\r\n    /** Current body temperature in Celsius. */\r\n    bodyTemperature: number;\r\n    /** Current experience points. */\r\n    experience: number;\r\n    /** Character's position in the game world. */\r\n    position: { x: number; y: number };\r\n    /** Items carried by the character in their inventory. */\r\n    inventory: Item[];\r\n    /** Active status effects currently affecting the character. */\r\n    activeEffects: Effect[];\r\n    /** List of skill IDs the character knows. */\r\n    skills: string[];\r\n    /** Character's base stats. */\r\n    stats: CharacterStats;\r\n    /** Collection of active status effect IDs. */\r\n    private statuses: Set<string>;\r\n    /** Map of skill instances, indexed by skill ID. */\r\n    private skillInstances: Map<string, Skill>;\r\n    /** Character state flags (e.g., 'invulnerable', 'stunned'). */\r\n    private flags: { [key: string]: boolean };\r\n\r\n    /**\r\n     * Creates an instance of Character.\r\n     * @param id - Unique identifier for the character.\r\n     * @param name - Display name of the character.\r\n     * @param baseStats - Initial base statistics for the character.\r\n     */\r\n    constructor(id: string, name: string, baseStats: CharacterStats) {\r\n        this.id = id;\r\n        this.name = name;\r\n        this.level = 1;\r\n        this.health = 100;\r\n        this.maxHealth = 100;\r\n        this.mana = 100;\r\n        this.maxMana = 100;\r\n        this.bodyTemperature = 37; // Normal human body temperature in Celsius\r\n        this.experience = 0;\r\n        this.position = { x: 0, y: 0 };\r\n        this.inventory = [];\r\n        this.activeEffects = [];\r\n        this.skills = [];\r\n        this.stats = { ...baseStats };\r\n        this.skillInstances = new Map();\r\n        this.statuses = new Set();\r\n        this.flags = {};\r\n    }\r\n\r\n    /**\r\n     * Applies damage to the character, reducing their health.\r\n     * Damage is ignored if the character has the 'invulnerable' flag.\r\n     * @param amount - The amount of damage to take.\r\n     */\r\n    takeDamage(amount: number): void {\r\n        if (this.flags['invulnerable']) return;\r\n        this.health = Math.max(0, this.health - amount);\r\n    }\r\n\r\n    /**\r\n     * Heals the character, restoring health up to their maximum health.\r\n     * @param amount - The amount of health to restore.\r\n     */\r\n    heal(amount: number): void {\r\n        this.health = Math.min(this.maxHealth, this.health + amount);\r\n    }\r\n\r\n    /**\r\n     * Modifies the character's body temperature by a given amount.\r\n     * Temperature is clamped between 30┬░C and 45┬░C to prevent unrealistic values.\r\n     * @param amount - The amount to change the body temperature by.\r\n     */\r\n    modifyBodyTemperature(amount: number): void {\r\n        this.bodyTemperature = Math.max(30, Math.min(45, this.bodyTemperature + amount));\r\n    }\r\n\r\n    /**\r\n     * Modifies a character's specific stat by a given amount.\r\n     * @param stat - The name of the stat to modify (e.g., 'strength', 'dexterity').\r\n     * @param amount - The amount to add to the stat. Can be positive or negative.\r\n     */\r\n    modifyStat(stat: keyof CharacterStats, amount: number): void {\r\n        if (stat in this.stats) {\r\n            this.stats[stat] += amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a status effect to the character.\r\n     * @param statusId - The unique ID of the status effect to add.\r\n     */\r\n    addStatus(statusId: string): void {\r\n        this.statuses.add(statusId);\r\n    }\r\n\r\n    /**\r\n     * Removes a status effect from the character.\r\n     * @param statusId - The unique ID of the status effect to remove.\r\n     */\r\n    removeStatus(statusId: string): void {\r\n        this.statuses.delete(statusId);\r\n    }\r\n\r\n    /**\r\n     * Checks if the character currently has a specific status effect.\r\n     * @param statusId - The unique ID of the status effect to check.\r\n     * @returns `true` if the character has the status, `false` otherwise.\r\n     */\r\n    hasStatus(statusId: string): boolean {\r\n        return this.statuses.has(statusId);\r\n    }\r\n\r\n    /**\r\n     * Adds a new skill to the character's repertoire.\r\n     * @param skill - The {@link Skill} instance to add.\r\n     */\r\n    addSkill(skill: Skill): void {\r\n        this.skills.push(skill.id);\r\n        this.skillInstances.set(skill.id, skill);\r\n    }\r\n\r\n    /**\r\n     * Removes a skill from the character.\r\n     * @param skillId - The unique ID of the skill to remove.\r\n     */\r\n    removeSkill(skillId: string): void {\r\n        this.skills = this.skills.filter(id => id !== skillId);\r\n        this.skillInstances.delete(skillId);\r\n    }\r\n\r\n    /**\r\n     * Checks if the character has a specific skill.\r\n     * @param skillId - The unique ID of the skill to check.\r\n     * @returns `true` if the character has the skill, `false` otherwise.\r\n     */\r\n    hasSkill(skillId: string): boolean {\r\n        return this.skills.includes(skillId);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a skill instance by its ID.\r\n     * @param skillId - The unique ID of the skill to retrieve.\r\n     * @returns The {@link Skill} instance if found, otherwise `undefined`.\r\n     */\r\n    getSkill(skillId: string): Skill | undefined {\r\n        return this.skillInstances.get(skillId);\r\n    }\r\n\r\n    /**\r\n     * Checks if a skill can be used by the character based on mana cost and cooldown.\r\n     * @param skillId - The unique ID of the skill to check.\r\n     * @returns `true` if the skill can be used, `false` otherwise.\r\n     */\r\n    canUseSkill(skillId: string): boolean {\r\n        const skill = this.skillInstances.get(skillId);\r\n        if (!skill) return false;\r\n        return skill.isUsable(this.mana);\r\n    }\r\n\r\n    /**\r\n     * Uses a skill, consuming mana and starting its cooldown.\r\n     * @param skillId - The unique ID of the skill to use.\r\n     */\r\n    useSkill(skillId: string): void {\r\n        const skill = this.skillInstances.get(skillId);\r\n        if (!skill || !this.canUseSkill(skillId)) return;\r\n        \r\n        this.mana -= skill.manaCost;\r\n        skill.startCooldown();\r\n    }\r\n\r\n    /**\r\n     * Adds an item to the character's inventory.\r\n     * @param item - The {@link Item} to add.\r\n     */\r\n    addItem(item: Item): void {\r\n        this.inventory.push(item);\r\n    }\r\n\r\n    /**\r\n     * Removes and returns an item from the character's inventory.\r\n     * @param itemId - The unique ID of the item to remove.\r\n     * @returns The removed {@link Item} if found, otherwise `undefined`.\r\n     */\r\n    removeItem(itemId: string): Item | undefined {\r\n        const index = this.inventory.findIndex(item => item.id === itemId);\r\n        if (index === -1) return undefined;\r\n        return this.inventory.splice(index, 1)[0];\r\n    }\r\n\r\n    /**\r\n     * Checks if the character has a specific item in their inventory.\r\n     * @param itemId - The unique ID of the item to check for.\r\n     * @returns `true` if the character has the item, `false` otherwise.\r\n     */\r\n    hasItem(itemId: string): boolean {\r\n        return this.inventory.some(item => item.id === itemId);\r\n    }\r\n\r\n    /**\r\n     * Checks if the character is currently alive (health > 0).\r\n     * @returns `true` if the character is alive, `false` otherwise.\r\n     */\r\n    isAlive(): boolean {\r\n        return this.health > 0;\r\n    }\r\n\r\n    /**\r\n     * Checks if the character can currently move.\r\n     * Movement is restricted if the character has the 'stunned' flag.\r\n     * @returns `true` if the character can move, `false` otherwise.\r\n     */\r\n    canMove(): boolean {\r\n        return !this.flags['stunned'];\r\n    }\r\n\r\n    /**\r\n     * Updates the character's state, processing active effects and skill cooldowns.\r\n     * @param deltaTime - The time elapsed since the last update, in milliseconds.\r\n     */\r\n    update(deltaTime: number): void {\r\n        // Update skill cooldowns\r\n        this.skillInstances.forEach(skill => {\r\n            skill.reduceCooldown(deltaTime / 1000);\r\n        });\r\n\r\n        // Update active effects\r\n        this.activeEffects = this.activeEffects.filter(effect => {\r\n            if (effect.duration) {\r\n                return effect.duration > 0;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\chunk-new.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\chunk.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\combat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\entity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\experience.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TranslatableString' is defined but never used.","line":1,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TranslatableString } from '../types/i18n';\r\n\r\n/**\r\n * Defines the experience requirements and rewards for a specific character level.\r\n */\r\nexport interface ExperienceLevel {\r\n    /** The character level this definition applies to. */\r\n    level: number;\r\n    /** The total experience points required to reach this level. */\r\n    requiredExp: number;\r\n    /** Optional: Rewards granted upon reaching this level. */\r\n    rewards?: {\r\n        /** Optional: Number of skill points gained. */\r\n        skillPoints?: number;\r\n        /** Optional: Number of stat points gained. */\r\n        statPoints?: number;\r\n        /** Optional: List of unlockable features or items. */\r\n        unlockables?: string[];\r\n    };\r\n}\r\n\r\n/**\r\n * Manages a character's experience points and level progression.\r\n */\r\nexport class Experience {\r\n    private _currentExp: number;\r\n    private _currentLevel: number;\r\n    private readonly _levelThresholds: ExperienceLevel[];\r\n\r\n    /**\r\n     * Creates an instance of Experience.\r\n     * @param initialExp - The starting experience points for the character.\r\n     * @param levelThresholds - An array defining the experience requirements and rewards for each level. Defaults to `defaultLevelThresholds`.\r\n     */\r\n    constructor(\r\n        initialExp: number = 0,\r\n        levelThresholds: ExperienceLevel[] = defaultLevelThresholds\r\n    ) {\r\n        this._currentExp = initialExp;\r\n        this._levelThresholds = levelThresholds;\r\n        this._currentLevel = this.calculateLevel(initialExp);\r\n    }\r\n\r\n    /** Gets the current experience points of the character. */\r\n    get currentExp(): number {\r\n        return this._currentExp;\r\n    }\r\n\r\n    /** Gets the current level of the character. */\r\n    get currentLevel(): number {\r\n        return this._currentLevel;\r\n    }\r\n\r\n    /** Gets the experience points required to reach the next level. Returns `Infinity` if at max level. */\r\n    get nextLevelExp(): number {\r\n        const nextLevel = this._levelThresholds.find(lt => lt.level === this._currentLevel + 1);\r\n        return nextLevel?.requiredExp || Infinity;\r\n    }\r\n\r\n    /** Gets the remaining experience points needed to reach the next level. */\r\n    get expToNextLevel(): number {\r\n        return this.nextLevelExp - this._currentExp;\r\n    }\r\n\r\n    /** Gets the {@link ExperienceLevel} data for the current level. */\r\n    get currentLevelData(): ExperienceLevel {\r\n        return this._levelThresholds.find(lt => lt.level === this._currentLevel)!;\r\n    }\r\n\r\n    /**\r\n     * Adds experience points to the character and calculates any level ups.\r\n     * @param amount - The amount of experience points to add.\r\n     * @returns A {@link LevelUpResult} detailing any levels gained and their rewards.\r\n     */\r\n    addExperience(amount: number): LevelUpResult {\r\n        const oldLevel = this._currentLevel;\r\n        this._currentExp += amount;\r\n        const newLevel = this.calculateLevel(this._currentExp);\r\n        this._currentLevel = newLevel;\r\n\r\n        if (newLevel > oldLevel) {\r\n            const levelUps: ExperienceLevel[] = [];\r\n            for (let level = oldLevel + 1; level <= newLevel; level++) {\r\n                const levelData = this._levelThresholds.find(lt => lt.level === level);\r\n                if (levelData) levelUps.push(levelData);\r\n            }\r\n            return {\r\n                levelsGained: newLevel - oldLevel,\r\n                newLevel,\r\n                levelUps\r\n            };\r\n        }\r\n\r\n        return { levelsGained: 0, newLevel: oldLevel, levelUps: [] };\r\n    }\r\n\r\n    /**\r\n     * Calculates the character's level based on their total experience points.\r\n     * @param exp - The total experience points.\r\n     * @returns The corresponding character level.\r\n     */\r\n    private calculateLevel(exp: number): number {\r\n        let level = 1;\r\n        for (const threshold of this._levelThresholds) {\r\n            if (exp >= threshold.requiredExp) {\r\n                level = threshold.level;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return level;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the result of an experience gain operation, detailing any level ups.\r\n */\r\nexport interface LevelUpResult {\r\n    /** The number of levels gained in this operation. */\r\n    levelsGained: number;\r\n    /** The character's new level after gaining experience. */\r\n    newLevel: number;\r\n    /** An array of {@link ExperienceLevel} objects for each level gained, including their rewards. */\r\n    levelUps: ExperienceLevel[];\r\n}\r\n\r\n/**\r\n * Default level thresholds following a common RPG progression curve.\r\n * This array defines the experience required for each level up to 100,\r\n * along with default rewards like skill and stat points.\r\n */\r\nconst defaultLevelThresholds: ExperienceLevel[] = Array.from({ length: 100 }, (_, i) => ({\r\n    level: i + 1,\r\n    // Experience required increases exponentially: 100 * (1.5 ^ level)\r\n    requiredExp: Math.floor(100 * (Math.pow(1.5, i))),\r\n    rewards: {\r\n        // Skill points are granted every 5 levels\r\n        skillPoints: (i + 1) % 5 === 0 ? 1 : 0,\r\n        // 3 stat points are granted per level\r\n        statPoints: 3,\r\n        unlockables: []\r\n    }\r\n}));\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\exploration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_skillGains' is assigned a value but never used.","line":322,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":322,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GridPosition } from '../values/grid-position';\r\nimport { GridCell } from './grid-cell';\r\nimport type { TranslatableString } from '../types/i18n';\r\n\r\n/**\r\n * Defines the various types of discoveries that can be made during exploration.\r\n */\r\nexport enum DiscoveryType {\r\n    LANDMARK = 'landmark',    // A notable geographical or structural feature.\r\n    RESOURCE = 'resource',    // A source of valuable materials.\r\n    SETTLEMENT = 'settlement',// A populated area or ruin.\r\n    DUNGEON = 'dungeon',      // A dangerous area with challenges and rewards.\r\n    ARTIFACT = 'artifact',    // A rare or unique item of significance.\r\n    SECRET = 'secret'         // A hidden area or piece of lore.\r\n}\r\n\r\n/**\r\n * Defines the difficulty levels for exploration and discoveries.\r\n */\r\nexport enum ExplorationDifficulty {\r\n    EASY = 'easy',\r\n    NORMAL = 'normal',\r\n    HARD = 'hard',\r\n    EXTREME = 'extreme',\r\n    LEGENDARY = 'legendary'\r\n}\r\n\r\n/**\r\n * Represents a single discovery made during exploration.\r\n */\r\nexport interface Discovery {\r\n    /** Unique identifier for the discovery. */\r\n    id: string;\r\n    /** The type of discovery. */\r\n    type: DiscoveryType;\r\n    /** The multilingual name of the discovery. */\r\n    name: TranslatableString;\r\n    /** The multilingual description of the discovery. */\r\n    description: TranslatableString;\r\n    /** The difficulty associated with making or interacting with this discovery. */\r\n    difficulty: ExplorationDifficulty;\r\n    /** Optional: Rewards obtained upon making this discovery. */\r\n    rewards?: {\r\n        /** Experience points gained. */\r\n        experience: number;\r\n        /** Optional: List of item IDs obtained. */\r\n        items?: string[];\r\n        /** Optional: List of features or recipes unlocked. */\r\n        unlocks?: string[];\r\n    };\r\n}\r\n\r\n/**\r\n * Tracks the player's overall exploration progress and discoveries.\r\n */\r\nexport interface ExplorationProgress {\r\n    /** A set of string representations of {@link GridPosition} for cells that have been revealed. */\r\n    revealedCells: Set<string>;\r\n    /** A map of all discoveries made, indexed by their ID. */\r\n    discoveries: Map<string, Discovery>;\r\n    /** A set of IDs for discoveries that have been fully completed or resolved. */\r\n    completedDiscoveries: Set<string>;\r\n    /** The total cumulative score from all exploration activities. */\r\n    totalExplorationScore: number;\r\n    /** A map of exploration-related skill levels, indexed by skill name. */\r\n    skillLevels: Map<string, number>;\r\n}\r\n\r\n/**\r\n * Manages the player's exploration activities, including revealing cells,\r\n * discovering points of interest, and tracking exploration-related skills.\r\n */\r\nexport class ExplorationManager {\r\n    private _progress: ExplorationProgress;\r\n    private _activeCells: Map<string, GridCell>;\r\n    private _discoveryChances: Map<string, number>;\r\n\r\n    /**\r\n     * Creates an instance of ExplorationManager.\r\n     */\r\n    constructor() {\r\n        this._progress = {\r\n            revealedCells: new Set(),\r\n            discoveries: new Map(),\r\n            completedDiscoveries: new Set(),\r\n            totalExplorationScore: 0,\r\n            skillLevels: new Map([\r\n                ['tracking', 1],\r\n                ['survival', 1],\r\n                ['archaeology', 1],\r\n                ['naturalism', 1]\r\n            ])\r\n        };\r\n        this._activeCells = new Map();\r\n        this._discoveryChances = new Map();\r\n    }\r\n\r\n    /**\r\n     * Explores a given grid cell, updating exploration progress and checking for new discoveries.\r\n     * @param cell - The {@link GridCell} to explore.\r\n     * @param explorationSkills - A map of the player's current exploration skill levels.\r\n     * @returns An {@link ExplorationResult} detailing the outcome of the exploration.\r\n     */\r\n    exploreCell(cell: GridCell, explorationSkills: Map<string, number>): ExplorationResult {\r\n        // If the cell has already been revealed, return 'already_explored' type.\r\n        if (this._progress.revealedCells.has(cell.position.toString())) {\r\n            return { type: 'already_explored', discoveries: [] };\r\n        }\r\n\r\n        // Mark the cell as revealed and add it to active cells.\r\n        this._progress.revealedCells.add(cell.position.toString());\r\n        this._activeCells.set(cell.position.toString(), cell);\r\n\r\n        // Check for new discoveries within the cell.\r\n        const discoveries = this.checkForDiscoveries(cell, explorationSkills);\r\n        // Calculate exploration points gained from this action.\r\n        const explorationPoints = this.calculateExplorationPoints(cell, discoveries);\r\n        \r\n        // Add points to total exploration score.\r\n        this._progress.totalExplorationScore += explorationPoints;\r\n        \r\n        return {\r\n            type: 'success',\r\n            discoveries,\r\n            explorationPoints,\r\n            newSkillLevels: this.updateSkillLevels(discoveries)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Checks for potential discoveries within a given grid cell based on its attributes and player skills.\r\n     * @param cell - The {@link GridCell} to check.\r\n     * @param skills - A map of the player's current exploration skill levels.\r\n     * @returns An array of {@link Discovery} objects found in the cell.\r\n     */\r\n    private checkForDiscoveries(cell: GridCell, skills: Map<string, number>): Discovery[] {\r\n        const discoveries: Discovery[] = [];\r\n        const baseChance = this.calculateBaseDiscoveryChance(cell);\r\n\r\n        // Check each discovery type based on cell attributes and relevant skills.\r\n        // Magic affinity influences artifact discovery, boosted by archaeology skill.\r\n        if (this.rollForDiscovery(baseChance * cell.attributes.magicAffinity / 100, skills.get('archaeology') || 1)) {\r\n            discoveries.push(this.generateDiscovery(DiscoveryType.ARTIFACT, cell));\r\n        }\r\n\r\n        // Human presence influences settlement discovery, boosted by archaeology skill.\r\n        if (this.rollForDiscovery(baseChance * cell.attributes.humanPresence / 100, skills.get('archaeology') || 1)) {\r\n            discoveries.push(this.generateDiscovery(DiscoveryType.SETTLEMENT, cell));\r\n        }\r\n\r\n        // Danger level influences dungeon discovery, boosted by survival skill.\r\n        if (this.rollForDiscovery(baseChance * cell.attributes.dangerLevel / 100, skills.get('survival') || 1)) {\r\n            discoveries.push(this.generateDiscovery(DiscoveryType.DUNGEON, cell));\r\n        }\r\n\r\n        // Vegetation density influences resource discovery, boosted by naturalism skill.\r\n        if (this.rollForDiscovery(baseChance * cell.attributes.vegetationDensity / 100, skills.get('naturalism') || 1)) {\r\n            discoveries.push(this.generateDiscovery(DiscoveryType.RESOURCE, cell));\r\n        }\r\n\r\n        return discoveries;\r\n    }\r\n\r\n    /**\r\n     * Calculates the base chance of making a discovery in a given cell.\r\n     * This chance is influenced by the cell's explorability and whether neighboring cells have already been explored.\r\n     * @param cell - The {@link GridCell} for which to calculate the chance.\r\n     * @returns The base discovery chance (0-1).\r\n     */\r\n    private calculateBaseDiscoveryChance(cell: GridCell): number {\r\n        const key = cell.position.toString();\r\n        // Cache the calculated chance to avoid redundant computations.\r\n        if (!this._discoveryChances.has(key)) {\r\n            let chance = 0.1; // 10% base chance for any discovery.\r\n            // Explorability directly scales the chance.\r\n            chance *= (cell.attributes.explorability / 100);\r\n            // Reduce chance if many neighbors are already explored, simulating less \"new\" to find.\r\n            chance *= (1 - (this.getNeighborExploredCount(cell.position) * 0.1)); \r\n            this._discoveryChances.set(key, chance);\r\n        }\r\n        return this._discoveryChances.get(key)!;\r\n    }\r\n\r\n    /**\r\n     * Rolls a dice to determine if a discovery is made, considering base chance and skill level.\r\n     * @param chance - The base probability (0-1) of discovery.\r\n     * @param skillLevel - The player's relevant skill level.\r\n     * @returns `true` if a discovery is made, `false` otherwise.\r\n     */\r\n    private rollForDiscovery(chance: number, skillLevel: number): boolean {\r\n        // Skill level provides a bonus to the discovery chance.\r\n        const skillBonus = (skillLevel - 1) * 0.05; // 5% bonus per skill level.\r\n        return Math.random() < (chance + skillBonus);\r\n    }\r\n\r\n    /**\r\n     * Generates a new {@link Discovery} object for a given type and cell.\r\n     * @param type - The {@link DiscoveryType} to generate.\r\n     * @param cell - The {@link GridCell} where the discovery was made.\r\n     * @returns The newly generated {@link Discovery} object.\r\n     */\r\n    private generateDiscovery(type: DiscoveryType, cell: GridCell): Discovery {\r\n        const id = `${type}_${cell.position.toString()}_${Date.now()}`;\r\n        const discovery: Discovery = {\r\n            id,\r\n            type,\r\n            name: { key: `discovery.${type}.name` }, // Placeholder for translatable name.\r\n            description: { key: `discovery.${type}.description` }, // Placeholder for translatable description.\r\n            difficulty: this.calculateDifficulty(cell),\r\n            rewards: {\r\n                experience: this.calculateExperienceReward(type, cell),\r\n                items: this.generateRewardItems(type, cell),\r\n                unlocks: this.generateUnlocks(type, cell)\r\n            }\r\n        };\r\n\r\n        this._progress.discoveries.set(id, discovery);\r\n        return discovery;\r\n    }\r\n\r\n    /**\r\n     * Calculates the {@link ExplorationDifficulty} for a discovery based on cell attributes.\r\n     * @param cell - The {@link GridCell} where the discovery was made.\r\n     * @returns The calculated {@link ExplorationDifficulty}.\r\n     */\r\n    private calculateDifficulty(cell: GridCell): ExplorationDifficulty {\r\n        // Difficulty is a weighted sum of danger, travel cost, and inverse explorability.\r\n        const difficultyScore = \r\n            (cell.attributes.dangerLevel * 0.4) +\r\n            (cell.attributes.travelCost * 0.3) +\r\n            ((100 - cell.attributes.explorability) * 0.3);\r\n\r\n        // Map the score to an enumeration of difficulty levels.\r\n        if (difficultyScore >= 90) return ExplorationDifficulty.LEGENDARY;\r\n        if (difficultyScore >= 75) return ExplorationDifficulty.EXTREME;\r\n        if (difficultyScore >= 50) return ExplorationDifficulty.HARD;\r\n        if (difficultyScore >= 25) return ExplorationDifficulty.NORMAL;\r\n        return ExplorationDifficulty.EASY;\r\n    }\r\n\r\n    /**\r\n     * Calculates the experience reward for a discovery based on its type and the cell's difficulty.\r\n     * @param type - The {@link DiscoveryType}.\r\n     * @param cell - The {@link GridCell} of the discovery.\r\n     * @returns The calculated experience points.\r\n     */\r\n    private calculateExperienceReward(type: DiscoveryType, cell: GridCell): number {\r\n        // Base XP for each discovery type.\r\n        const baseXP = {\r\n            [DiscoveryType.LANDMARK]: 100,\r\n            [DiscoveryType.RESOURCE]: 50,\r\n            [DiscoveryType.SETTLEMENT]: 150,\r\n            [DiscoveryType.DUNGEON]: 200,\r\n            [DiscoveryType.ARTIFACT]: 250,\r\n            [DiscoveryType.SECRET]: 300\r\n        }[type];\r\n\r\n        // Difficulty multiplier for XP.\r\n        const difficultyMultiplier = {\r\n            [ExplorationDifficulty.EASY]: 1,\r\n            [ExplorationDifficulty.NORMAL]: 1.5,\r\n            [ExplorationDifficulty.HARD]: 2,\r\n            [ExplorationDifficulty.EXTREME]: 3,\r\n            [ExplorationDifficulty.LEGENDARY]: 5\r\n        }[this.calculateDifficulty(cell)];\r\n\r\n        return Math.floor(baseXP * difficultyMultiplier);\r\n    }\r\n\r\n    /**\r\n     * Generates reward items for a discovery.\r\n     * @param _type - The {@link DiscoveryType}.\r\n     * @param _cell - The {@link GridCell} of the discovery.\r\n     * @returns An array of item IDs to be rewarded.\r\n     * @todo Implement actual item generation logic based on discovery type and cell attributes.\r\n     */\r\n    private generateRewardItems(_type: DiscoveryType, _cell: GridCell): string[] {\r\n        // This would be implemented to generate appropriate rewards based on discovery type and cell attributes\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Generates unlocks (e.g., recipes, skills) for a discovery.\r\n     * @param _type - The {@link DiscoveryType}.\r\n     * @param _cell - The {@link GridCell} of the discovery.\r\n     * @returns An array of unlockable IDs.\r\n     * @todo Implement actual unlock generation logic based on discovery type and cell attributes.\r\n     */\r\n    private generateUnlocks(_type: DiscoveryType, _cell: GridCell): string[] {\r\n        // This would be implemented to generate appropriate unlocks based on discovery type and cell attributes\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Calculates exploration points gained from exploring a cell and making discoveries.\r\n     * @param cell - The {@link GridCell} explored.\r\n     * @param discoveries - An array of {@link Discovery} objects made in the cell.\r\n     * @returns The total exploration points gained.\r\n     */\r\n    private calculateExplorationPoints(cell: GridCell, discoveries: Discovery[]): number {\r\n        let points = cell.attributes.explorability; // Base points from cell's explorability.\r\n        // Add bonus points for each discovery made.\r\n        discoveries.forEach(discovery => {\r\n            points += {\r\n                [DiscoveryType.LANDMARK]: 50,\r\n                [DiscoveryType.RESOURCE]: 30,\r\n                [DiscoveryType.SETTLEMENT]: 100,\r\n                [DiscoveryType.DUNGEON]: 150,\r\n                [DiscoveryType.ARTIFACT]: 200,\r\n                [DiscoveryType.SECRET]: 250\r\n            }[discovery.type];\r\n        });\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Updates player skill levels based on new discoveries.\r\n     * @param discoveries - An array of {@link Discovery} objects made.\r\n     * @returns The updated map of skill levels.\r\n     */\r\n    private updateSkillLevels(discoveries: Discovery[]): Map<string, number> {\r\n        const _skillGains = new Map<string, number>(); // This variable is currently unused.\r\n        \r\n        discoveries.forEach(discovery => {\r\n            switch (discovery.type) {\r\n                case DiscoveryType.ARTIFACT:\r\n                    this.gainSkillExp('archaeology', 10);\r\n                    break;\r\n                case DiscoveryType.RESOURCE:\r\n                    this.gainSkillExp('naturalism', 10);\r\n                    break;\r\n                case DiscoveryType.DUNGEON:\r\n                    this.gainSkillExp('survival', 10);\r\n                    break;\r\n            }\r\n        });\r\n\r\n        return this._progress.skillLevels;\r\n    }\r\n\r\n    /**\r\n     * Awards experience to a specific exploration skill.\r\n     * @param skill - The name of the skill to gain experience for.\r\n     * @param amount - The amount of experience to award.\r\n     */\r\n    private gainSkillExp(skill: string, amount: number): void {\r\n        const currentLevel = this._progress.skillLevels.get(skill) || 1;\r\n        // Simplified experience gain: if amount >= expNeeded, level up.\r\n        // In a real system, this would involve tracking current XP within a level.\r\n        const expNeeded = Math.floor(100 * Math.pow(1.5, currentLevel - 1));\r\n        \r\n        if (amount >= expNeeded) {\r\n            this._progress.skillLevels.set(skill, currentLevel + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Counts how many of a cell's immediate neighbors have already been explored.\r\n     * @param position - The {@link GridPosition} of the cell.\r\n     * @returns The count of explored neighbors.\r\n     */\r\n    private getNeighborExploredCount(position: GridPosition): number {\r\n        let count = 0;\r\n        const neighbors = [\r\n            new GridPosition(position.x + 1, position.y),\r\n            new GridPosition(position.x - 1, position.y),\r\n            new GridPosition(position.x, position.y + 1),\r\n            new GridPosition(position.x, position.y - 1)\r\n        ];\r\n\r\n        neighbors.forEach(pos => {\r\n            if (this._progress.revealedCells.has(pos.toString())) {\r\n                count++;\r\n            }\r\n        });\r\n\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a copy of the current exploration progress.\r\n     * @returns A copy of the {@link ExplorationProgress} object.\r\n     */\r\n    getProgress(): ExplorationProgress {\r\n        return {\r\n            ...this._progress,\r\n            revealedCells: new Set(this._progress.revealedCells),\r\n            discoveries: new Map(this._progress.discoveries),\r\n            completedDiscoveries: new Set(this._progress.completedDiscoveries),\r\n            skillLevels: new Map(this._progress.skillLevels)\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Represents the result of an exploration attempt on a single grid cell.\r\n */\r\nexport interface ExplorationResult {\r\n    /** The type of result (e.g., 'success' if new discoveries were made, 'already_explored' if the cell was already known). */\r\n    type: 'success' | 'already_explored';\r\n    /** Optional: An array of {@link Discovery} objects made during this exploration. */\r\n    discoveries?: Discovery[];\r\n    /** Optional: The number of exploration points gained from this action. */\r\n    explorationPoints?: number;\r\n    /** Optional: The updated map of player skill levels if any skills gained experience. */\r\n    newSkillLevels?: Map<string, number>;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\game-time.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\grid-cell.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\inventory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\region.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\skill.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\terrain-definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\terrain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\weather.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\entities\\world.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\examples\\mod-effects.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Effect' is defined but never used.","line":1,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { Effect } from '../types/effects';\r\nimport { EffectType, EffectTarget, CustomEffectDefinition } from '../types/effects';\r\n\r\n// Example weather effect from a mod\r\nexport const RainstormEffect: CustomEffectDefinition = {\r\n    modId: 'weather_expansion',\r\n    name: { key: 'effects.rainstorm.name' },\r\n    description: { key: 'effects.rainstorm.description' },\r\n    type: EffectType.MODIFY_TERRAIN,\r\n    target: EffectTarget.AREA,\r\n    value: 1,\r\n    modifier: {\r\n        type: 'percentage',\r\n        value: 0.5\r\n    },\r\n    duration: 600, // 10 minutes in game time\r\n    tickRate: 10,\r\n    conditions: [\r\n        {\r\n            type: 'location',\r\n            operator: '!=',\r\n            value: 'indoor'\r\n        }\r\n    ],\r\n    visualEffect: 'rain_particles',\r\n    soundEffect: 'rain_ambient',\r\n    tags: ['weather', 'water', 'natural'],\r\n    \r\n    // Custom properties for the weather mod\r\n    customProperties: {\r\n        puddleFormation: true,\r\n        lightningChance: 0.1,\r\n        windSpeed: 20\r\n    }\r\n};\r\n\r\n// Example item effect from a mod\r\nexport const FrostbiteWeaponEffect: CustomEffectDefinition = {\r\n    modId: 'ice_weapons',\r\n    name: { key: 'effects.frostbite_weapon.name' },\r\n    description: { key: 'effects.frostbite_weapon.description' },\r\n    type: EffectType.CONDITIONAL,\r\n    target: EffectTarget.TARGET,\r\n    value: 10, // Base effect value\r\n    modifier: {\r\n        type: 'flat',\r\n        value: 1\r\n    },\r\n    triggerConditions: [\r\n        {\r\n            type: 'stat',\r\n            operator: '>',\r\n            value: 0,\r\n            target: 'hit_landed'\r\n        }\r\n    ],\r\n    triggeredEffects: [\r\n        {\r\n            id: 'frost_damage',\r\n            name: { key: 'effects.frost_damage.name' },\r\n            description: { key: 'effects.frost_damage.description' },\r\n            type: EffectType.DAMAGE_OVER_TIME,\r\n            target: EffectTarget.TARGET,\r\n            value: 5,\r\n            modifier: { type: 'flat', value: 1 },\r\n            duration: 30,\r\n            tickRate: 5,\r\n            stackable: true,\r\n            maxStacks: 3,\r\n            visualEffect: 'frost_particles',\r\n            tags: ['cold', 'damage', 'magical']\r\n        },\r\n        {\r\n            id: 'slow',\r\n            name: { key: 'effects.slow.name' },\r\n            description: { key: 'effects.slow.description' },\r\n            type: EffectType.MODIFY_MOVEMENT,\r\n            target: EffectTarget.TARGET,\r\n            value: 30,\r\n            modifier: { type: 'percentage', value: -0.3 },\r\n            duration: 15,\r\n            visualEffect: 'frost_feet',\r\n            tags: ['slow', 'movement', 'magical']\r\n        }\r\n    ],\r\n    tags: ['weapon', 'ice', 'magical']\r\n};\r\n\r\n// Example status effect from a mod\r\nexport const BerserkerEffect: CustomEffectDefinition = {\r\n    modId: 'warrior_classes',\r\n    name: { key: 'effects.berserker.name' },\r\n    description: { key: 'effects.berserker.description' },\r\n    type: EffectType.STATUS,\r\n    target: EffectTarget.SELF,\r\n    conditions: [\r\n        {\r\n            type: 'stat',\r\n            operator: '<',\r\n            value: 50,\r\n            target: 'health_percentage'\r\n        }\r\n    ],\r\n    value: 1,\r\n    modifier: {\r\n        type: 'percentage',\r\n        value: 0.5\r\n    },\r\n    triggeredEffects: [\r\n        {\r\n            id: 'increased_damage',\r\n            name: { key: 'effects.increased_damage.name' },\r\n            description: { key: 'effects.increased_damage.description' },\r\n            type: EffectType.BUFF,\r\n            target: EffectTarget.SELF,\r\n            value: 50,\r\n            modifier: { type: 'percentage', value: 0.5 },\r\n            duration: -1, // Permanent while berserker is active\r\n            tags: ['damage', 'combat']\r\n        },\r\n        {\r\n            id: 'reduced_defense',\r\n            name: { key: 'effects.reduced_defense.name' },\r\n            description: { key: 'effects.reduced_defense.description' },\r\n            type: EffectType.DEBUFF,\r\n            target: EffectTarget.SELF,\r\n            value: -25,\r\n            modifier: { type: 'percentage', value: -0.25 },\r\n            duration: -1,\r\n            tags: ['defense', 'combat']\r\n        }\r\n    ],\r\n    visualEffect: 'berserker_aura',\r\n    tags: ['status', 'combat', 'class_specific']\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\factories\\entity-factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\factories\\terrain-factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\generators\\world-generator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\repositories\\weather-repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\repositories\\world-repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\attributes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\game.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\player.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\skills.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\terrain-attributes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\terrain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\weather.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\world-attributes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\types\\world.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\usecases\\combat-usecase.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'defender' is defined but never used. Allowed unused args must match /^_/u.","line":103,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":103,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Combatant, CombatResult, CombatRound, CombatAction } from '../entities/combat';\r\n\r\nexport interface ICombatUseCase {\r\n    initiateCombat(attacker: Combatant, defender: Combatant): Promise<void>;\r\n    executeCombatRound(): Promise<CombatRound>;\r\n    endCombat(): Promise<CombatResult>;\r\n}\r\n\r\nexport class CombatUseCase implements ICombatUseCase {\r\n    private currentAttacker?: Combatant;\r\n    private currentDefender?: Combatant;\r\n    private rounds: CombatRound[] = [];\r\n\r\n    async initiateCombat(attacker: Combatant, defender: Combatant): Promise<void> {\r\n        this.currentAttacker = attacker;\r\n        this.currentDefender = defender;\r\n        this.rounds = [];\r\n    }\r\n\r\n    async executeCombatRound(): Promise<CombatRound> {\r\n        if (!this.currentAttacker || !this.currentDefender) {\r\n            throw new Error('Combat not initialized');\r\n        }\r\n\r\n        const round: CombatRound = {\r\n            actions: [],\r\n            results: new Map(),\r\n            effects: new Map()\r\n        };\r\n\r\n        // Process attacker's turn\r\n        const attackerAction = await this.determineAction(this.currentAttacker);\r\n        round.actions.push(attackerAction);\r\n        await this.executeAction(attackerAction, round);\r\n\r\n        if (!this.currentDefender.isDead()) {\r\n            // Process defender's turn\r\n            const defenderAction = await this.determineAction(this.currentDefender);\r\n            round.actions.push(defenderAction);\r\n            await this.executeAction(defenderAction, round);\r\n        }\r\n\r\n        // Update effects for both combatants\r\n        this.currentAttacker.updateEffects();\r\n        this.currentDefender.updateEffects();\r\n\r\n        this.rounds.push(round);\r\n        return round;\r\n    }\r\n\r\n    async endCombat(): Promise<CombatResult> {\r\n        if (!this.currentAttacker || !this.currentDefender) {\r\n            throw new Error('Combat not initialized');\r\n        }\r\n\r\n        const winner = this.currentAttacker.isDead() ? this.currentDefender : this.currentAttacker;\r\n        const loser = this.currentAttacker.isDead() ? this.currentAttacker : this.currentDefender;\r\n\r\n        return {\r\n            winner,\r\n            loser,\r\n            rounds: this.rounds,\r\n            experience: this.calculateExperience(winner, loser),\r\n            loot: await this.generateLoot(loser)\r\n        };\r\n    }\r\n\r\n    private async determineAction(combatant: Combatant): Promise<CombatAction> {\r\n        // This could be enhanced with AI decision making for NPCs/Monsters\r\n        // For now, just return a basic attack\r\n        return {\r\n            actor: combatant,\r\n            target: combatant === this.currentAttacker ? this.currentDefender! : this.currentAttacker!,\r\n            type: 'ATTACK'\r\n        };\r\n    }\r\n\r\n    private async executeAction(action: CombatAction, round: CombatRound): Promise<void> {\r\n        switch (action.type) {\r\n            case 'ATTACK': {\r\n                const damage = this.calculateDamage(action.actor, action.target);\r\n                const actualDamage = action.target.takeDamage(damage.amount);\r\n                round.results.set(action.target.id, {\r\n                    ...damage,\r\n                    amount: actualDamage\r\n                });\r\n                break;\r\n            }\r\n            case 'SKILL': {\r\n                if (!action.skill) throw new Error('Skill action requires a skill');\r\n                // Handle skill execution\r\n                break;\r\n            }\r\n            case 'DEFEND':\r\n                // Add defensive buffs\r\n                break;\r\n            case 'FLEE':\r\n                // Handle flee attempt\r\n                break;\r\n        }\r\n    }\r\n\r\n    private calculateDamage(attacker: Combatant, defender: Combatant) {\r\n        const base = attacker.stats.attack;\r\n        const isCritical = Math.random() < (attacker.stats.criticalChance || 0);\r\n        const critMult = isCritical ? (attacker.stats.criticalDamage || 1.5) : 1;\r\n        \r\n        return {\r\n            amount: Math.floor(base * critMult),\r\n            type: 'PHYSICAL' as const,\r\n            isCritical\r\n        };\r\n    }\r\n\r\n    private calculateExperience(_winner: Combatant, _loser: Combatant): number {\r\n        // Implement experience calculation logic\r\n        return 100; // Placeholder\r\n    }\r\n\r\n    private async generateLoot(_loser: Combatant): Promise<any[]> {\r\n        // Implement loot generation logic\r\n        return []; // Placeholder\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\usecases\\experience-usecase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\usecases\\exploration-usecase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\usecases\\skill-usecase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\usecases\\weather-usecase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\usecases\\world-usecase.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GridCell' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GridCellAttributes' is defined but never used.","line":12,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Enemy' is defined but never used.","line":16,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n// Minimal World interface for usecase compatibility (should be replaced with real implementation)\r\ninterface World {\r\n    getChunk(position: any): Chunk | undefined;\r\n    getChunksInArea(position: any, viewRadius: number): Chunk[];\r\n    getChunksByTerrain(terrainType: any): Chunk[];\r\n    update(): void;\r\n    getExploredPercentage(): number;\r\n    getRegion(regionId: number): any;\r\n}\r\nimport { GridPosition } from '../values/grid-position';\r\nimport { GridCell, GridCellAttributes } from '../entities/world';\r\nimport { TerrainType } from '../entities/terrain';\r\nimport { WorldGenerator } from '../generators/world-generator';\r\nimport { CreatureEngine } from '../engines/creature-engine';\r\nimport type { Enemy, Chunk } from '@/lib/game/types';\r\n\r\nexport interface IWorldUseCase {\r\n    generateWorld(config: WorldGenerationConfig): Promise<World>;\r\n    exploreChunk(position: GridPosition): Promise<Chunk>;\r\n    getVisibleChunks(position: GridPosition, viewRadius: number): Promise<Chunk[]>;\r\n    updateWorld(): Promise<void>;\r\n}\r\n\r\ninterface WorldGenerationConfig {\r\n    width: number;\r\n    height: number;\r\n    minRegionSize: number;\r\n    maxRegionSize: number;\r\n    terrainDistribution: Record<TerrainType, number>;\r\n}\r\n\r\nexport class WorldUseCase implements IWorldUseCase {\r\n    constructor(\r\n        private world: World,\r\n        private readonly worldGenerator: WorldGenerator,\r\n        private readonly worldRepository: any, // Will be defined in infrastructure\r\n        private readonly creatureEngine: CreatureEngine\r\n    ) {}\r\n\r\n    async generateWorld(_config: WorldGenerationConfig): Promise<World> {\r\n        // TODO: Replace with real World implementation\r\n        this.world = await this.worldGenerator.generateWorld() as unknown as World;\r\n        await this.worldRepository.save(this.world);\r\n        return this.world;\r\n    }\r\n\r\n    async exploreChunk(position: GridPosition): Promise<Chunk> {\r\n        const chunk = this.world.getChunk(position);\r\n        if (!chunk) {\r\n            throw new Error(`No chunk found at position ${position.toString()}`);\r\n        }\r\n\r\n        // Mark chunk as explored (using the explored property instead of markExplored method)\r\n        chunk.explored = true;\r\n\r\n        // Register creature if present in the chunk\r\n        if (chunk.enemy) {\r\n            const creatureId = `creature_${chunk.x}_${chunk.y}`;\r\n            this.creatureEngine.registerCreature(creatureId, chunk.enemy, position, chunk);\r\n        }\r\n\r\n        await this.worldRepository.save(this.world);\r\n        return chunk;\r\n    }\r\n\r\n    async getVisibleChunks(position: GridPosition, viewRadius: number): Promise<Chunk[]> {\r\n        return this.world.getChunksInArea(position, viewRadius);\r\n    }\r\n\r\n    async updateWorld(): Promise<void> {\r\n        this.world.update();\r\n        await this.worldRepository.save(this.world);\r\n    }\r\n\r\n    async getExploredPercentage(): Promise<number> {\r\n        return this.world.getExploredPercentage();\r\n    }\r\n\r\n    async getChunksByTerrain(terrainType: TerrainType): Promise<Chunk[]> {\r\n        return this.world.getChunksByTerrain(terrainType);\r\n    }\r\n\r\n    async getRegionInfo(position: GridPosition): Promise<{\r\n        regionId: number;\r\n        exploredPercentage: number;\r\n        dominantTerrain: TerrainType;\r\n    }> {\r\n        const chunk = this.world.getChunk(position);\r\n        if (!chunk) {\r\n            throw new Error(`No chunk found at position ${position.toString()}`);\r\n        }\r\n\r\n        const region = this.world.getRegion(chunk.regionId);\r\n        if (!region) {\r\n            throw new Error(`No region found with id ${chunk.regionId}`);\r\n        }\r\n\r\n        return {\r\n            regionId: region.id,\r\n            exploredPercentage: region.exploredPercentage,\r\n            dominantTerrain: region.dominantTerrain.type\r\n        };\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\values\\grid-position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\values\\position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\core\\values\\world-position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain-v2\\__tests__\\terrain.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain-v2\\defaults.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain-v2\\terrain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain-v2\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\__tests__\\terrain-features.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\__tests__\\terrain-loader.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\__tests__\\terrain-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\__tests__\\terrain.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\api\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\implementations\\terrain-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\implementations\\terrain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\game\\terrain\\services\\terrain-loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\game-lifecycle\\useGameEvents.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'currentSeason', 'customItemCatalog', 'customItemDefinitions', 'customStructures', 'language', 'playerPosition.x', 'playerPosition.y', 'regionCounter', 'regions', 'setRegionCounter', 'setRegions', 'setWorld', 'triggerRandomEvent', 'turnsSinceLastProactiveGen', 'world', and 'worldProfile'. Either include them or remove the dependency array.","line":191,"column":6,"nodeType":"ArrayExpression","endLine":191,"endColumn":34,"suggestions":[{"desc":"Update the dependencies array to be: [turn, isLoaded, isGameOver, turnsSinceLastProactiveGen, triggerRandomEvent, world, regions, regionCounter, playerPosition.x, playerPosition.y, worldProfile, currentSeason, customItemDefinitions, customItemCatalog, customStructures, language, setWorld, setRegions, setRegionCounter]","fix":{"range":[7617,7645],"text":"[turn, isLoaded, isGameOver, turnsSinceLastProactiveGen, triggerRandomEvent, world, regions, regionCounter, playerPosition.x, playerPosition.y, worldProfile, currentSeason, customItemDefinitions, customItemCatalog, customStructures, language, setWorld, setRegions, setRegionCounter]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\game-lifecycle\\useGameInitialization.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'inProgressKey' is assigned a value but never used.","line":63,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":289,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":17},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":302,"column":5,"nodeType":"CallExpression","endLine":308,"endColumn":7}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'addNarrativeEntry', 'deps', 'finalWorldSetup', 'gameSlot', 'gameStateRepository', 'language', 'setBuildableStructures', 'setCurrentSeason', 'setCustomItemCatalog', 'setCustomItemDefinitions', 'setCustomStructures', 'setDay', 'setFinalWorldSetup', 'setGameTime', 'setIsLoaded', 'setNarrativeLog', 'setPlayerBehaviorProfile', 'setPlayerPosition', 'setPlayerStats', 'setRecipes', 'setRegionCounter', 'setRegions', 'setTurn', 'setWeatherZones', 'setWorld', 'setWorldProfile', 't', and 'user?.uid'. Either include them or remove the dependency array.","line":301,"column":6,"nodeType":"ArrayExpression","endLine":309,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [addNarrativeEntry, deps, finalWorldSetup, gameSlot, gameStateRepository, language, setBuildableStructures, setCurrentSeason, setCustomItemCatalog, setCustomItemDefinitions, setCustomStructures, setDay, setFinalWorldSetup, setGameTime, setIsLoaded, setNarrativeLog, setPlayerBehaviorProfile, setPlayerPosition, setPlayerStats, setRecipes, setRegionCounter, setRegions, setTurn, setWeatherZones, setWorld, setWorldProfile, t, user?.uid]","fix":{"range":[14948,15300],"text":"[addNarrativeEntry, deps, finalWorldSetup, gameSlot, gameStateRepository, language, setBuildableStructures, setCurrentSeason, setCustomItemCatalog, setCustomItemDefinitions, setCustomStructures, setDay, setFinalWorldSetup, setGameTime, setIsLoaded, setNarrativeLog, setPlayerBehaviorProfile, setPlayerPosition, setPlayerStats, setRecipes, setRegionCounter, setRegions, setTurn, setWeatherZones, setWorld, setWorldProfile, t, user?.uid]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n'use client';\r\n\r\nimport { useEffect } from 'react';\r\nimport { useLanguage } from '@/context/language-context';\r\nimport { generateWeatherForZone, generateChunksInRadius } from '@/lib/game/engine/generation';\r\nimport { generateOfflineNarrative } from '@/lib/game/engine/offline';\r\nimport { recipes as staticRecipes } from '@/lib/game/recipes';\r\nimport { buildableStructures as staticBuildableStructures } from '@/lib/game/structures';\r\nimport { itemDefinitions as staticItemDefinitions } from '@/lib/game/items';\r\nimport type { IGameStateRepository } from '@/lib/game/ports/game-state.repository';\r\nimport type { GameState, PlayerStatusDefinition, WorldDefinition, GeneratedItem, Recipe, ItemDefinition } from '@/lib/game/types';\r\nimport { logger } from '@/lib/logger';\r\nimport { getTranslatedText, ensurePlayerItemId } from '@/lib/utils';\r\nimport { normalizePlayerStatus } from '@/lib/game/normalize';\r\nimport { useAuth } from '@/context/auth-context';\r\n\r\n\r\ntype GameInitializationDeps = {\r\n  setIsLoaded: (loaded: boolean) => void;\r\n  gameStateRepository: IGameStateRepository;\r\n  gameSlot: number;\r\n  finalWorldSetup: GameState['worldSetup'] | null;\r\n  setWorldProfile: (profile: GameState['worldProfile']) => void;\r\n  setCurrentSeason: (season: GameState['currentSeason']) => void;\r\n  setGameTime: (time: number) => void;\r\n  setDay: (day: number) => void;\r\n  setTurn: (turn: number) => void;\r\n  setWeatherZones: (zones: GameState['weatherZones']) => void;\r\n  setRecipes: (recipes: Record<string, Recipe>) => void;\r\n  setCustomItemCatalog: (catalog: GeneratedItem[]) => void;\r\n  setCustomItemDefinitions: (defs: Record<string, any>) => void;\r\n  setCustomStructures: (structures: GameState['customStructures']) => void;\r\n  setBuildableStructures: (structures: GameState['buildableStructures']) => void;\r\n  setPlayerStats: React.Dispatch<React.SetStateAction<PlayerStatusDefinition>>;\r\n  setFinalWorldSetup: React.Dispatch<React.SetStateAction<GameState['worldSetup'] | null>>;\r\n  setPlayerPosition: (pos: GameState['playerPosition']) => void;\r\n  setPlayerBehaviorProfile: (profile: GameState['playerBehaviorProfile']) => void;\r\n  setWorld: React.Dispatch<React.SetStateAction<WorldDefinition>>;\r\n  setRegions: (regions: GameState['regions']) => void;\r\n  setRegionCounter: (counter: number) => void;\r\n  setNarrativeLog: (log: GameState['narrativeLog']) => void;\r\n  addNarrativeEntry: (text: string, type: 'narrative' | 'action' | 'system' | 'monologue', entryId?: string) => void;\r\n};\r\n\r\nexport function useGameInitialization(deps: GameInitializationDeps) {\r\n  const {\r\n    setIsLoaded, gameStateRepository, gameSlot, finalWorldSetup,\r\n    setWorldProfile, setCurrentSeason, setGameTime, setDay, setTurn,\r\n    setWeatherZones, setRecipes, setCustomItemCatalog, setCustomItemDefinitions,\r\n    setCustomStructures, setBuildableStructures, setPlayerStats, setFinalWorldSetup,\r\n    setPlayerPosition, setPlayerBehaviorProfile, setWorld, setRegions,\r\n    setRegionCounter, setNarrativeLog, addNarrativeEntry\r\n  } = deps;\r\n\r\n  const { t, language } = useLanguage();\r\n  const { user } = useAuth();\r\n\r\n  // Prevent concurrent initialization for the same slot across remounts/StrictMode double-invoke.\r\n  // Module-level so it survives hook remounts and avoids overlapping heavy generation.\r\n  // Key: gameSlot\r\n  // Note: kept lightweight and only used in dev to avoid accidental production locking.\r\n  const inProgressKey = `game-init-inprogress-${gameSlot}`;\r\n\r\n  useEffect(() => {\r\n    logger.debug('[GameInit] useGameInitialization effect triggered', {\r\n      gameSlot,\r\n      finalWorldSetup,\r\n      user: user?.uid || null,\r\n      language: language\r\n    });\r\n\r\n    // Strict slot validation\r\n    if (typeof gameSlot !== 'number' || isNaN(gameSlot) || gameSlot < 0) {\r\n      logger.error('[GameInit] Invalid or missing gameSlot. Aborting initialization.', { gameSlot, deps });\r\n      setIsLoaded(false);\r\n      return;\r\n    }\r\n\r\n    let isMounted = true;\r\n    // track whether this effect instance registered the in-progress lock\r\n    let didRegister = false;\r\n\r\n    // module-scoped map to avoid duplicate work across mounts\r\n    // Use a property on globalThis to keep the symbol across HMR and module reloads in dev\r\n     \r\n    const globalAny = globalThis as any;\r\n    if (!globalAny.__gameInitInProgress) globalAny.__gameInitInProgress = new Set<number>();\r\n    const inProgressSet: Set<number> = globalAny.__gameInitInProgress;\r\n\r\n    if (inProgressSet.has(gameSlot)) {\r\n      logger.info(`[GameInit] Initialization for slot ${gameSlot} already in progress elsewhere ΓÇö skipping this instance.`);\r\n      // we still return a cleanup to set isMounted false\r\n      return () => {\r\n        isMounted = false;\r\n        logger.debug('[GameInit] useGameInitialization effect cleanup (unmount) - skipped start', { gameSlot });\r\n      };\r\n    }\r\n    const loadGame = async () => {\r\n      // register that we're doing work for this slot\r\n      inProgressSet.add(gameSlot);\r\n      didRegister = true;\r\n      setIsLoaded(false);\r\n      logger.info(`[GameInit] Starting to load game for slot ${gameSlot}.`);\r\n      logger.debug('[GameInit] Initial parameters', {\r\n        gameSlot,\r\n        finalWorldSetup,\r\n        user: user?.uid || null,\r\n        language: language\r\n      });\r\n\r\n      let loadedState: GameState | null = null;\r\n      try {\r\n        loadedState = await gameStateRepository.load(`slot_${gameSlot}`);\r\n        logger.debug('[GameInit] Loaded state from repository', loadedState);\r\n      } catch (error) {\r\n        logger.error('[GameInit] Failed to load game state', error);\r\n      }\r\n\r\n      if (!isMounted) {\r\n        logger.info(`[GameInit] Component unmounted during load for slot ${gameSlot}. Aborting.`);\r\n        // remove our registration so future mounts can try again\r\n        if (didRegister) inProgressSet.delete(gameSlot);\r\n        return;\r\n      }\r\n\r\n      const stateToInitialize = loadedState;\r\n\r\n      if (!stateToInitialize && !finalWorldSetup) {\r\n        logger.warn(`[GameInit] No loaded state and no finalWorldSetup for slot ${gameSlot}. Waiting for world creation.`, {\r\n          loadedState,\r\n          finalWorldSetup\r\n        });\r\n        if (isMounted) setIsLoaded(false);\r\n        return;\r\n      }\r\n\r\n      if (stateToInitialize) {\r\n        logger.info(`[GameInit] Initializing game state from loaded data for slot ${gameSlot}.`);\r\n        logger.debug('[GameInit] State to initialize', stateToInitialize);\r\n\r\n        const finalCatalogMap = new Map<string, GeneratedItem>();\r\n        // Preserve canonical ids when constructing the runtime item catalog.\r\n        // For static definitions the canonical key is the object key; for generated/custom\r\n        // items prefer any explicit `id` on the item, otherwise fall back to the English name.\r\n        Object.entries(staticItemDefinitions).forEach(([key, def]) => {\r\n          const defId = (def as any).id ?? key;\r\n          finalCatalogMap.set(defId, { ...(def as any), id: defId } as GeneratedItem);\r\n        });\r\n        (stateToInitialize.customItemCatalog || []).forEach(item => {\r\n          const itemId = (item as any).id ?? getTranslatedText(item.name, 'en');\r\n          if (itemId) finalCatalogMap.set(itemId, { ...(item as any), id: itemId } as GeneratedItem);\r\n        });\r\n\r\n        const finalCatalogArray: GeneratedItem[] = Array.from(finalCatalogMap.values());\r\n        const finalRecipes = { ...staticRecipes, ...(stateToInitialize.recipes || {}) };\r\n\r\n        const finalDefs = finalCatalogArray.reduce((acc, item) => {\r\n          const itemId = (item as any).id ?? getTranslatedText(item.name, 'en');\r\n          if (itemId) acc[itemId] = { ...(item as any), id: itemId } as ItemDefinition;\r\n          return acc;\r\n        }, {} as Record<string, ItemDefinition>);\r\n\r\n        setWorldProfile(stateToInitialize.worldProfile);\r\n        setCurrentSeason(stateToInitialize.currentSeason);\r\n        setGameTime(stateToInitialize.gameTime || 360);\r\n        setDay(stateToInitialize.day);\r\n        setTurn(stateToInitialize.turn || 1);\r\n        setWeatherZones(stateToInitialize.weatherZones || {});\r\n        setRecipes(finalRecipes);\r\n        setCustomItemCatalog(finalCatalogArray);\r\n        setCustomItemDefinitions(finalDefs);\r\n        setCustomStructures(stateToInitialize.customStructures || []);\r\n        setBuildableStructures(staticBuildableStructures);\r\n        // Normalize player stats and ensure each inventory item has a canonical id\r\n        const normalizedStats = normalizePlayerStatus(stateToInitialize.playerStats);\r\n        if (Array.isArray(normalizedStats.items) && normalizedStats.items.length > 0) {\r\n          normalizedStats.items = normalizedStats.items.map((it: any) => ensurePlayerItemId(it, finalDefs, t, language));\r\n        }\r\n        setPlayerStats(() => normalizedStats);\r\n        setFinalWorldSetup(() => stateToInitialize.worldSetup);\r\n        setPlayerPosition(stateToInitialize.playerPosition || { x: 0, y: 0 });\r\n        setPlayerBehaviorProfile(stateToInitialize.playerBehaviorProfile || { moves: 0, attacks: 0, crafts: 0, customActions: 0 });\r\n\r\n        let worldSnapshot: Record<string, any> = stateToInitialize.world || {};\r\n        let regionsSnapshot: Record<string, any> = stateToInitialize.regions || {};\r\n        let regionCounterSnapshot = stateToInitialize.regionCounter || 0;\r\n        let weatherZonesSnapshot = stateToInitialize.weatherZones || {};\r\n\r\n        const initialPosKey = `${stateToInitialize.playerPosition.x},${stateToInitialize.playerPosition.y}`;\r\n\r\n        if (Object.keys(worldSnapshot).length === 0) {\r\n          logger.info('[GameInit] World is empty, performing initial chunk generation.');\r\n          logger.debug('[GameInit] Generating chunks in radius', {\r\n            playerPosition: stateToInitialize.playerPosition,\r\n            worldProfile: stateToInitialize.worldProfile,\r\n            currentSeason: stateToInitialize.currentSeason\r\n          });\r\n          // Debug breakpoint: pause before heavy generation (set window.__DEBUG_BREAK = true in browser)\r\n          try { const { maybeDebug } = await import('@/lib/debug'); maybeDebug('useGameInitialization:before-generate'); } catch {}\r\n          const { world: newWorld, regions: newRegions, regionCounter: newRegionCounter } = generateChunksInRadius(\r\n            {}, {}, 0,\r\n            stateToInitialize.playerPosition.x,\r\n            stateToInitialize.playerPosition.y,\r\n            7, // Initial radius\r\n            stateToInitialize.worldProfile,\r\n            stateToInitialize.currentSeason,\r\n            finalDefs,\r\n            finalCatalogArray,\r\n            stateToInitialize.customStructures || [],\r\n            language\r\n          );\r\n          // Debug after generation\r\n          try { const { maybeDebug } = await import('@/lib/debug'); maybeDebug('useGameInitialization:after-generate'); } catch {}\r\n          worldSnapshot = newWorld;\r\n          regionsSnapshot = newRegions;\r\n          regionCounterSnapshot = newRegionCounter;\r\n        }\r\n\r\n        Object.keys(regionsSnapshot).filter(id => !weatherZonesSnapshot[id]).forEach(regionId => {\r\n          const region = regionsSnapshot[Number(regionId)];\r\n          if (region) {\r\n            const initialWeather = generateWeatherForZone(region.terrain, stateToInitialize!.currentSeason);\r\n            weatherZonesSnapshot[regionId] = {\r\n              id: regionId,\r\n              terrain: region.terrain,\r\n              currentWeather: initialWeather,\r\n              nextChangeTime: (stateToInitialize!.gameTime || 360) + Math.floor(Math.random() * (initialWeather.duration_range[1] - initialWeather.duration_range[0] + 1)) + initialWeather.duration_range[0] * 10\r\n            };\r\n            logger.debug('[GameInit] Generated weather for region', {\r\n              regionId,\r\n              initialWeather\r\n            });\r\n          }\r\n        });\r\n\r\n        setWorld(() => worldSnapshot);\r\n        setRegions(regionsSnapshot);\r\n        setRegionCounter(regionCounterSnapshot);\r\n        setWeatherZones(weatherZonesSnapshot);\r\n\r\n        if ((stateToInitialize.narrativeLog || []).length === 0) {\r\n          const startingChunk = worldSnapshot[initialPosKey];\r\n          if (startingChunk) {\r\n            const initialNarrative = getTranslatedText(stateToInitialize.worldSetup.initialNarrative, language, t);\r\n            const chunkDescription = generateOfflineNarrative(startingChunk, 'long', worldSnapshot, stateToInitialize.playerPosition, t, language);\r\n            addNarrativeEntry(`${initialNarrative}\\n\\n${chunkDescription}`, 'narrative');\r\n            logger.debug('[GameInit] Added initial narrative entry', {\r\n              initialNarrative,\r\n              chunkDescription\r\n            });\r\n          }\r\n        } else {\r\n          setNarrativeLog(stateToInitialize.narrativeLog);\r\n          logger.debug('[GameInit] Loaded narrative log', stateToInitialize.narrativeLog);\r\n        }\r\n\r\n    if (isMounted) setIsLoaded(true);\r\n  try { const { maybeDebug } = await import('@/lib/debug'); maybeDebug('useGameInitialization:setIsLoaded:true'); } catch {}\r\n        logger.info(`[GameInit] Game for slot ${gameSlot} is fully loaded and initialized.`);\r\n        logger.debug('[GameInit] Initialization complete', {\r\n          isLoaded: true,\r\n          finalWorldSetup: stateToInitialize.worldSetup\r\n        });\r\n\r\n      } else if (finalWorldSetup && isMounted) {\r\n        logger.info(`[GameInit] New game initiated with finalWorldSetup for slot ${gameSlot}.`);\r\n        setIsLoaded(true);\r\n        logger.debug('[GameInit] New game setup', {\r\n          isLoaded: true,\r\n          finalWorldSetup\r\n        });\r\n      }\r\n\r\n      // done with work for this slot\r\n      if (didRegister) inProgressSet.delete(gameSlot);\r\n    };\r\n\r\n    loadGame();\r\n\r\n    return () => {\r\n      isMounted = false;\r\n      // if this effect instance registered the in-progress marker, remove it so future mounts can proceed\r\n      try {\r\n        if (didRegister && inProgressSet && inProgressSet.has(gameSlot)) {\r\n          inProgressSet.delete(gameSlot);\r\n          logger.debug('[GameInit] Cleared in-progress marker during cleanup', { gameSlot });\r\n        }\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n      // include a short stack snippet to help identify what caused the unmount (useful while debugging)\r\n      const stack = (new Error().stack || '').split('\\n').slice(1, 6).map(s => s.trim());\r\n      logger.debug('[GameInit] useGameInitialization effect cleanup (unmount)', { gameSlot, stack });\r\n    };\r\n    // Use a single serialized dependency so the dependency array length is always 1. This avoids\r\n    // \"final argument to useEffect changed size\" errors when HMR or parent code changes the\r\n    // shape/identity of many values across renders. We still only trigger when meaningful inputs\r\n    // change (gameSlot, finalWorldSetup identity, repository type, language, user id).\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [\r\n    JSON.stringify({\r\n      gameSlot,\r\n      finalWorldSetupId: finalWorldSetup ? (finalWorldSetup as any).id || String(finalWorldSetup) : null,\r\n      repoType: (gameStateRepository && (gameStateRepository as any).constructor && (gameStateRepository as any).constructor.name) || null,\r\n      language,\r\n      userUid: user?.uid || null\r\n    })\r\n  ]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\game-lifecycle\\useGameSaving.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":97,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":23},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'deps', 'language', and 't'. Either include them or remove the dependency array.","line":108,"column":6,"nodeType":"ArrayExpression","endLine":114,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [isLoaded, isSaving, isGameOver, finalWorldSetup, gameStateRepository, gameSlot, worldProfile, currentSeason, world, recipes, buildableStructures, regions, regionCounter, playerPosition, playerBehaviorProfile, playerStats, narrativeLogRef, customItemDefinitions, customItemCatalog, customStructures, weatherZones, gameTime, day, turn, toast, setIsSaving, deps, t, language]","fix":{"range":[4846,5230],"text":"[isLoaded, isSaving, isGameOver, finalWorldSetup, gameStateRepository, gameSlot, worldProfile, currentSeason, world, recipes, buildableStructures, regions, regionCounter, playerPosition, playerBehaviorProfile, playerStats, narrativeLogRef, customItemDefinitions, customItemCatalog, customStructures, weatherZones, gameTime, day, turn, toast, setIsSaving, deps, t, language]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\"use client\";\r\n\r\nimport { useEffect } from 'react';\r\nimport { useLanguage } from '@/context/language-context';\r\nimport { itemDefinitions as staticItemDefinitions } from '@/lib/game/items';\r\nimport { ensurePlayerItemId } from '@/lib/utils';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport type { IGameStateRepository } from '@/lib/game/ports/game-state.repository';\r\nimport type { GameState } from \"@/lib/game/types\";\r\nimport { logger } from '@/lib/logger';\r\n\r\ntype GameSavingDeps = {\r\n  isLoaded: boolean;\r\n  isSaving: boolean;\r\n  isGameOver: boolean;\r\n  setIsSaving: (saving: boolean) => void;\r\n  gameStateRepository: IGameStateRepository;\r\n  gameSlot: number;\r\n  // All state slices that need to be saved\r\n  worldProfile: GameState['worldProfile'];\r\n  currentSeason: GameState['currentSeason'];\r\n  world: GameState['world'];\r\n  recipes: GameState['recipes'];\r\n  buildableStructures: GameState['buildableStructures'];\r\n  regions: GameState['regions'];\r\n  regionCounter: GameState['regionCounter'];\r\n  playerPosition: GameState['playerPosition'];\r\n  playerBehaviorProfile: GameState['playerBehaviorProfile'];\r\n  playerStats: GameState['playerStats'];\r\n  narrativeLogRef: React.RefObject<GameState['narrativeLog']>;\r\n  finalWorldSetup: GameState['worldSetup'] | null;\r\n  customItemDefinitions: GameState['customItemDefinitions'];\r\n  customItemCatalog: GameState['customItemCatalog'];\r\n  customStructures: GameState['customStructures'];\r\n  weatherZones: GameState['weatherZones'];\r\n  gameTime: GameState['gameTime'];\r\n  day: GameState['day'];\r\n  turn: GameState['turn'];\r\n  setPlayerStats?: (updater: any) => void;\r\n};\r\n\r\nexport function useGameSaving(deps: GameSavingDeps) {\r\n  const {\r\n    isLoaded, isSaving, isGameOver, setIsSaving, gameStateRepository, gameSlot,\r\n    worldProfile, currentSeason, world, recipes, buildableStructures, regions,\r\n    regionCounter, playerPosition, playerBehaviorProfile, playerStats,\r\n    narrativeLogRef, finalWorldSetup, customItemDefinitions, customItemCatalog,\r\n    customStructures, weatherZones, gameTime, day, turn,\r\n  } = deps;\r\n\r\n  const { toast } = useToast();\r\n  const { t, language } = useLanguage();\r\n\r\n  useEffect(() => {\r\n    if (!isLoaded || isSaving || isGameOver || !finalWorldSetup) return;\r\n\r\n    const gameState: GameState = {\r\n        worldProfile, currentSeason, world, recipes, buildableStructures,\r\n        regions, regionCounter, playerPosition, playerBehaviorProfile,\r\n        playerStats, narrativeLog: narrativeLogRef.current!, worldSetup: finalWorldSetup,\r\n        customItemDefinitions, customItemCatalog, customStructures, weatherZones, gameTime, day,\r\n        turn,\r\n    };\r\n\r\n    const save = async () => {\r\n        setIsSaving(true);\r\n        try {\r\n            // Normalize player item ids against the full registry (core + custom) before saving\r\n            try {\r\n              const mergedDefs = { ...staticItemDefinitions, ...(customItemDefinitions || {}) };\r\n              if (gameState.playerStats && Array.isArray(gameState.playerStats.items)) {\r\n                const normalizedItems = gameState.playerStats.items.map((it: any) => {\r\n                  const before = (it && it.id) ? String(it.id) : undefined;\r\n                  const normalized = ensurePlayerItemId(it, mergedDefs, t, language);\r\n                  const after = (normalized && (normalized as any).id) ? (normalized as any).id : undefined;\r\n                  if (process.env.NODE_ENV !== 'production' && before !== after) {\r\n                    logger.debug('[GameSaving] Normalized player item id', { before, after, item: normalized });\r\n                  }\r\n                  return normalized;\r\n                });\r\n                // Update the state object and (optionally) in-memory playerStats if caller provided setter\r\n                gameState.playerStats = { ...gameState.playerStats, items: normalizedItems } as any;\r\n                if (typeof deps.setPlayerStats === 'function') {\r\n                  try {\r\n                    deps.setPlayerStats((prev: any) => ({ ...prev, items: normalizedItems }));\r\n                  } catch (e) {\r\n                    logger.debug('[GameSaving] Failed to update in-memory playerStats after normalization', e);\r\n                  }\r\n                }\r\n              }\r\n            } catch (e) {\r\n              logger.warn('[GameSaving] Failed to normalize player items before save', e);\r\n            }\r\n\r\n            await gameStateRepository.save(`slot_${gameSlot}`, gameState);\r\n        } catch (error) {\r\n            toast({ title: \"Save Error\", description: \"Could not save your progress.\", variant: \"destructive\"});\r\n        } finally {\r\n            setIsSaving(false);\r\n        }\r\n    };\r\n    \r\n    // Debounce saving to avoid rapid writes\r\n    const timerId = setTimeout(save, 1500); \r\n    return () => clearTimeout(timerId);\r\n\r\n  }, [\r\n    isLoaded, isSaving, isGameOver, finalWorldSetup, gameStateRepository, gameSlot,\r\n    worldProfile, currentSeason, world, recipes, buildableStructures, regions, regionCounter,\r\n    playerPosition, playerBehaviorProfile, playerStats, narrativeLogRef,\r\n    customItemDefinitions, customItemCatalog, customStructures, weatherZones, gameTime, day, turn,\r\n    toast, setIsSaving\r\n  ]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\game-lifecycle\\usePlayerProgression.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":31,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":13},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'playerStats.unlockProgress'. Either include it or remove the dependency array.","line":59,"column":6,"nodeType":"ArrayExpression","endLine":59,"endColumn":190,"suggestions":[{"desc":"Update the dependencies array to be: [playerStats.unlockProgress.kills, playerStats.unlockProgress.damageSpells, playerStats.unlockProgress.moves, isLoaded, playerStats.skills, setPlayerStats, t, addNarrativeEntry, toast, playerStats.unlockProgress]","fix":{"range":[2494,2678],"text":"[playerStats.unlockProgress.kills, playerStats.unlockProgress.damageSpells, playerStats.unlockProgress.moves, isLoaded, playerStats.skills, setPlayerStats, t, addNarrativeEntry, toast, playerStats.unlockProgress]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'playerBehaviorProfile'. Either include it or remove the dependency array.","line":84,"column":6,"nodeType":"ArrayExpression","endLine":84,"endColumn":172,"suggestions":[{"desc":"Update the dependencies array to be: [playerBehaviorProfile.moves, playerBehaviorProfile.attacks, playerBehaviorProfile.crafts, isLoaded, playerStats.persona, setPlayerStats, addNarrativeEntry, t, toast, playerBehaviorProfile]","fix":{"range":[3880,4046],"text":"[playerBehaviorProfile.moves, playerBehaviorProfile.attacks, playerBehaviorProfile.crafts, isLoaded, playerStats.persona, setPlayerStats, addNarrativeEntry, t, toast, playerBehaviorProfile]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":111,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":122,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'language'. Either include it or remove the dependency array.","line":125,"column":6,"nodeType":"ArrayExpression","endLine":125,"endColumn":102,"suggestions":[{"desc":"Update the dependencies array to be: [isLoaded, playerStats.stamina, playerStats.hunger, world, playerPosition, addNarrativeEntry, t, language]","fix":{"range":[5731,5827],"text":"[isLoaded, playerStats.stamina, playerStats.hunger, world, playerPosition, addNarrativeEntry, t, language]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n'use client';\r\n\r\nimport { useEffect, useRef } from 'react';\r\nimport { getKeywordVariations } from '@/lib/game/data/narrative-templates';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useLanguage } from '@/context/language-context';\r\nimport { skillDefinitions } from '@/lib/game/skills';\r\nimport type { PlayerStatus, PlayerBehaviorProfile, PlayerPersona } from \"@/lib/game/types\";\r\nimport type { TranslationKey } from \"@/lib/i18n\";\r\n\r\ntype PlayerProgressionDeps = {\r\n  isLoaded: boolean;\r\n  playerStats: PlayerStatus;\r\n  setPlayerStats: (fn: (prev: PlayerStatus) => PlayerStatus) => void;\r\n  playerBehaviorProfile: PlayerBehaviorProfile;\r\n  addNarrativeEntry: (text: string, type: 'narrative' | 'action' | 'system' | 'monologue', entryId?: string) => void;\r\n  // optional world + position to allow biome-aware monologue selection\r\n  world?: any;\r\n  playerPosition?: { x: number, y: number };\r\n};\r\n\r\nexport function usePlayerProgression(deps: PlayerProgressionDeps) {\r\n  const { isLoaded, playerStats, setPlayerStats, playerBehaviorProfile, addNarrativeEntry, world, playerPosition } = deps;\r\n  const { t, language } = useLanguage();\r\n  const { toast } = useToast();\r\n  const lastMonologueAt = useRef(0);\r\n  // small helper to pick a monologue line: prefer biome-specific pool, fallback to generic tired pool\r\n  try {\r\n    /* noop to keep lint happy; actual selection below inside effect */\r\n  } catch (e) {}\r\n\r\n  // EFFECT: Check for skill unlocks based on player's actions.\r\n  useEffect(() => {\r\n    if (!isLoaded) return;\r\n    const currentSkillNames = new Set(playerStats.skills.map(s => s.name));\r\n\r\n    const newlyUnlockedSkills = skillDefinitions.filter(skillDef => {\r\n        if (currentSkillNames.has(skillDef.name) || !skillDef.unlockCondition) return false;\r\n  const progress = (playerStats.unlockProgress as any)[skillDef.unlockCondition.type] ?? 0;\r\n  return progress >= skillDef.unlockCondition.count;\r\n    });\r\n\r\n    if (newlyUnlockedSkills.length > 0) {\r\n        setPlayerStats(prev => ({\r\n            ...prev,\r\n            skills: [...prev.skills, ...newlyUnlockedSkills]\r\n        }));\r\n        \r\n        newlyUnlockedSkills.forEach(skill => {\r\n            const skillName = t(skill.name as TranslationKey);\r\n            addNarrativeEntry(t('skillUnlocked', { skillName }), 'system');\r\n            toast({\r\n                title: t('skillUnlockedTitle'),\r\n                description: t('skillUnlockedDesc', { skillName })\r\n            });\r\n        });\r\n    }\r\n  }, [playerStats.unlockProgress.kills, playerStats.unlockProgress.damageSpells, playerStats.unlockProgress.moves, isLoaded, playerStats.skills, setPlayerStats, t, addNarrativeEntry, toast]);\r\n\r\n  // EFFECT: Update player persona based on behavior profile.\r\n  useEffect(() => {\r\n    if (!isLoaded) return;\r\n    const { moves, attacks, crafts } = playerBehaviorProfile;\r\n    const totalActions = moves + attacks + crafts;\r\n    \r\n    if (totalActions < 20) return;\r\n\r\n    let newPersona: PlayerPersona = playerStats.persona;\r\n    const movePercentage = moves / totalActions;\r\n    const attackPercentage = attacks / totalActions;\r\n    const craftPercentage = crafts / totalActions;\r\n    \r\n    if (movePercentage > 0.6 && newPersona !== 'explorer') newPersona = 'explorer';\r\n    else if (attackPercentage > 0.6 && newPersona !== 'warrior') newPersona = 'warrior';\r\n    else if (craftPercentage > 0.5 && newPersona !== 'artisan') newPersona = 'artisan';\r\n\r\n    if (newPersona !== playerStats.persona) {\r\n        setPlayerStats(prev => ({ ...prev, persona: newPersona }));\r\n        const messageKey = newPersona === 'explorer' ? 'personaExplorer' : newPersona === 'warrior' ? 'personaWarrior' : 'personaArtisan';\r\n        addNarrativeEntry(t(messageKey as TranslationKey), 'system');\r\n        toast({ title: t('personaUnlockedTitle'), description: t(messageKey as TranslationKey) });\r\n    }\r\n  }, [playerBehaviorProfile.moves, playerBehaviorProfile.attacks, playerBehaviorProfile.crafts, isLoaded, playerStats.persona, setPlayerStats, addNarrativeEntry, t, toast]);\r\n\r\n  // EFFECT: Emit a short monologue/self-talk when player is exhausted or hungry.\r\n  useEffect(() => {\r\n    if (!isLoaded) return;\r\n    try {\r\n      const stamina = playerStats.stamina ?? 100;\r\n      const hunger = playerStats.hunger ?? 100;\r\n      // thresholds: stamina low OR hunger low\r\n      const thresholdMet = (stamina < 20) || (hunger < 20);\r\n      const now = Date.now();\r\n      // cooldown: avoid spamming monologues more often than once per 30s\r\n      if (!thresholdMet) return;\r\n      if (now - lastMonologueAt.current < 30_000) return;\r\n\r\n      // determine biome-specific pool key if we can\r\n      let biomeKey = 'monologue_tired';\r\n      try {\r\n        if (world && playerPosition) {\r\n          const chunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n          if (chunk && chunk.terrain) {\r\n            const candidate = `${String(chunk.terrain).toLowerCase()}_monologue`;\r\n            // check presence in keyword db\r\n            const db = getKeywordVariations(language as any);\r\n            if ((db as any)[candidate] && Array.isArray((db as any)[candidate]) && (db as any)[candidate].length > 0) biomeKey = candidate;\r\n          }\r\n        }\r\n      } catch (e) {\r\n        // fallback to monologue_tired\r\n        biomeKey = 'monologue_tired';\r\n      }\r\n\r\n  const db = getKeywordVariations(language as any);\r\n      const pool: string[] = (db as any)[biomeKey] || (db as any)['monologue_tired'] || [];\r\n      if (!pool || pool.length === 0) return;\r\n      const choice = pool[Math.floor(Math.random() * pool.length)];\r\n      addNarrativeEntry(choice, 'monologue');\r\n      lastMonologueAt.current = now;\r\n    } catch (e) {\r\n      // ignore\r\n    }\r\n  }, [isLoaded, playerStats.stamina, playerStats.hunger, world, playerPosition, addNarrativeEntry, t]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\game-lifecycle\\useWorldRendering.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'sDayDuration' and 'sStart'. Either include them or remove the dependency array.","line":51,"column":6,"nodeType":"ArrayExpression","endLine":51,"endColumn":80,"suggestions":[{"desc":"Update the dependencies array to be: [world, playerPosition, gameTime, weatherZones, isLoaded, setCurrentChunk, sStart, sDayDuration]","fix":{"range":[1814,1888],"text":"[world, playerPosition, gameTime, weatherZones, isLoaded, setCurrentChunk, sStart, sDayDuration]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n'use client';\r\n\r\nimport { useEffect } from 'react';\r\nimport { getEffectiveChunk } from '@/lib/game/engine/generation';\r\nimport { useSettings } from '@/context/settings-context';\r\nimport type { GameState, Chunk } from \"@/lib/game/types\";\r\n\r\n/**\r\n * @typedef {object} WorldRenderingDeps\r\n * Dependencies for the useWorldRendering hook.\r\n */\r\ntype WorldRenderingDeps = {\r\n  isLoaded: boolean;\r\n  world: GameState['world'];\r\n  playerPosition: GameState['playerPosition'];\r\n  weatherZones: GameState['weatherZones'];\r\n  gameTime: number;\r\n  setCurrentChunk: (chunk: Chunk | null) => void;\r\n};\r\n\r\n/**\r\n * Manages the calculation of the \"effective\" chunk based on environmental factors.\r\n * This hook is responsible for taking the base chunk data and applying dynamic\r\n * modifiers like weather and time of day to produce the final, \"effective\" chunk that the\r\n* player actually experiences and that the narrative is based on.\r\n *\r\n * @param {WorldRenderingDeps} deps - The dependencies required for rendering the world state.\r\n */\r\nexport function useWorldRendering(deps: WorldRenderingDeps) {\r\n  const {\r\n    isLoaded, world, playerPosition, weatherZones, gameTime, setCurrentChunk\r\n  } = deps;\r\n\r\n  const { settings } = useSettings();\r\n  const sStart = (settings as any).startTime ?? 0;\r\n  const sDayDuration = (settings as any).dayDuration ?? 24000;\r\n\r\n  // EFFECT: Update the visual representation of the current chunk whenever the environment changes.\r\n  useEffect(() => {\r\n    if (!isLoaded) return;\r\n    \r\n    const baseChunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n    if (baseChunk) {\r\n  const newEffectiveChunk = getEffectiveChunk(baseChunk, weatherZones, gameTime, sStart, sDayDuration);\r\n        setCurrentChunk(newEffectiveChunk);\r\n    } else {\r\n        setCurrentChunk(null);\r\n    }\r\n  }, [world, playerPosition, gameTime, weatherZones, isLoaded, setCurrentChunk]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-action-handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'itemDefinitions' is defined but never used.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'buildNarrative' is defined but never used.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'itemName' is defined but never used. Allowed unused args must match /^_/u.","line":113,"column":76,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":84},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'kind' is assigned a value but never used.","line":117,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalCount' is assigned a value but never used.","line":134,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":150,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":176,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":19},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'resolveItemDef', 'sDayDuration', and 'sStart'. Either include them or remove the dependency array.","line":311,"column":8,"nodeType":"ArrayExpression","endLine":311,"endColumn":296,"suggestions":[{"desc":"Update the dependencies array to be: [setIsLoading, finalWorldSetup, settings.diceType, settings.narrativeLength, settings.aiModel, addNarrativeEntry, t, weatherZones, gameTime, sStart, sDayDuration, narrativeLogRef, language, customItemDefinitions, setWorld, setPlayerStats, advanceGameTime, resolveItemDef, setCustomItemCatalog, setCustomItemDefinitions, toast]","fix":{"range":[17203,17491],"text":"[setIsLoading, finalWorldSetup, settings.diceType, settings.narrativeLength, settings.aiModel, addNarrativeEntry, t, weatherZones, gameTime, sStart, sDayDuration, narrativeLogRef, language, customItemDefinitions, setWorld, setPlayerStats, advanceGameTime, resolveItemDef, setCustomItemCatalog, setCustomItemDefinitions, toast]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'resolveItemDef', 'sDayDuration', and 'sStart'. Either include them or remove the dependency array.","line":406,"column":8,"nodeType":"ArrayExpression","endLine":406,"endColumn":185,"suggestions":[{"desc":"Update the dependencies array to be: [playerPosition, world, weatherZones, gameTime, sStart, sDayDuration, settings.diceType, addNarrativeEntry, t, playerStats, language, setWorld, setPlayerStats, advanceGameTime, resolveItemDef]","fix":{"range":[22539,22716],"text":"[playerPosition, world, weatherZones, gameTime, sStart, sDayDuration, settings.diceType, addNarrativeEntry, t, playerStats, language, setWorld, setPlayerStats, advanceGameTime, resolveItemDef]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'resolveItemDef' and 'turn'. Either include them or remove the dependency array.","line":577,"column":8,"nodeType":"ArrayExpression","endLine":577,"endColumn":142,"suggestions":[{"desc":"Update the dependencies array to be: [resolveItemDef, playerStats, playerPosition.x, playerPosition.y, world, t, language, addNarrativeEntry, setPlayerStats, advanceGameTime, turn, setWorld]","fix":{"range":[32086,32220],"text":"[resolveItemDef, playerStats, playerPosition.x, playerPosition.y, world, t, language, addNarrativeEntry, setPlayerStats, advanceGameTime, turn, setWorld]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":801,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":801,"endColumn":21},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'flushPickupBuffer', 'resolveItemDef', 'sDayDuration', 'sStart', and 'worldProfile'. Either include them or remove the dependency array.","line":866,"column":8,"nodeType":"ArrayExpression","endLine":866,"endColumn":179,"suggestions":[{"desc":"Update the dependencies array to be: [playerStats, t, world, playerPosition.x, playerPosition.y, setPlayerStats, advanceGameTime, turn, addNarrativeEntry, language, toast, customItemDefinitions, resolveItemDef, worldProfile, setWorld, flushPickupBuffer, weatherZones, gameTime, sStart, sDayDuration]","fix":{"range":[50909,51080],"text":"[playerStats, t, world, playerPosition.x, playerPosition.y, setPlayerStats, advanceGameTime, turn, addNarrativeEntry, language, toast, customItemDefinitions, resolveItemDef, worldProfile, setWorld, flushPickupBuffer, weatherZones, gameTime, sStart, sDayDuration]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'resolveItemDef'. Either include it or remove the dependency array.","line":959,"column":8,"nodeType":"ArrayExpression","endLine":959,"endColumn":155,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, isGameOver, setPlayerBehaviorProfile, t, addNarrativeEntry, playerStats, setPlayerStats, advanceGameTime, toast, resolveItemDef]","fix":{"range":[56570,56717],"text":"[isLoading, isGameOver, setPlayerBehaviorProfile, t, addNarrativeEntry, playerStats, setPlayerStats, advanceGameTime, toast, resolveItemDef]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'resolveItemDef', 'sDayDuration', and 'sStart'. Either include them or remove the dependency array.","line":1132,"column":6,"nodeType":"ArrayExpression","endLine":1132,"endColumn":265,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, isGameOver, setIsLoading, world, playerPosition.x, playerPosition.y, weatherZones, gameTime, sStart, sDayDuration, playerStats, t, addNarrativeEntry, setPlayerStats, language, customItemDefinitions, customItemCatalog, advanceGameTime, resolveItemDef, setCustomItemCatalog, setCustomItemDefinitions, toast]","fix":{"range":[66493,66752],"text":"[isLoading, isGameOver, setIsLoading, world, playerPosition.x, playerPosition.y, weatherZones, gameTime, sStart, sDayDuration, playerStats, t, addNarrativeEntry, setPlayerStats, language, customItemDefinitions, customItemCatalog, advanceGameTime, resolveItemDef, setCustomItemCatalog, setCustomItemDefinitions, toast]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'language', 'resolveItemDef', and 't'. Either include them or remove the dependency array.","line":1197,"column":6,"nodeType":"ArrayExpression","endLine":1197,"endColumn":68,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, isGameOver, setPlayerStats, resolveItemDef, customItemDefinitions, t, language]","fix":{"range":[70081,70143],"text":"[isLoading, isGameOver, setPlayerStats, resolveItemDef, customItemDefinitions, t, language]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'language', 'resolveItemDef', and 't'. Either include them or remove the dependency array.","line":1236,"column":6,"nodeType":"ArrayExpression","endLine":1236,"endColumn":68,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, isGameOver, setPlayerStats, resolveItemDef, customItemDefinitions, t, language]","fix":{"range":[72214,72276],"text":"[isLoading, isGameOver, setPlayerStats, resolveItemDef, customItemDefinitions, t, language]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'language' and 'resolveItemDef'. Either include them or remove the dependency array.","line":1316,"column":8,"nodeType":"ArrayExpression","endLine":1316,"endColumn":172,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, isGameOver, isLoaded, world, playerPosition.x, playerPosition.y, playerStats, t, addNarrativeEntry, setPlayerStats, advanceGameTime, toast, resolveItemDef, customItemDefinitions, language, setWorld]","fix":{"range":[75803,75967],"text":"[isLoading, isGameOver, isLoaded, world, playerPosition.x, playerPosition.y, playerStats, t, addNarrativeEntry, setPlayerStats, advanceGameTime, toast, resolveItemDef, customItemDefinitions, language, setWorld]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1442,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":1442,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1484,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":1484,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1499,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":1499,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1502,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":1502,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":1526,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":1526,"endColumn":35},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'narrativeLogRef'. Either include it or remove the dependency array.","line":1558,"column":8,"nodeType":"ArrayExpression","endLine":1558,"endColumn":187,"suggestions":[{"desc":"Update the dependencies array to be: [isLoading, isGameOver, playerPosition, world, playerStats, setPlayerBehaviorProfile, t, addNarrativeEntry, settings.narrativeLength, setPlayerPosition, advanceGameTime, language, narrativeLogRef]","fix":{"range":[90132,90311],"text":"[isLoading, isGameOver, playerPosition, world, playerStats, setPlayerBehaviorProfile, t, addNarrativeEntry, settings.narrativeLength, setPlayerPosition, advanceGameTime, language, narrativeLogRef]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\n'use client';\r\n// NOTE: react-hooks/exhaustive-deps is being audited. Removed the file-level disable\r\n// so ESLint can report missing/unnecessary deps per-hook. We'll fix each hook's deps in small commits.\r\n\r\nimport { useCallback, useEffect, useRef } from 'react';\r\nimport { useToast } from '@/hooks/use-toast';\r\nimport { useLanguage } from '@/context/language-context';\r\nimport { useSettings } from '@/context/settings-context';\r\nimport { generateNarrative, type GenerateNarrativeInput } from '@/ai/flows/generate-narrative-flow';\r\nimport { fuseItems } from '@/ai/flows/fuse-items-flow';\r\nimport { provideQuestHint } from '@/ai/flows/provide-quest-hint';\r\nimport { rollDice, getSuccessLevel, successLevelToTranslationKey } from '@/lib/game/dice';\r\nimport { itemDefinitions } from '@/lib/game/items';\r\nimport { resolveItemDef as resolveItemDefHelper } from '@/lib/game/item-utils';\r\nimport { generateOfflineNarrative, generateOfflineActionNarrative, handleSearchAction } from '@/lib/game/engine/offline';\r\nimport { getEffectiveChunk } from '@/lib/game/engine/generation';\r\nimport { analyze_chunk_mood } from '@/lib/game/engine/offline';\r\nimport { useAudio } from '@/lib/audio/useAudio';\r\nimport { getTemplates } from '@/lib/game/templates';\r\nimport { clamp, getTranslatedText, resolveItemId, ensurePlayerItemId } from '@/lib/utils';\r\nimport { getKeywordVariations } from '@/lib/game/data/narrative-templates';\r\nimport { buildNarrative } from '@/lib/narrative/assembler';\r\nimport type { GameState, World, PlayerStatus, Recipe, CraftingOutcome, EquipmentSlot, Action, TranslationKey, PlayerItem, ItemEffect, ChunkItem, NarrativeEntry, GeneratedItem, TranslatableString, ItemDefinition, Chunk, Enemy } from '@/lib/game/types';\r\nimport { doc, setDoc } from 'firebase/firestore';\r\nimport { db } from '@/lib/firebase-config';\r\nimport { logger } from '@/lib/logger';\r\n\r\ntype ActionHandlerDeps = {\r\n  isLoaded: boolean;\r\n  isLoading: boolean;\r\n  isGameOver: boolean;\r\n  setIsLoading: (loading: boolean) => void;\r\n    playerStats: PlayerStatus;\r\n    setPlayerStats: React.Dispatch<React.SetStateAction<PlayerStatus>>;\r\n    world: World;\r\n    setWorld: React.Dispatch<React.SetStateAction<World>>;\r\n    recipes: Record<string, Recipe>;\r\n    buildableStructures: Record<string, any>;\r\n    customItemDefinitions: Record<string, ItemDefinition>;\r\n    setCustomItemCatalog: React.Dispatch<React.SetStateAction<GeneratedItem[]>>;\r\n    setCustomItemDefinitions: React.Dispatch<React.SetStateAction<Record<string, ItemDefinition>>>;\r\n  finalWorldSetup: GameState['worldSetup'] | null;\r\n    addNarrativeEntry: (text: string, type: 'narrative' | 'action' | 'system' | 'monologue', entryId?: string) => void;\r\n  advanceGameTime: (stats?: PlayerStatus, pos?: { x: number, y: number }) => void;\r\n  setPlayerBehaviorProfile: (fn: (prev: any) => any) => void;\r\n  playerPosition: { x: number, y: number };\r\n  setPlayerPosition: (pos: { x: number, y: number }) => void;\r\n  weatherZones: Record<string, any>;\r\n  turn: number;\r\n  gameTime: number;\r\n  regions: GameState['regions'];\r\n  setRegions: (regions: GameState['regions']) => void;\r\n  regionCounter: number;\r\n  setRegionCounter: (counter: number) => void;\r\n  worldProfile: GameState['worldProfile'];\r\n  currentSeason: GameState['currentSeason'];\r\n  customItemCatalog: GameState['customItemCatalog'];\r\n  customStructures: GameState['customStructures'];\r\n  narrativeLogRef: React.RefObject<NarrativeEntry[]>;\r\n};\r\n\r\nexport function useActionHandlers(deps: ActionHandlerDeps) {\r\n    const {\r\n        isLoaded, isLoading, isGameOver, setIsLoading, playerStats, setPlayerStats, world, setWorld, buildableStructures,\r\n            customItemDefinitions, setCustomItemCatalog, setCustomItemDefinitions, finalWorldSetup, addNarrativeEntry, advanceGameTime,\r\n            setPlayerBehaviorProfile, playerPosition, setPlayerPosition, weatherZones, turn, gameTime, customItemCatalog, narrativeLogRef\r\n    } = deps;\r\n    // worldProfile contains global spawn/config modifiers (e.g., spawnMultiplier)\r\n    const { worldProfile } = deps;\r\n\r\n    // Helper to resolve an item definition by name. Prefer custom/generated definitions\r\n    // (world-specific), but fall back to the built-in master item catalog when needed.\r\n    const resolveItemDef = (name: string) => {\r\n        return resolveItemDefHelper(name, customItemDefinitions);\r\n    };\r\n\r\n  const { t, language } = useLanguage();\r\n  const { settings } = useSettings();\r\n    // Defensive typed aliases for legacy fields that may be missing from GameSettings type\r\n    // Some code expects startTime/dayDuration to exist; cast to any and provide sensible defaults\r\n    const sStart = (settings as any).startTime ?? 0;\r\n    const sDayDuration = (settings as any).dayDuration ?? 24000;\r\n  const { toast } = useToast();\r\n    const isOnline = settings.gameMode === 'ai';\r\n\r\n    // audio: auto-play background based on mood when player moves or environment changes\r\n    // useAudio must be used inside AudioProvider (layouts already wrap the app)\r\n    const audio = useAudio();\r\n\r\n    // Track last move biome/time so we can emit a shorter \"continuation\" narrative when\r\n    // the player moves repeatedly within the same biome.\r\n    const lastMoveRef = useRef<{ biome?: string; time?: number }>({});\r\n\r\n    // Buffer pick-up events that occur within a short window so we aggregate multi-pick\r\n    // events into a single summary narrative instead of spamming detailed lines per item.\r\n    const pickupBufferRef = useRef<{ items: Array<any>; timer?: ReturnType<typeof setTimeout> }>({ items: [] });\r\n    const lastPickupMonologueAt = useRef(0);\r\n\r\n    const flushPickupBuffer = () => {\r\n        const buf = pickupBufferRef.current;\r\n        if (!buf || !buf.items || buf.items.length === 0) return;\r\n        const items = buf.items.splice(0, buf.items.length);\r\n        if (buf.timer) { clearTimeout(buf.timer); buf.timer = undefined; }\r\n\r\n        try {\r\n            // If only one distinct item and qty ===1, render the detailed single-pick template\r\n            if (items.length === 1 && items[0].quantity <= 1) {\r\n                const it = items[0];\r\n                // try to recreate the previous single-item detailed narrative path\r\n                const resolvedDef = resolveItemDef(getTranslatedText(it.name, 'en'));\r\n                const buildSensoryText = (def: ItemDefinition | undefined, itemName?: string) => {\r\n                    if (!def || !def.senseEffect || !Array.isArray(def.senseEffect.keywords) || def.senseEffect.keywords.length === 0) return '';\r\n                    const raw = def.senseEffect.keywords[Math.floor(Math.random() * def.senseEffect.keywords.length)];\r\n                    const [kindRaw, ...rest] = raw.split(':');\r\n                    const kind = kindRaw || 'generic';\r\n                    const valRaw = rest.join(':') || '';\r\n                    // fallback translation helper (keep minimal)\r\n                    const sensory = valRaw || raw;\r\n                    return sensory;\r\n                };\r\n                const itemNameText = t(it.name as TranslationKey);\r\n                const sensory = buildSensoryText(resolvedDef, itemNameText);\r\n                const narrativeText = t('pickedUpItem_single_1' as TranslationKey, { itemName: itemNameText, sensory });\r\n                addNarrativeEntry(narrativeText, 'narrative');\r\n                return;\r\n            }\r\n\r\n            // Multi-summary: group by name and sum quantities\r\n            const grouped: Record<string, number> = {};\r\n            items.forEach((it: any) => { const key = getTranslatedText(it.name, language); grouped[key] = (grouped[key] || 0) + (it.quantity || 1); });\r\n            const summaryList = Object.keys(grouped).map(k => `${grouped[k]} ${k}`).slice(0, 6).join(', ');\r\n            const totalCount = Object.values(grouped).reduce((s, v) => s + v, 0);\r\n            const summaryText = language === 'vi' ? `Bß║ín gom ─æ╞░ß╗úc ${summaryList}.` : `You picked up ${summaryList}.`;\r\n            addNarrativeEntry(summaryText, 'narrative');\r\n\r\n            // Optionally add a brief monologue if many distinct items found, but throttle it\r\n            const distinct = Object.keys(grouped).length;\r\n            const now = Date.now();\r\n            if (distinct >= 3 && now - lastPickupMonologueAt.current > 60_000) {\r\n                const db = getKeywordVariations(language as any);\r\n                const pool = (db as any)['monologue_tired'] || [];\r\n                if (pool.length > 0) {\r\n                    const line = pool[Math.floor(Math.random() * pool.length)];\r\n                    addNarrativeEntry(line, 'monologue');\r\n                    lastPickupMonologueAt.current = now;\r\n                }\r\n            }\r\n        } catch (e) {\r\n            // fallback: nothing\r\n        }\r\n    };\r\n\r\n    // When the player's current chunk or environment changes, prefer playing\r\n    // biome-specific ambience (files named like Ambience_<Biome>) and fall back\r\n    // to mood-based background tracks when a matching ambience isn't available.\r\n    // We respect the playbackMode in the provider by checking it before\r\n    // triggering playback.\r\n    useEffect(() => {\r\n        try {\r\n            if (!audio || audio.playbackMode === 'off') return;\r\n            const key = `${playerPosition.x},${playerPosition.y}`;\r\n            const baseChunk = world[key];\r\n            if (!baseChunk) return;\r\n            const currentChunk = getEffectiveChunk(baseChunk, weatherZones, gameTime, sStart, sDayDuration);\r\n            // prefer biome-based ambience when possible (matches filenames like Ambience_Cave_00.mp3)\r\n            const biome = (currentChunk.terrain || (currentChunk as any).biome) as string | undefined | null;\r\n            if (biome) {\r\n                // playAmbienceForBiome will no-op if no matching file exists\r\n                audio.playAmbienceForBiome(biome);\r\n            } else {\r\n                const moods = analyze_chunk_mood(currentChunk);\r\n                audio.playBackgroundForMoods(moods);\r\n            }\r\n        } catch (e) {\r\n            // non-fatal: don't block game logic if audio fails\r\n        }\r\n    }, [world, playerPosition.x, playerPosition.y, weatherZones, gameTime, audio, sStart, sDayDuration]);\r\n\r\n  const handleOnlineNarrative = useCallback(async (action: string, worldCtx: World, playerPosCtx: { x: number, y: number }, playerStatsCtx: PlayerStatus) => {\r\n    setIsLoading(true);\r\n    \r\n    const entryId = `${Date.now()}-ai-response`;\r\n    logger.info(`[AI] Starting narrative generation for action: \"${action}\"`, { entryId });\r\n    \r\n    const baseChunk = worldCtx[`${playerPosCtx.x},${playerPosCtx.y}`];\r\n    if (!baseChunk || !finalWorldSetup) { setIsLoading(false); return; }\r\n\r\n    const { roll, range } = rollDice(settings.diceType);\r\n    const successLevel = getSuccessLevel(roll, settings.diceType);\r\n    addNarrativeEntry(t('diceRollMessage', { diceType: settings.diceType, roll, level: t(successLevelToTranslationKey[successLevel]) }), 'system', `${Date.now()}-dice`);\r\n\r\n    const currentChunk = getEffectiveChunk(baseChunk, weatherZones, gameTime, sStart, sDayDuration);\r\n\r\n    const surroundingChunks: Chunk[] = [];\r\n    if (settings.narrativeLength === 'long') {\r\n        for (let dy = 1; dy >= -1; dy--) {\r\n            for (let dx = -1; dx <= 1; dx++) {\r\n                if (dx === 0 && dy === 0) continue;\r\n                const key = `${playerPosCtx.x + dx},${playerPosCtx.y + dy}`;\r\n                const adjacentChunk = worldCtx[key];\r\n                if (adjacentChunk && adjacentChunk.explored) {\r\n                    surroundingChunks.push(getEffectiveChunk(adjacentChunk, weatherZones, gameTime, sStart, sDayDuration));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    try {\r\n        const recentNarrative = narrativeLogRef.current?.slice(-5).map(e => e.text) || [];\r\n        \r\n        logger.debug('[AI] Input for generateNarrative', { entryId, action, playerPosCtx });\r\n        // Normalize player status and chunk data for AI flows so Zod schemas expecting\r\n        // concrete numeric fields and plain string enemy.type are satisfied.\r\n        const normalizedPlayerStatus = {\r\n            ...playerStatsCtx,\r\n            unlockProgress: {\r\n                kills: playerStatsCtx.unlockProgress?.kills ?? 0,\r\n                damageSpells: playerStatsCtx.unlockProgress?.damageSpells ?? 0,\r\n                moves: playerStatsCtx.unlockProgress?.moves ?? 0,\r\n            },\r\n            playerLevel: typeof playerStatsCtx.playerLevel === 'number'\r\n                ? { level: playerStatsCtx.playerLevel as number, experience: 0 }\r\n                : (playerStatsCtx.playerLevel ?? { level: 1, experience: 0 }),\r\n            questsCompleted: playerStatsCtx.questsCompleted ?? 0,\r\n        };\r\n\r\n    const normalizeChunkForAI = (c: Chunk): Chunk => {\r\n            // Force the enemy.type translation to a plain string for AI inputs.\r\n            // Use the declared enemy.type (TranslatableString) directly when translating.\r\n            const enemy = c.enemy\r\n                ? ({ ...c.enemy, type: getTranslatedText(c.enemy.type ?? { en: '' }, language) } as any)\r\n                : null;\r\n            return { ...c, enemy } as any as Chunk;\r\n        };\r\n\r\n    const normalizedCurrentChunk = normalizeChunkForAI(currentChunk as Chunk);\r\n    const normalizedSurrounding = surroundingChunks.length > 0 ? surroundingChunks.map(normalizeChunkForAI) : undefined;\r\n\r\n        const input: GenerateNarrativeInput = {\r\n            worldName: t(finalWorldSetup.worldName as TranslationKey),\r\n            playerAction: action,\r\n            playerStatus: normalizedPlayerStatus,\r\n            // normalizedCurrentChunk has been massaged for AI; cast to any to satisfy the Zod-derived input shape\r\n            currentChunk: normalizedCurrentChunk as any,\r\n            surroundingChunks: normalizedSurrounding as any,\r\n            recentNarrative,\r\n            language,\r\n            customItemDefinitions,\r\n            diceRoll: roll,\r\n            diceType: settings.diceType,\r\n            diceRange: range,\r\n            successLevel,\r\n            aiModel: settings.aiModel,\r\n            narrativeLength: settings.narrativeLength,\r\n        };\r\n        const result = await generateNarrative(input);\r\n        \r\n        logger.info('[AI] Narrative generated successfully', { entryId, result });\r\n\r\n        addNarrativeEntry(result.narrative, 'narrative', entryId);\r\n        if(result.systemMessage) addNarrativeEntry(result.systemMessage, 'system', `${Date.now()}-system`);\r\n\r\n        let finalPlayerStats: PlayerStatus = { ...playerStatsCtx, ...(result.updatedPlayerStatus || {})};\r\n        // Ensure unlockProgress numeric fields are present to satisfy stricter typings\r\n        finalPlayerStats.unlockProgress = {\r\n            kills: finalPlayerStats.unlockProgress?.kills ?? 0,\r\n            damageSpells: finalPlayerStats.unlockProgress?.damageSpells ?? 0,\r\n            moves: finalPlayerStats.unlockProgress?.moves ?? 0,\r\n        };\r\n        \r\n            if (worldCtx[`${playerPosCtx.x},${playerPosCtx.y}`]?.enemy && result.updatedChunk?.enemy === null) {\r\n                finalPlayerStats.unlockProgress = { ...finalPlayerStats.unlockProgress, kills: (finalPlayerStats.unlockProgress?.kills ?? 0) + 1 };\r\n            }\r\n\r\n        setWorld(prev => {\r\n            const newWorld = { ...prev };\r\n            const key = `${currentChunk.x},${currentChunk.y}`;\r\n            if (result.updatedChunk) {\r\n                const chunkToUpdate = newWorld[key];\r\n                const updatedEnemy: Enemy | null = result.updatedChunk?.enemy !== undefined ? result.updatedChunk.enemy : chunkToUpdate.enemy;\r\n                // result.updatedChunk may be partial ΓÇö treat it as Partial<Chunk> when merging\r\n                const partial: Partial<Chunk> | undefined = result.updatedChunk as Partial<Chunk> | undefined;\r\n                newWorld[key] = { ...chunkToUpdate, ...(partial || {}), enemy: updatedEnemy } as Chunk;\r\n            }\r\n            return newWorld;\r\n        });\r\n        \r\n        if (result.newlyGeneratedItem) {\r\n            const newItem = result.newlyGeneratedItem;\r\n            // Resolve a canonical id for the generated item (prefer id/key from defs)\r\n            const newItemId = resolveItemId(newItem.name, customItemDefinitions, t, language) ?? getTranslatedText(newItem.name, 'en');\r\n            if (!resolveItemDef(newItemId)) {\r\n                logger.info('[AI] A new item was generated for the world', { newItem, newItemId });\r\n                setCustomItemCatalog(prev => [...prev, newItem]);\r\n                setCustomItemDefinitions(prev => ({ ...prev, [newItemId]: { ...newItem } }));\r\n                if (db) {\r\n                    await setDoc(doc(db, \"world-catalog\", \"items\", \"generated\", newItemId), newItem);\r\n                }\r\n            }\r\n        }\r\n        setPlayerStats(() => finalPlayerStats);\r\n        advanceGameTime(finalPlayerStats);\r\n    } catch (error) {\r\n        logger.error(\"[AI] Narrative generation failed\", error);\r\n        toast({ title: t('offlineModeActive'), description: t('offlineToastDesc'), variant: \"destructive\" });\r\n    } finally {\r\n        setIsLoading(false);\r\n    }\r\n    }, [settings.diceType, settings.aiModel, settings.narrativeLength, finalWorldSetup, weatherZones, gameTime, customItemDefinitions, narrativeLogRef, language, setIsLoading, addNarrativeEntry, setWorld, setCustomItemCatalog, setCustomItemDefinitions, setPlayerStats, advanceGameTime, toast, t]);\r\n\r\n  const handleOfflineAttack = useCallback(() => {\r\n    const key = `${playerPosition.x},${playerPosition.y}`;\r\n    const baseChunk = world[key];\r\n    if (!baseChunk || !baseChunk.enemy) { addNarrativeEntry(t('noTarget'), 'system'); return; }\r\n    \r\n    logger.debug('[Offline] Starting attack sequence', { playerPosition, enemy: baseChunk.enemy });\r\n    const currentChunk = getEffectiveChunk(baseChunk, weatherZones, gameTime, sStart, sDayDuration);\r\n\r\n    const { roll } = rollDice(settings.diceType);\r\n    const successLevel = getSuccessLevel(roll, settings.diceType);\r\n    addNarrativeEntry(t('diceRollMessage', { diceType: settings.diceType, roll, level: t(successLevelToTranslationKey[successLevel]) }), 'system');\r\n\r\n    let playerDamage = 0;\r\n    const damageMultiplier = successLevel === 'CriticalFailure' ? 0 : successLevel === 'Failure' ? 0 : successLevel === 'GreatSuccess' ? 1.5 : successLevel === 'CriticalSuccess' ? 2.0 : 1.0;\r\n    \r\n    if (damageMultiplier > 0) {\r\n    let playerDamageModifier = 1.0;\r\n    if ((currentChunk.lightLevel ?? 0) < -3) { playerDamageModifier *= 0.8; }\r\n    if ((currentChunk.moisture ?? 0) > 8) { playerDamageModifier *= 0.9; }\r\n        \r\n    let playerBaseDamage = (playerStats.attributes?.physicalAttack ?? 0) + (playerStats.persona === 'warrior' ? 2 : 0);\r\n        playerDamage = Math.round(playerBaseDamage * damageMultiplier * playerDamageModifier);\r\n    }\r\n\r\n    const finalEnemyHp = Math.max(0, currentChunk.enemy!.hp - playerDamage);\r\n    const enemyDefeated = finalEnemyHp <= 0;\r\n    let lootDrops: ChunkItem[] = [];\r\n\r\n    let enemyDamage = 0;\r\n    let fled = false;\r\n\r\n    if (enemyDefeated) {\r\n        const templates = getTemplates(language);\r\n        const enemyTemplate = templates[currentChunk.terrain]?.enemies.find((e: any) => getTranslatedText(e.data.type as TranslatableString, 'en') === getTranslatedText(currentChunk.enemy!.type as TranslatableString, 'en'));\r\n        if (enemyTemplate?.data?.loot) {\r\n            type LootEntry = { name: string; chance: number };\r\n            for (const lootItem of (enemyTemplate.data.loot as LootEntry[])) {\r\n                if (Math.random() < lootItem.chance) {\r\n                    const definition = resolveItemDef(lootItem.name);\r\n                    if (definition) {\r\n                        lootDrops.push({\r\n                            name: { en: lootItem.name, vi: t(lootItem.name as TranslationKey) },\r\n                            description: definition.description,\r\n                            tier: definition.tier,\r\n                            quantity: clamp(Math.floor(Math.random() * (definition.baseQuantity.max - definition.baseQuantity.min + 1)) + definition.baseQuantity.min, 1, Infinity),\r\n                            emoji: definition.emoji,\r\n                        } as ChunkItem);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        fled = currentChunk.enemy!.behavior === 'passive' || (successLevel === 'CriticalSuccess' && currentChunk.enemy!.size === 'small');\r\n        if (!fled) enemyDamage = Math.round(currentChunk.enemy!.damage);\r\n    }\r\n\r\n    let nextPlayerStats = {...playerStats};\r\n    nextPlayerStats.hp = Math.max(0, nextPlayerStats.hp - enemyDamage);\r\n    if (enemyDefeated) {\r\n        nextPlayerStats.unlockProgress = { ...nextPlayerStats.unlockProgress, kills: (nextPlayerStats.unlockProgress?.kills ?? 0) + 1 };\r\n    }\r\n\r\n    const narrativeResult = { successLevel, playerDamage, enemyDamage, enemyDefeated, fled, enemyType: currentChunk.enemy!.type };\r\n    const narrative = generateOfflineActionNarrative('attack', narrativeResult, currentChunk, t, language);\r\n    addNarrativeEntry(narrative, 'narrative');\r\n\r\n    if (enemyDefeated && lootDrops.length > 0) {\r\n        addNarrativeEntry(t('enemyDropped', { items: lootDrops.map(i => `${i.quantity} ${getTranslatedText(i.name, language)}`).join(', ') }), 'system');\r\n    }\r\n\r\n    setWorld(prev => {\r\n        const newWorld = { ...prev };\r\n        const chunkToUpdate = { ...newWorld[key]! };\r\n        chunkToUpdate.enemy = (enemyDefeated || fled) ? null : { ...chunkToUpdate.enemy!, hp: finalEnemyHp };\r\n        if (lootDrops.length > 0) {\r\n            const newItemsMap = new Map<string, PlayerItem>((chunkToUpdate.items || []).map((item: PlayerItem) => [getTranslatedText(item.name, 'en'), { ...item } as PlayerItem]));\r\n            lootDrops.forEach((droppedItem: ChunkItem) => {\r\n                const dropName = getTranslatedText(droppedItem.name, 'en');\r\n                const existingItem = newItemsMap.get(dropName);\r\n                if (existingItem) {\r\n                    existingItem.quantity += droppedItem.quantity;\r\n                } else {\r\n                    newItemsMap.set(dropName, droppedItem);\r\n                }\r\n            });\r\n            chunkToUpdate.items = Array.from(newItemsMap.values());\r\n        }\r\n        newWorld[key] = chunkToUpdate;\r\n        return newWorld;\r\n    });\r\n\r\n    setPlayerStats(() => nextPlayerStats);\r\n    advanceGameTime(nextPlayerStats);\r\n    }, [playerPosition, world, addNarrativeEntry, settings.diceType, t, playerStats, customItemDefinitions, advanceGameTime, setWorld, weatherZones, gameTime, setPlayerStats, language]);\r\n\r\n  const handleOfflineItemUse = useCallback((itemName: string, target: string) => {\r\n    const itemDef = resolveItemDef(itemName);\r\n    if (!itemDef) return;\r\n\r\n    let newPlayerStats: PlayerStatus = JSON.parse(JSON.stringify(playerStats));\r\n    newPlayerStats.items = newPlayerStats.items || [];\r\n    newPlayerStats.pets = newPlayerStats.pets || [];\r\n    newPlayerStats.skills = newPlayerStats.skills || [];\r\n    const itemIndex = newPlayerStats.items.findIndex(i => getTranslatedText(i.name, 'en') === itemName);\r\n\r\n    if (itemIndex === -1) {\r\n        addNarrativeEntry(t('itemNotFound'), 'system');\r\n        return;\r\n    }\r\n    \r\n    const key = `${playerPosition.x},${playerPosition.y}`;\r\n    const currentChunk = world[key];\r\n    if (!currentChunk) return;\r\n\r\n    let narrativeResult: any = { itemName, target };\r\n    let itemWasConsumed = false;\r\n    let finalWorldUpdate: Partial<World> | null = null;\r\n\r\n    if (target === 'player') {\r\n        if (!itemDef.effects.length) {\r\n            addNarrativeEntry(t('itemNoEffect', { item: t(itemName as TranslationKey) }), 'system');\r\n            return;\r\n        }\r\n        itemWasConsumed = true;\r\n        let effectDescriptions: string[] = [];\r\n        itemDef.effects.forEach((effect: ItemEffect) => {\r\n            const amt = effect.amount ?? 0;\r\n            if (effect.type === 'HEAL') {\r\n                const old = newPlayerStats.hp;\r\n                newPlayerStats.hp = Math.min(100, newPlayerStats.hp + amt);\r\n                if (newPlayerStats.hp > old) effectDescriptions.push(t('itemHealEffect', { amount: newPlayerStats.hp - old }));\r\n            }\r\n            if (effect.type === 'RESTORE_STAMINA') {\r\n                const old = newPlayerStats.stamina;\r\n                newPlayerStats.stamina = Math.min(100, newPlayerStats.stamina + amt);\r\n                if (newPlayerStats.stamina > old) effectDescriptions.push(t('itemStaminaEffect', { amount: (newPlayerStats.stamina - old).toFixed(0) }));\r\n            }\r\n            if (effect.type === 'RESTORE_HUNGER') {\r\n                if (newPlayerStats.hunger === undefined) newPlayerStats.hunger = 100;\r\n                const old = newPlayerStats.hunger;\r\n                newPlayerStats.hunger = Math.min(100, newPlayerStats.hunger + amt);\r\n                if (newPlayerStats.hunger > old) effectDescriptions.push(t('itemHungerEffect', { amount: (newPlayerStats.hunger - old).toFixed(0) }));\r\n            }\r\n            if (effect.type === 'APPLY_EFFECT') {\r\n                // Apply a status effect instance to the player (makes the item grant a timed effect)\r\n                if (effect.effectType) {\r\n                        type LocalStatusEffect = {\r\n                            id: string;\r\n                            type: string;\r\n                            duration: number;\r\n                            magnitude?: number;\r\n                            description: TranslatableString;\r\n                            appliedTurn: number;\r\n                            source?: string;\r\n                        };\r\n                        const newEffect: LocalStatusEffect = {\r\n                            id: `item-${Date.now()}-${Math.random().toString(36).slice(2,6)}`,\r\n                            type: String(effect.effectType),\r\n                            duration: Number(effect.effectDuration ?? 0),\r\n                            magnitude: typeof effect.effectMagnitude === 'number' ? effect.effectMagnitude : undefined,\r\n                            // lightweight description: use the effect type as fallback text\r\n                            description: { en: String(effect.effectType), vi: String(effect.effectType) },\r\n                            appliedTurn: (turn ?? 0),\r\n                            source: itemName,\r\n                        };\r\n                        newPlayerStats.statusEffects = newPlayerStats.statusEffects || [];\r\n                        newPlayerStats.statusEffects.push(newEffect as any);\r\n                        effectDescriptions.push(`${t('appliedEffect') || 'Applied effect'}: ${String(effect.effectType)}`);\r\n                    }\r\n            }\r\n            if (effect.type === 'GAMBLE_EFFECT') {\r\n                // Gamble effect: 50/50 chance between positive and negative outcomes\r\n                const gambleType = effect.gambleType || 'balanced';\r\n                const isPositive = Math.random() < 0.5;\r\n\r\n                if (isPositive) {\r\n                    if (gambleType === 'mana') {\r\n                        const healAmount = 30; // Large mana restoration\r\n                        const old = newPlayerStats.mana ?? 0;\r\n                        newPlayerStats.mana = Math.min(100, (newPlayerStats.mana ?? 0) + healAmount);\r\n                        if (newPlayerStats.mana > old) effectDescriptions.push(t('itemManaEffect', { amount: newPlayerStats.mana - old }));\r\n                    } else if (gambleType === 'health') {\r\n                        const healAmount = 30; // Large health restoration\r\n                        const old = newPlayerStats.hp;\r\n                        newPlayerStats.hp = Math.min(100, newPlayerStats.hp + healAmount);\r\n                        if (newPlayerStats.hp > old) effectDescriptions.push(t('itemHealEffect', { amount: newPlayerStats.hp - old }));\r\n                    } else { // balanced\r\n                        const healAmount = 20; // Medium restoration for both\r\n                        const oldHp = newPlayerStats.hp;\r\n                        const oldMana = newPlayerStats.mana ?? 0;\r\n                        newPlayerStats.hp = Math.min(100, newPlayerStats.hp + healAmount);\r\n                        newPlayerStats.mana = Math.min(100, (newPlayerStats.mana ?? 0) + healAmount);\r\n                        if (newPlayerStats.hp > oldHp) effectDescriptions.push(t('itemHealEffect', { amount: newPlayerStats.hp - oldHp }));\r\n                        if (newPlayerStats.mana > oldMana) effectDescriptions.push(t('itemManaEffect', { amount: newPlayerStats.mana - oldMana }));\r\n                    }\r\n                } else {\r\n                    // Apply poison effect (negative outcome)\r\n                    type LocalStatusEffect = {\r\n                        id: string;\r\n                        type: string;\r\n                        duration: number;\r\n                        magnitude?: number;\r\n                        description: TranslatableString;\r\n                        appliedTurn: number;\r\n                        source?: string;\r\n                    };\r\n                    const poisonEffect: LocalStatusEffect = {\r\n                        id: `item-${Date.now()}-${Math.random().toString(36).slice(2,6)}`,\r\n                        type: 'poison',\r\n                        duration: 5,\r\n                        magnitude: 2,\r\n                        description: { en: 'Poisoned', vi: 'Bß╗ï ─æß╗Öc' },\r\n                        appliedTurn: (turn ?? 0),\r\n                        source: itemName,\r\n                    };\r\n                    newPlayerStats.statusEffects = newPlayerStats.statusEffects || [];\r\n                    newPlayerStats.statusEffects.push(poisonEffect as any);\r\n                    effectDescriptions.push(t('appliedEffect') || 'Applied effect: Poison');\r\n                }\r\n            }\r\n        });\r\n        narrativeResult.wasUsed = effectDescriptions.length > 0;\r\n        narrativeResult.effectDescription = effectDescriptions.join(', ');\r\n    } else { // Taming logic\r\n        if (!currentChunk.enemy || getTranslatedText(currentChunk.enemy.type, 'en') !== target) {\r\n            addNarrativeEntry(t('noTargetForITEM', { target: t(target as TranslationKey) }), 'system');\r\n            return;\r\n        }\r\n        if (!currentChunk.enemy.diet.includes(itemName)) {\r\n            addNarrativeEntry(t('targetNotInterested', { target: t(target as TranslationKey), item: t(itemName as TranslationKey) }), 'system');\r\n            return;\r\n        }\r\n\r\n        itemWasConsumed = true;\r\n        narrativeResult.itemConsumed = true;\r\n        const newEnemyState = { ...currentChunk.enemy, satiation: Math.min(currentChunk.enemy.satiation + 1, currentChunk.enemy.maxSatiation) };\r\n        const tamingChance = 0.1 + (newEnemyState.satiation / newEnemyState.maxSatiation) * 0.4 - (newEnemyState.hp / 100) * 0.2;\r\n\r\n        if (Math.random() < tamingChance) {\r\n            newPlayerStats.pets = [...(newPlayerStats.pets || []), { type: currentChunk.enemy.type, level: 1 }];\r\n            finalWorldUpdate = { [key]: { ...currentChunk, enemy: null } };\r\n            narrativeResult.wasTamed = true;\r\n            narrativeResult.newPet = newPlayerStats.pets.at(-1);\r\n        } else {\r\n            finalWorldUpdate = { [key]: { ...currentChunk, enemy: newEnemyState } };\r\n            narrativeResult.wasTamed = false;\r\n        }\r\n    }\r\n    \r\n    if (itemWasConsumed) {\r\n        newPlayerStats.items[itemIndex].quantity -= 1;\r\n    }\r\n    \r\n    const narrative = generateOfflineActionNarrative('useItem', narrativeResult, currentChunk, t, language);\r\n    addNarrativeEntry(narrative, 'narrative');\r\n\r\n    // Apply state changes at the end\r\n    if (finalWorldUpdate) {\r\n        setWorld(prev => ({ ...prev, ...finalWorldUpdate! }));\r\n    }\r\n    \r\n    newPlayerStats.items = newPlayerStats.items.filter(i => i.quantity > 0);\r\n    setPlayerStats(() => newPlayerStats);\r\n    advanceGameTime(newPlayerStats);\r\n    }, [playerStats, customItemDefinitions, playerPosition, world, addNarrativeEntry, t, advanceGameTime, setWorld, setPlayerStats, language]);\r\n\r\n  const handleOfflineSkillUse = useCallback((skillName: string) => {\r\n\r\n    let newPlayerStats: PlayerStatus = JSON.parse(JSON.stringify(playerStats));\r\n    newPlayerStats.skills = newPlayerStats.skills || [];\r\n    newPlayerStats.items = newPlayerStats.items || [];\r\n    const skillToUse = newPlayerStats.skills.find((s: any) => t(s.name as TranslationKey) === skillName);\r\n\r\n    if (!skillToUse) { addNarrativeEntry(t('skillNotFound', { skillName: t(skillName as TranslationKey) }), 'system'); return; }\r\n    if ((newPlayerStats.mana ?? 0) < skillToUse.manaCost) { addNarrativeEntry(t('notEnoughMana', { skillName: t(skillName as TranslationKey) }), 'system'); return; }\r\n\r\n    const { roll } = rollDice(settings.diceType);\r\n    const successLevel = getSuccessLevel(roll, settings.diceType);\r\n    addNarrativeEntry(t('diceRollMessage', { diceType: settings.diceType, roll, level: t(successLevelToTranslationKey[successLevel]) }), 'system');\r\n    newPlayerStats.mana = (newPlayerStats.mana ?? 0) - skillToUse.manaCost;\r\n\r\n    const key = `${playerPosition.x},${playerPosition.y}`;\r\n    const currentChunk = world[key]!;\r\n    let newEnemy: any = currentChunk.enemy ? { ...currentChunk.enemy } : null;\r\n    \r\n    let narrativeResult: any = { skill: skillToUse, successLevel, enemy: newEnemy };\r\n\r\n    if (successLevel === 'CriticalFailure') {\r\n        const backfireDamage = Math.round(skillToUse.effect.amount * 0.5);\r\n        newPlayerStats.hp = Math.max(0, newPlayerStats.hp - backfireDamage);\r\n        narrativeResult.backfireDamage = backfireDamage;\r\n    } else if (successLevel !== 'Failure') {\r\n        const effectMultiplier = successLevel === 'GreatSuccess' ? 1.5 : successLevel === 'CriticalSuccess' ? 2.0 : 1.0;\r\n\r\n        if (skillToUse.effect.type === 'HEAL') {\r\n            const healAmount = Math.round(skillToUse.effect.amount * effectMultiplier);\r\n            const oldHp = newPlayerStats.hp;\r\n            newPlayerStats.hp = Math.min(100, newPlayerStats.hp + healAmount);\r\n            narrativeResult.healedAmount = newPlayerStats.hp - oldHp;\r\n        } else if (skillToUse.effect.type === 'DAMAGE' && newEnemy) {\r\n                const baseDamage = skillToUse.effect.amount + Math.round((newPlayerStats.attributes?.magicalAttack ?? 0) * 0.5);\r\n            const finalDamage = Math.round(baseDamage * effectMultiplier);\r\n\r\n            newEnemy.hp = Math.max(0, newEnemy.hp - finalDamage);\r\n            narrativeResult.finalDamage = finalDamage;\r\n\r\n            if (skillToUse.effect.healRatio) {\r\n                const healedAmount = Math.round(finalDamage * skillToUse.effect.healRatio);\r\n                const oldHp = newPlayerStats.hp;\r\n                newPlayerStats.hp = Math.min(100, newPlayerStats.hp + healedAmount);\r\n                if (newPlayerStats.hp > oldHp) narrativeResult.siphonedAmount = newPlayerStats.hp - oldHp;\r\n            }\r\n            if (newEnemy.hp <= 0) {\r\n                newEnemy = null;\r\n                newPlayerStats.unlockProgress = { ...newPlayerStats.unlockProgress, kills: (newPlayerStats.unlockProgress?.kills ?? 0) + 1 };\r\n            }\r\n            newPlayerStats.unlockProgress = { ...newPlayerStats.unlockProgress, damageSpells: (newPlayerStats.unlockProgress?.damageSpells ?? 0) + 1 };\r\n            narrativeResult.enemy = newEnemy;\r\n        }\r\n    }\r\n    \r\n    const narrative = generateOfflineActionNarrative('useSkill', narrativeResult, currentChunk, t, language);\r\n    addNarrativeEntry(narrative, 'narrative');\r\n\r\n    if(newEnemy !== currentChunk.enemy) setWorld(prev => ({...prev, [key]: {...prev[key]!, enemy: newEnemy}}));\r\n    setPlayerStats(() => newPlayerStats);\r\n    advanceGameTime(newPlayerStats);\r\n    }, [playerStats, settings.diceType, t, addNarrativeEntry, playerPosition, world, advanceGameTime, setWorld, setPlayerStats, language]);\r\n\r\n    const handleOfflineAction = useCallback((action: Action) => {\r\n        let newPlayerStats: PlayerStatus = { ...playerStats, dailyActionLog: [...(playerStats.dailyActionLog || []), t(action.textKey as TranslationKey, action.params)] };\r\n    newPlayerStats.items = newPlayerStats.items || [];\r\n    newPlayerStats.quests = newPlayerStats.quests || [];\r\n      const currentChunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n      if (!currentChunk) return;\r\n\r\n      const { textKey } = action;\r\n\r\n      if (textKey === 'observeAction_enemy') {\r\n          const enemy = currentChunk.enemy;\r\n          if (enemy) {\r\n              const enemyName = t(enemy.type as TranslationKey);\r\n              newPlayerStats.trackedEnemy = {\r\n                  chunkKey: `${currentChunk.x},${currentChunk.y}`,\r\n                  type: getTranslatedText(enemy.type, 'en'),\r\n                  lastSeen: turn,\r\n              };\r\n              addNarrativeEntry(t('observeSuccess', { enemyName }), 'system');\r\n          }\r\n      } else if (textKey === 'talkToAction_npc') {\r\n          const npcName = t(action.params!.npcName as TranslationKey);\r\n          const npc = currentChunk.NPCs.find((n: any) => t(n.name as TranslationKey) === npcName);\r\n          if (npc) {\r\n              const templates = getTemplates(language);\r\n              let npcDef: any;\r\n               for (const terrain of Object.keys(templates)) {\r\n                      const templateNpc = templates[terrain as 'forest']?.NPCs.find((n: any) => t(n.data.name as TranslationKey) === npcName);\r\n                  if (templateNpc) {\r\n                      npcDef = templateNpc.data;\r\n                      break;\r\n                  }\r\n              }\r\n              if (npcDef?.quest && npcDef.questItem) {\r\n                  const questText = t(npcDef.quest as TranslationKey);\r\n                  if (newPlayerStats.quests.includes(questText)) {\r\n                      const itemInInventory = newPlayerStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === npcDef.questItem!.name);\r\n                      if (itemInInventory && itemInInventory.quantity >= npcDef.questItem!.quantity) {\r\n                          addNarrativeEntry(t('gaveItemToNpc', { quantity: npcDef.questItem.quantity, itemName: t(npcDef.questItem.name as TranslationKey), npcName: npcName}), 'system');\r\n                          itemInInventory.quantity -= npcDef.questItem!.quantity;\r\n                          if (itemInInventory.quantity <= 0) newPlayerStats.items = newPlayerStats.items.filter(i => getTranslatedText(i.name, 'en') !== npcDef!.questItem!.name);\r\n                          (npcDef.rewardItems || []).forEach((reward: PlayerItem) => {\r\n                          const existingItem = newPlayerStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === getTranslatedText(reward.name, 'en'));\r\n                          if (existingItem) existingItem.quantity += reward.quantity;\r\n                              else newPlayerStats.items.push(ensurePlayerItemId({...reward}, customItemDefinitions, t, language));\r\n                          });\r\n                          newPlayerStats.quests = newPlayerStats.quests.filter(q => q !== questText);\r\n                          addNarrativeEntry(t('npcQuestCompleted', { npcName: npcName }), 'narrative');\r\n                          toast({ title: t('questCompletedTitle'), description: questText });\r\n                      } else addNarrativeEntry(t('npcQuestNotEnoughItems', { npcName: npcName, needed: npcDef.questItem.quantity - (itemInInventory?.quantity || 0), itemName: t(npcDef.questItem.name as TranslationKey) }), 'narrative');\r\n                  } else { newPlayerStats.quests.push(questText); addNarrativeEntry(t('npcQuestGive', { npcName: npcName, questText: questText }), 'narrative'); }\r\n              } else addNarrativeEntry(t('npcNoQuest', { npcName: npcName }), 'narrative');\r\n          }\r\n      } else if (textKey === 'useItemOnNpcAction') {\r\n          const npcName = t(action.params!.npcName as TranslationKey);\r\n          const itemName = action.params!.itemName as string;\r\n          const npc = currentChunk.NPCs.find((n: any) => t(n.name as TranslationKey) === npcName);\r\n          if (npc && itemName === 'cvnt_essence') {\r\n              // Special logic for Floptropica quest completion\r\n              const questText = t('floptropica_quest2');\r\n              if (newPlayerStats.quests.includes(questText)) {\r\n                  const itemInInventory = newPlayerStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === 'cvnt_essence');\r\n                  if (itemInInventory && itemInInventory.quantity >= 1) {\r\n                      // Consume the item\r\n                      itemInInventory.quantity -= 1;\r\n                      if (itemInInventory.quantity <= 0) {\r\n                          newPlayerStats.items = newPlayerStats.items.filter(i => getTranslatedText(i.name, 'en') !== 'cvnt_essence');\r\n                      }\r\n\r\n                      // Complete the quest\r\n                      newPlayerStats.quests = newPlayerStats.quests.filter(q => q !== questText);\r\n\r\n                      // Add reward item (meme_template)\r\n                      const rewardItemName = 'meme_template';\r\n                      const existingRewardItem = newPlayerStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === rewardItemName);\r\n                      if (existingRewardItem) {\r\n                          existingRewardItem.quantity += 1;\r\n                      } else {\r\n                          const rewardItemDef = resolveItemDef(rewardItemName);\r\n                          if (rewardItemDef) {\r\n                              newPlayerStats.items.push(ensurePlayerItemId({\r\n                                  name: { en: rewardItemName, vi: t(rewardItemName as TranslationKey) },\r\n                                  quantity: 1,\r\n                                  tier: rewardItemDef.tier,\r\n                                  emoji: rewardItemDef.emoji\r\n                              }, customItemDefinitions, t, language));\r\n                          }\r\n                      }\r\n\r\n                      // Add narrative and toast\r\n                      addNarrativeEntry(t('floptropicaQuest2Completed', { npcName: npcName }), 'narrative');\r\n                      toast({ title: t('questCompletedTitle'), description: questText });\r\n                  } else {\r\n                      addNarrativeEntry(t('itemNotFound'), 'system');\r\n                  }\r\n              } else {\r\n                  addNarrativeEntry(t('npcNoQuest', { npcName: npcName }), 'narrative');\r\n              }\r\n          } else {\r\n              addNarrativeEntry(t('invalidAction'), 'system');\r\n          }\r\n      } else if (textKey === 'exploreAction') {\r\n          const result = handleSearchAction(\r\n              currentChunk,\r\n              action.id,\r\n              language,\r\n              t,\r\n              customItemDefinitions,\r\n              (range) => clamp(Math.floor(Math.random() * (range.max - range.min + 1)) + range.min, 1, Infinity),\r\n              // pass optional spawnMultiplier from worldProfile (fallback to 1)\r\n              (worldProfile && worldProfile.spawnMultiplier) || 1\r\n          );\r\n          \r\n          if (result.toastInfo) {\r\n              toast({\r\n                  title: t(result.toastInfo.title),\r\n                  description: t(result.toastInfo.description, result.toastInfo.params)\r\n              });\r\n          }\r\n          addNarrativeEntry(result.narrative, 'narrative');\r\n          setWorld(prev => ({...prev, [`${playerPosition.x},${playerPosition.y}`]: result.newChunk}));\r\n      } else if (textKey === 'pickUpAction_item') {\r\n          const chunkKey = `${playerPosition.x},${playerPosition.y}`;\r\n      const itemInChunk = currentChunk.items.find((i: ChunkItem) => getTranslatedText(i.name, 'en') === action.params!.itemName);\r\n          \r\n          if (!itemInChunk) {\r\n              toast({ title: t('actionNotAvailableTitle'), description: t('itemNotFoundNarrative', {itemName: t(action.params!.itemName as TranslationKey)}), variant: 'destructive' });\r\n               setWorld(prev => {\r\n                  const newWorld = { ...prev };\r\n                  const chunkToUpdate = { ...newWorld[chunkKey]! };\r\n                  chunkToUpdate.actions = chunkToUpdate.actions.filter((a: any) => a.id !== action.id);\r\n                  newWorld[chunkKey] = chunkToUpdate;\r\n                  return newWorld;\r\n              });\r\n              return;\r\n          }\r\n\r\n          toast({\r\n              title: t('itemPickedUpTitle'),\r\n              description: t('pickedUpItemToast', { quantity: itemInChunk.quantity, itemName: t(itemInChunk.name as TranslationKey) }),\r\n          });\r\n          \r\n              const itemInInventory = newPlayerStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === getTranslatedText(itemInChunk.name, 'en'));\r\n          if (itemInInventory) {\r\n              itemInInventory.quantity += itemInChunk.quantity;\r\n          } else {\r\n              newPlayerStats.items.push(ensurePlayerItemId({...itemInChunk}, customItemDefinitions, t, language));\r\n          }\r\n          \r\n          // Buffer pickup narratives: collect into a short window and flush a single\r\n          // aggregated narrative to avoid spamming a long sequence of per-item details.\r\n          try {\r\n              const resolvedDef = resolveItemDef(getTranslatedText(itemInChunk.name, 'en'));\r\n              const senseKey = resolvedDef?.senseEffect?.keywords?.[0] || undefined;\r\n              pickupBufferRef.current.items.push({ name: itemInChunk.name, quantity: itemInChunk.quantity || 1, senseKey, emoji: itemInChunk.emoji });\r\n              // schedule flush in 250ms if not already scheduled\r\n              if (!pickupBufferRef.current.timer) {\r\n                  pickupBufferRef.current.timer = setTimeout(() => flushPickupBuffer(), 250) as any;\r\n              }\r\n          } catch (e) {\r\n              // If buffering fails, fall back to adding a safe single-line narrative\r\n              addNarrativeEntry(t('pickedUpItemNarrative', { quantity: itemInChunk.quantity, itemName: t(itemInChunk.name as TranslationKey) }), 'narrative');\r\n          }\r\n\r\n          setWorld(prev => {\r\n              const newWorld = { ...prev };\r\n              const chunkToUpdate = { ...newWorld[chunkKey]! };\r\n              chunkToUpdate.items = chunkToUpdate.items.filter((i: any) => getTranslatedText(i.name, 'en') !== getTranslatedText(itemInChunk.name, 'en'));\r\n                  chunkToUpdate.actions = chunkToUpdate.actions.filter((a: any) => a.id !== action.id);\r\n              newWorld[chunkKey] = chunkToUpdate;\r\n              return newWorld;\r\n          });\r\n      } else if (textKey === 'listenToSurroundingsAction') {\r\n          const directions = [{ dx: 0, dy: 1, dir: 'North' }, { dx: 0, dy: -1, dir: 'South' }, { dx: 1, dy: 0, dir: 'East' }, { dx: -1, dy: 0, dir: 'West' }];\r\n          let heardSomething = false;\r\n          for (const dir of directions) {\r\n              const checkPos = { x: playerPosition.x + dir.dx, y: playerPosition.y + dir.dy };\r\n              const chunkKey = `${checkPos.x},${checkPos.y}`;\r\n              if (world[chunkKey] && world[chunkKey].enemy) {\r\n                  addNarrativeEntry(t('listenHearSomething', { direction: t(`direction${dir.dir}` as TranslationKey), sound: t('enemySoundGeneric') }), 'narrative');\r\n                  heardSomething = true;\r\n                  break;\r\n              }\r\n          }\r\n           if (!heardSomething) {\r\n              let hintGiven = false;\r\n              for (const dir of directions) {\r\n                  const biomeCheckPos = { x: playerPosition.x + dir.dx * 3, y: playerPosition.y + dir.dy * 3 };\r\n                  const biomeKey = `${biomeCheckPos.x},${biomeCheckPos.y}`;\r\n                  const adjacentChunk = world[biomeKey];\r\n                  if (adjacentChunk && adjacentChunk.terrain !== currentChunk.terrain) {\r\n                      const biomeSoundKey = `biomeSound_${adjacentChunk.terrain}` as TranslationKey;\r\n                      const sound = t(biomeSoundKey);\r\n                      if (sound !== biomeSoundKey) {\r\n                           addNarrativeEntry(t('listenHearBiome', { direction: t(`direction${dir.dir}` as TranslationKey), sound: sound }), 'narrative');\r\n                           hintGiven = true;\r\n                           break;\r\n                      }\r\n                  }\r\n              }\r\n               if (!hintGiven) {\r\n                  addNarrativeEntry(t('listenHearNothing'), 'narrative');\r\n              }\r\n          }\r\n      } else if (textKey === 'analyzeAction') {\r\n          const chunk = getEffectiveChunk(currentChunk, weatherZones, gameTime, sStart, sDayDuration);\r\n          let analysis = `[Analysis Report]\\nCoordinates: (${chunk.x}, ${chunk.y})\\nRegion ID: ${chunk.regionId}\\nTerrain: ${t(chunk.terrain as TranslationKey)}\\nTravel Cost: ${chunk.travelCost}\\n\\nEnvironmental Factors:\\n- Temperature: ${chunk.temperature?.toFixed(1)}┬░C\\n- Moisture: ${chunk.moisture}/100\\n- Light Level: ${chunk.lightLevel}/100\\n- Danger Level: ${chunk.dangerLevel}/100\\n- Explorability: ${chunk.explorability.toFixed(1)}/100\\n- Magic Affinity: ${chunk.magicAffinity}/100\\n- Human Presence: ${chunk.humanPresence}/100\\n- Predator Presence: ${chunk.predatorPresence}/100\\n- Vegetation Density: ${chunk.vegetationDensity}/100\\n- Soil Type: ${t(chunk.soilType as TranslationKey)}\\n- Wind Level: ${chunk.windLevel?.toFixed(1) ?? 'N/A'}/100\\n\\nEntities:\\n- Items: ${chunk.items.map((i: any) => t(i.name) + ` (x${i.quantity})`).join(', ') || 'None'}\\n- NPCs: ${chunk.NPCs.map((n: any) => t(n.name)).join(', ') || 'None'}\\n- Structures: ${chunk.structures.map((s: any) => t(s.name)).join(', ') || 'None'}`;\r\n\r\n          if (chunk.enemy) {\r\n              const enemy = chunk.enemy;\r\n              analysis += `\\n\\nEnemy:\\n  Type: ${t(enemy.type as any)}\\n  HP: ${enemy.hp}\\n  Damage: ${enemy.damage}\\n  Behavior: ${enemy.behavior}\\n  Size: ${enemy.size}\\n  Diet: ${enemy.diet.join(', ')}\\n  Satiation: ${enemy.satiation}/${enemy.maxSatiation}`;\r\n              if (enemy.senseEffect) {\r\n                  analysis += `\\n  Sense Effect: ${enemy.senseEffect.keywords.join(', ')}`;\r\n              }\r\n              if (enemy.harvestable) {\r\n                  analysis += `\\n  Harvestable:\\n    Difficulty: ${enemy.harvestable.difficulty}\\n    Required Tool: ${t(enemy.harvestable.requiredTool as TranslationKey)}\\n    Loot: ${enemy.harvestable.loot.map((loot: any) => `${t(loot.name as TranslationKey)} (${loot.chance * 100}% chance)`).join(', ')}`;\r\n              }\r\n          }\r\n\r\n          addNarrativeEntry(analysis, 'system');\r\n      }\r\n\r\n      setPlayerStats(() => newPlayerStats);\r\n      advanceGameTime(newPlayerStats);\r\n    }, [addNarrativeEntry, playerStats, t, world, playerPosition, toast, advanceGameTime, customItemDefinitions, setWorld, turn, weatherZones, gameTime, setPlayerStats, language]);\r\n\r\n  const handleAction = useCallback((actionId: number) => {\r\n    if (isLoading || isGameOver || !isLoaded) return;\r\n    const chunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n    if(!chunk) return;\r\n    \r\n    const action = chunk.actions.find((a: any) => a.id === actionId);\r\n    if (!action) {\r\n        toast({ title: t('actionNotAvailableTitle'), description: t('actionNotAvailableDesc'), variant: 'destructive' });\r\n        return;\r\n    }\r\n    \r\n    const actionText = t(action.textKey as TranslationKey, action.params);\r\n    addNarrativeEntry(actionText, 'action');\r\n    if (isOnline && action.textKey === 'talkToAction_npc') {\r\n        const newPlayerStats = { ...playerStats, dailyActionLog: [...(playerStats.dailyActionLog || []), actionText]};\r\n        handleOnlineNarrative(actionText, world, playerPosition, newPlayerStats);\r\n    } else {\r\n        handleOfflineAction(action);\r\n    }\r\n  }, [isLoading, isGameOver, isLoaded, world, playerPosition, playerStats, isOnline, handleOnlineNarrative, handleOfflineAction, toast, t, addNarrativeEntry]);\r\n\r\n  const handleAttack = useCallback(() => {\r\n    if (isLoading || isGameOver || !isLoaded) return;\r\n    setPlayerBehaviorProfile(p => ({ ...p, attacks: p.attacks + 1 }));\r\n    const baseChunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n    if (!baseChunk?.enemy) { addNarrativeEntry(t('noTarget'), 'system'); return; }\r\n    \r\n    const actionText = `${t('attackAction')} ${t(baseChunk.enemy.type as TranslationKey)}`;\r\n    addNarrativeEntry(actionText, 'action');\r\n    const newPlayerStats = { ...playerStats, dailyActionLog: [...(playerStats.dailyActionLog || []), actionText]};\r\n\r\n    setPlayerStats(() => newPlayerStats);\r\n    handleOfflineAttack();\r\n    }, [isLoading, isGameOver, isLoaded, setPlayerBehaviorProfile, world, playerPosition, addNarrativeEntry, t, playerStats, handleOfflineAttack, setPlayerStats]);\r\n\r\n  const handleCustomAction = useCallback((text: string) => {\r\n    if (!text.trim() || isLoading || isGameOver || !isLoaded) return;\r\n    setPlayerBehaviorProfile(p => ({ ...p, customActions: p.customActions + 1 }));\r\n\r\n    if (text.trim().toLowerCase() === 'analyze') {\r\n        handleOfflineAction({id: -1, textKey: 'analyzeAction'});\r\n        return;\r\n    }\r\n\r\n    const newPlayerStats = { ...playerStats, dailyActionLog: [...(playerStats.dailyActionLog || []), text]};\r\n    addNarrativeEntry(text, 'action');\r\n    if (isOnline) {\r\n        handleOnlineNarrative(text, world, playerPosition, newPlayerStats);\r\n    }\r\n    else {\r\n         addNarrativeEntry(t('customActionFail'), 'narrative');\r\n         setPlayerStats(() => newPlayerStats);\r\n         advanceGameTime(newPlayerStats);\r\n    }\r\n  }, [isLoading, isGameOver, isLoaded, setPlayerBehaviorProfile, playerStats, isOnline, handleOnlineNarrative, handleOfflineAction, world, playerPosition, addNarrativeEntry, t, advanceGameTime, setPlayerStats]);\r\n\r\n  const handleCraft = useCallback(async (recipe: Recipe, outcome: CraftingOutcome) => {\r\n    if (isLoading || isGameOver) return;\r\n    setPlayerBehaviorProfile(p => ({ ...p, crafts: p.crafts + 1 }));\r\n\r\n    if (!outcome.canCraft) { toast({ title: t('error'), description: t('notEnoughIngredients'), variant: \"destructive\" }); return; }\r\n    \r\n    const actionText = t('craftAction', {itemName: t(recipe.result.name as TranslationKey)});\r\n    addNarrativeEntry(actionText, 'action');\r\n    let updatedItems = (playerStats.items || []).map(i => ({...i}));\r\n    outcome.ingredientsToConsume.forEach((itemToConsume: any) => {\r\n        const itemIndex = updatedItems.findIndex((i: PlayerItem) => getTranslatedText(i.name, 'en') === itemToConsume.name);\r\n        if (itemIndex > -1) updatedItems[itemIndex].quantity -= itemToConsume.quantity;\r\n    });\r\n    \r\n    let nextPlayerStats = { ...playerStats, items: updatedItems.filter(i => i.quantity > 0), dailyActionLog: [...(playerStats.dailyActionLog || []), actionText] };\r\n\r\n    if (Math.random() * 100 < outcome.chance) {\r\n        const newInventory = [...nextPlayerStats.items];\r\n        const resultItemIndex = newInventory.findIndex(i => getTranslatedText(i.name, 'en') === recipe.result.name);\r\n        if (resultItemIndex > -1) newInventory[resultItemIndex].quantity += recipe.result.quantity;\r\n    else newInventory.push({ ...(recipe.result as PlayerItem), tier: resolveItemDef(recipe.result.name)?.tier || 1, emoji: recipe.result.emoji || resolveItemDef(recipe.result.name)?.emoji || '≡ƒôª' });\r\n        nextPlayerStats.items = newInventory;\r\n        \r\n        const successKeys: TranslationKey[] = ['craftSuccess1', 'craftSuccess2', 'craftSuccess3'];\r\n        const randomKey = successKeys[Math.floor(Math.random() * successKeys.length)];\r\n        addNarrativeEntry(t(randomKey, { itemName: t(recipe.result.name as TranslationKey) }), 'system');\r\n        toast({ title: t('craftSuccessTitle'), description: t('craftSuccess', { itemName: t(recipe.result.name as TranslationKey) }) });\r\n    } else {\r\n        const failKeys: TranslationKey[] = ['craftFail1', 'craftFail2', 'craftFail3'];\r\n        const randomKey = failKeys[Math.floor(Math.random() * failKeys.length)];\r\n        addNarrativeEntry(t(randomKey, { itemName: t(recipe.result.name as TranslationKey) }), 'system');\r\n        toast({ title: t('craftFailTitle'), description: t('craftFail', { itemName: t(recipe.result.name as TranslationKey) }), variant: 'destructive' });\r\n    }\r\n    setPlayerStats(() => nextPlayerStats);\r\n    advanceGameTime(nextPlayerStats);\r\n    }, [isLoading, isGameOver, setPlayerBehaviorProfile, playerStats, customItemDefinitions, addNarrativeEntry, toast, t, advanceGameTime, setPlayerStats]);\r\n\r\n  const handleItemUsed = useCallback((itemName: TranslatableString, target: 'player' | TranslatableString) => {\r\n    if (isLoading || isGameOver || !isLoaded) return;\r\n    const actionText = target === 'player' ? `${t('useAction')} ${t(itemName as TranslationKey)}` : `${t('useOnAction', {item: t(itemName as TranslationKey), target: t(target as TranslationKey)})}`;\r\n    addNarrativeEntry(actionText, 'action');\r\n    \r\n    handleOfflineItemUse(getTranslatedText(itemName, 'en'), getTranslatedText(target, 'en'));\r\n\r\n    }, [isLoading, isGameOver, isLoaded, t, handleOfflineItemUse, addNarrativeEntry]);\r\n\r\n  const handleUseSkill = useCallback((skillName: string) => {\r\n    if (isLoading || isGameOver || !isLoaded) return;\r\n    const actionText = `${t('useSkillAction')} ${skillName}`;\r\n    addNarrativeEntry(actionText, 'action');\r\n\r\n    handleOfflineSkillUse(skillName);\r\n    }, [isLoading, isGameOver, isLoaded, t, handleOfflineSkillUse, addNarrativeEntry]);\r\n\r\n  const handleBuild = useCallback((structureName: string) => {\r\n    if (isLoading || isGameOver) return;\r\n\r\n    const currentChunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n    if (currentChunk?.structures.length > 0) {\r\n        toast({ title: t('structureLimitTitle'), description: t('structureLimitDesc'), variant: \"destructive\" });\r\n        return;\r\n    }\r\n\r\n    const structureToBuild = buildableStructures[structureName];\r\n    if (!structureToBuild?.buildable) return;\r\n\r\n    const buildStaminaCost = 15;\r\n    if ((playerStats.stamina ?? 0) < buildStaminaCost) { toast({ title: t('notEnoughStamina'), description: t('notEnoughStaminaDesc', { cost: buildStaminaCost, current: (playerStats.stamina ?? 0).toFixed(0) }), variant: \"destructive\" }); return; }\r\n\r\n    const inventoryMap = new Map((playerStats.items || []).map(item => [getTranslatedText(item.name, 'en'), item.quantity]));\r\n    if (!structureToBuild.buildCost?.every((cost: any) => (inventoryMap.get(cost.name) || 0) >= cost.quantity)) { toast({ title: t('notEnoughIngredients'), variant: \"destructive\" }); return; }\r\n    \r\n    const actionText = t('buildConfirm',{structureName: t(structureName as TranslationKey)});\r\n    addNarrativeEntry(actionText, 'action');\r\n    let updatedItems = (playerStats.items || []).map(i => ({...i}));\r\n    structureToBuild.buildCost?.forEach((cost: any) => { updatedItems.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === cost.name)!.quantity -= cost.quantity; });\r\n    \r\n    const nextPlayerStats = { ...playerStats, items: updatedItems.filter(item => item.quantity > 0), stamina: playerStats.stamina - buildStaminaCost, dailyActionLog: [...(playerStats.dailyActionLog || []), actionText] };\r\n    \r\n    const key = `${playerPosition.x},${playerPosition.y}`;\r\n    setWorld(prev => {\r\n        const newWorld = { ...prev };\r\n        const chunkToUpdate = { ...newWorld[key]! };\r\n        const newStructure = { name: structureToBuild.name, description: t(structureToBuild.description as TranslationKey), emoji: structureToBuild.emoji, providesShelter: structureToBuild.providesShelter, restEffect: structureToBuild.restEffect, heatValue: structureToBuild.heatValue };\r\n        chunkToUpdate.structures = [...(chunkToUpdate.structures || []), newStructure];\r\n        newWorld[key] = chunkToUpdate;\r\n        return newWorld;\r\n    });\r\n\r\n    addNarrativeEntry(t('builtStructure', { structureName: t(structureName as TranslationKey) }), 'system');\r\n    setPlayerStats(() => nextPlayerStats);\r\n    advanceGameTime(nextPlayerStats);\r\n    }, [isLoading, isGameOver, buildableStructures, playerStats, playerPosition, addNarrativeEntry, advanceGameTime, toast, t, setWorld, world, setPlayerStats]);\r\n\r\n  const handleRest = useCallback(() => {\r\n    if (isLoading || isGameOver) return;\r\n    const shelter = world[`${playerPosition.x},${playerPosition.y}`]?.structures.find((s: any) => s.restEffect);\r\n    if (!shelter?.restEffect) { toast({ title: t('cantRestTitle'), description: t('cantRestDesc') }); return; }\r\n\r\n    const actionText = t('restInShelter', { shelterName: t(shelter.name as TranslationKey) });\r\n    addNarrativeEntry(actionText, 'action');\r\n    \r\n    const oldStats = {...playerStats};\r\n    const newHp = Math.min(100, oldStats.hp + shelter.restEffect.hp);\r\n    const newStamina = Math.min(100, oldStats.stamina + shelter.restEffect.stamina);\r\n    const newTemp = 37;\r\n\r\n    let restoredParts: string[] = [];\r\n    if (newHp > oldStats.hp) {\r\n        restoredParts.push(t('restHP', { amount: newHp - oldStats.hp }));\r\n    }\r\n    if (newStamina > oldStats.stamina) {\r\n        restoredParts.push(t('restStamina', { amount: (newStamina - oldStats.stamina).toFixed(0) }));\r\n    }\r\n\r\n    if(restoredParts.length > 0) {\r\n        addNarrativeEntry(t('restSuccess', { restoration: restoredParts.join(t('andConnector')) }), 'system');\r\n    } else {\r\n        addNarrativeEntry(t('restNoEffect'), 'system');\r\n    }\r\n\r\n    if(oldStats.bodyTemperature !== newTemp) {\r\n        addNarrativeEntry(t('restSuccessTemp'), 'system');\r\n    }\r\n\r\n    const nextPlayerStats = { ...playerStats, hp: newHp, stamina: newStamina, bodyTemperature: newTemp, dailyActionLog: [...(playerStats.dailyActionLog || []), actionText] };\r\n    setPlayerStats(() => nextPlayerStats);\r\n    advanceGameTime(nextPlayerStats);\r\n    }, [isLoading, isGameOver, world, playerPosition, addNarrativeEntry, advanceGameTime, t, toast, playerStats, setPlayerStats]);\r\n  \r\n  const handleFuseItems = useCallback(async (itemsToFuse: PlayerItem[]) => {\r\n    if (isLoading || isGameOver) return;\r\n    setIsLoading(true);\r\n\r\n    const baseChunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n    if (!baseChunk) { setIsLoading(false); return; }\r\n\r\n    const effectiveChunk = getEffectiveChunk(baseChunk, weatherZones, gameTime, sStart, sDayDuration);\r\n    const weather = weatherZones[effectiveChunk.regionId]?.currentWeather;\r\n    let successChanceBonus = playerStats.persona === 'artisan' ? 10 : 0;\r\n    let elementalAffinity: any = 'none';\r\n    let chaosFactor = effectiveChunk.magicAffinity;\r\n\r\n    if(weather?.exclusive_tags.includes('storm')) { successChanceBonus += 5; elementalAffinity = 'electric'; }\r\n    if(weather?.exclusive_tags.includes('heat')) elementalAffinity = 'fire';\r\n    if(effectiveChunk.dangerLevel > 80) { successChanceBonus -= 5; chaosFactor += 20; }\r\n    \r\n    const actionText = t('fuseAction', { items: itemsToFuse.map(i => t(i.name as TranslationKey)).join(', ') });\r\n    addNarrativeEntry(actionText, 'action');\r\n    let newItems = (playerStats.items || []).map(i => ({...i}));\r\n    itemsToFuse.forEach((item: PlayerItem) => { newItems.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === getTranslatedText(item.name, 'en'))!.quantity -= 1; });\r\n    let nextPlayerStats = { ...playerStats, items: newItems.filter(i => i.quantity > 0), dailyActionLog: [...(playerStats.dailyActionLog || []), actionText] };\r\n    setPlayerStats(() => nextPlayerStats);\r\n\r\n    try {\r\n        const normalizeChunkForAI = (c?: Chunk | null): Chunk | null => {\r\n            if (!c) return null;\r\n            const enemy = c.enemy ? { ...c.enemy, type: getTranslatedText(c.enemy.type ?? { en: '' }, language) } : null;\r\n            return { ...c, enemy } as Chunk;\r\n        };\r\n\r\n    const normalizedEffectiveChunk = normalizeChunkForAI(effectiveChunk as Chunk);\r\n\r\n        const result = await fuseItems({\r\n            itemsToFuse, playerPersona: playerStats.persona, currentChunk: normalizedEffectiveChunk as any,\r\n            environmentalContext: { biome: effectiveChunk.terrain, weather: t(weather?.name as TranslationKey) || 'clear' },\r\n            environmentalModifiers: { successChanceBonus, elementalAffinity, chaosFactor: clamp(chaosFactor, 0, 100) },\r\n            language, customItemDefinitions, fullItemCatalog: customItemCatalog,\r\n        });\r\n\r\n        addNarrativeEntry(result.narrative, 'narrative');\r\n        \r\n            if (result.resultItem) {\r\n            nextPlayerStats = { ...nextPlayerStats, items: [...nextPlayerStats.items] }; \r\n            const resultItemId = resolveItemId(result.resultItem.name, customItemDefinitions, t, language) ?? getTranslatedText(result.resultItem.name, 'en');\r\n            const existingItem = nextPlayerStats.items.find((i: PlayerItem) => i.id === resultItemId || getTranslatedText(i.name, 'en') === resultItemId);\r\n            if (existingItem) {\r\n                existingItem.quantity += result.resultItem!.baseQuantity.min;\r\n            } else {\r\n                const itemToAdd: PlayerItem = {\r\n                    name: result.resultItem.name,\r\n                    quantity: result.resultItem.baseQuantity.min,\r\n                    tier: result.resultItem.tier,\r\n                    emoji: result.resultItem.emoji,\r\n                    id: resultItemId\r\n                };\r\n                nextPlayerStats.items.push(ensurePlayerItemId(itemToAdd, customItemDefinitions, t, language));\r\n            }\r\n            \r\n            if(!resolveItemDef(resultItemId)) {\r\n                const newItem = result.resultItem;\r\n                setCustomItemCatalog(prev => [...prev, newItem]);\r\n                setCustomItemDefinitions(prev => ({ ...prev, [resultItemId]: { ...newItem }}));\r\n                if(db) {\r\n                    await setDoc(doc(db, \"world-catalog\", \"items\", \"generated\", resultItemId), newItem);\r\n                }\r\n            }\r\n        }\r\n        setPlayerStats(() => nextPlayerStats);\r\n        advanceGameTime(nextPlayerStats);\r\n    } catch(e) {\r\n        logger.error(\"AI Fusion failed:\", e);\r\n        toast({ title: t('error'), description: t('fusionError'), variant: \"destructive\" });\r\n        setPlayerStats(() => nextPlayerStats);\r\n        advanceGameTime(nextPlayerStats);\r\n    } finally {\r\n        setIsLoading(false);\r\n    }\r\n  }, [isLoading, isGameOver, world, playerPosition, playerStats, weatherZones, language, customItemDefinitions, customItemCatalog, addNarrativeEntry, advanceGameTime, t, toast, setIsLoading, setPlayerStats, setCustomItemCatalog, setCustomItemDefinitions, gameTime]);\r\n\r\n  const handleRequestQuestHint = useCallback(async (questText: string) => {\r\n    if (playerStats.questHints?.[questText] || !isOnline) return;\r\n\r\n    try {\r\n        const result = await provideQuestHint({ questText, language });\r\n        setPlayerStats(prev => ({ ...prev, questHints: { ...prev.questHints, [questText]: result.hint } }));\r\n    } catch (error) {\r\n        logger.error(\"Failed to get quest hint:\", error);\r\n        toast({ title: t('error'), description: t('suggestionError'), variant: \"destructive\" });\r\n    }\r\n  }, [playerStats.questHints, isOnline, language, setPlayerStats, toast, t]);\r\n\r\n  const handleEquipItem = useCallback((itemName: string) => {\r\n    if (isLoading || isGameOver) return;\r\n\r\n    setPlayerStats(prevStats => {\r\n        const newStats: PlayerStatus = JSON.parse(JSON.stringify(prevStats));\r\n    const itemDef = resolveItemDef(getTranslatedText(itemName as TranslationKey, 'en'));\r\n        if (!itemDef || !itemDef.equipmentSlot) return prevStats;\r\n\r\n        const itemToEquipIndex = newStats.items.findIndex(i => getTranslatedText(i.name, 'en') === getTranslatedText(itemName as TranslationKey, 'en'));\r\n        if (itemToEquipIndex === -1) return prevStats; \r\n    \r\n        const itemToEquip = newStats.items[itemToEquipIndex];\r\n        const slot = itemDef.equipmentSlot!;\r\n    \r\n        const currentEquipped = (newStats.equipment as any)[slot];\r\n        if (currentEquipped) {\r\n            const existingInInventory = newStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === getTranslatedText(currentEquipped.name, 'en'));\r\n            if (existingInInventory) {\r\n                existingInInventory.quantity += 1;\r\n            } else {\r\n                newStats.items.push(ensurePlayerItemId({ ...currentEquipped, quantity: 1 }, customItemDefinitions, t, language));\r\n            }\r\n        }\r\n    \r\n        (newStats.equipment as any)[slot] = { name: itemToEquip.name, quantity: 1, tier: itemToEquip.tier, emoji: itemDef.emoji };\r\n    \r\n        if (itemToEquip.quantity > 1) {\r\n            itemToEquip.quantity -= 1;\r\n        } else {\r\n            newStats.items.splice(itemToEquipIndex, 1);\r\n        }\r\n        \r\n        let basePhysAtk = 10, baseMagAtk = 5, baseCrit = 5, baseAtkSpd = 1.0, baseCd = 0, basePhysDef = 0, baseMagDef = 0;\r\n    Object.values(newStats.equipment).forEach((equipped: any) => {\r\n            if (equipped) {\r\n                const def = resolveItemDef(getTranslatedText(equipped.name, 'en'));\r\n                if (def?.attributes) {\r\n                    basePhysAtk += def.attributes.physicalAttack || 0;\r\n                    baseMagAtk += def.attributes.magicalAttack || 0;\r\n                    baseCrit += def.attributes.critChance || 0;\r\n                    baseAtkSpd += def.attributes.attackSpeed || 0;\r\n                    baseCd += def.attributes.cooldownReduction || 0;\r\n                    basePhysDef += def.attributes.physicalDefense || 0;\r\n                    baseMagDef += def.attributes.magicalDefense || 0;\r\n                }\r\n            }\r\n        });\r\n        newStats.attributes = { physicalAttack: basePhysAtk, magicalAttack: baseMagAtk, physicalDefense: basePhysDef, magicalDefense: baseMagDef, critChance: baseCrit, attackSpeed: baseAtkSpd, cooldownReduction: baseCd };\r\n\r\n        return newStats;\r\n    });\r\n  }, [isLoading, isGameOver, customItemDefinitions, setPlayerStats]);\r\n  \r\n  const handleUnequipItem = useCallback((slot: EquipmentSlot) => {\r\n    if (isLoading || isGameOver) return;\r\n\r\n    setPlayerStats(prevStats => {\r\n        const newStats: PlayerStatus = JSON.parse(JSON.stringify(prevStats));\r\n        const itemToUnequip = newStats.equipment[slot];\r\n        if (!itemToUnequip) return prevStats;\r\n\r\n    const existingInInventory = newStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === getTranslatedText(itemToUnequip.name, 'en'));\r\n        if (existingInInventory) {\r\n            existingInInventory.quantity += 1;\r\n        } else {\r\n            const itemDef = resolveItemDef(getTranslatedText(itemToUnequip.name, 'en'));\r\n            newStats.items.push(ensurePlayerItemId({ ...itemToUnequip, quantity: 1, emoji: itemDef?.emoji || '≡ƒôª' }, customItemDefinitions, t, language));\r\n        }\r\n\r\n        (newStats.equipment as any)[slot] = null;\r\n        \r\n        let basePhysAtk = 10, baseMagAtk = 5, baseCrit = 5, baseAtkSpd = 1.0, baseCd = 0, basePhysDef = 0, baseMagDef = 0;\r\n    Object.values(newStats.equipment).forEach((equipped: any) => {\r\n            if (equipped) {\r\n                const def = resolveItemDef(getTranslatedText(equipped.name, 'en'));\r\n                if (def?.attributes) {\r\n                    basePhysAtk += def.attributes.physicalAttack || 0;\r\n                    baseMagAtk += def.attributes.magicalAttack || 0;\r\n                    baseCrit += def.attributes.critChance || 0;\r\n                    baseAtkSpd += def.attributes.attackSpeed || 0;\r\n                    baseCd += def.attributes.cooldownReduction || 0;\r\n                    basePhysDef += def.attributes.physicalDefense || 0;\r\n                    baseMagDef += def.attributes.magicalDefense || 0;\r\n                }\r\n            }\r\n        });\r\n        newStats.attributes = { physicalAttack: basePhysAtk, magicalAttack: baseMagAtk, physicalDefense: basePhysDef, magicalDefense: baseMagDef, critChance: baseCrit, attackSpeed: baseAtkSpd, cooldownReduction: baseCd };\r\n        \r\n        return newStats;\r\n    });\r\n  }, [isLoading, isGameOver, customItemDefinitions, setPlayerStats]);\r\n\r\n  const handleReturnToMenu = () => {\r\n    window.location.href = '/';\r\n  };\r\n\r\n  const handleHarvest = useCallback((actionId: number) => {\r\n    if (isLoading || isGameOver || !isLoaded) return;\r\n    const chunk = world[`${playerPosition.x},${playerPosition.y}`];\r\n    if(!chunk) return;\r\n    \r\n    const action = chunk.actions.find((a: any) => a.id === actionId);\r\n    if (!action) {\r\n        toast({ title: t('actionNotAvailableTitle'), description: t('actionNotAvailableDesc'), variant: 'destructive' });\r\n        return;\r\n    }\r\n\r\n    const targetName = action.params?.targetName as string;\r\n    const enemy = chunk.enemy;\r\n    if (!enemy || getTranslatedText(enemy.type, 'en') !== targetName || !enemy.harvestable) {\r\n        toast({ title: t('actionNotAvailableTitle'), description: t('cantHarvest'), variant: 'destructive' });\r\n        return;\r\n    }\r\n\r\n    const requiredTool = enemy.harvestable.requiredTool;\r\n    const playerHasTool = (playerStats.items || []).some(item => getTranslatedText(item.name, 'en') === requiredTool);\r\n\r\n    if (!playerHasTool) {\r\n        toast({ title: t('harvestFail_noTool'), description: t('harvestFail_noTool_desc', { tool: t(requiredTool as TranslationKey), target: t(targetName as TranslationKey) }), variant: 'destructive' });\r\n        return;\r\n    }\r\n    \r\n    const actionText = t('harvestAction', { target: t(targetName as TranslationKey) });\r\n    addNarrativeEntry(actionText, 'action');\r\n\r\n    let nextPlayerStats = { ...playerStats };\r\n    nextPlayerStats.items = nextPlayerStats.items || [];\r\n    let worldWasModified = false;\r\n    const newWorld = { ...world };\r\n    \r\n    const lootItems: ChunkItem[] = [];\r\n    enemy.harvestable.loot.forEach((loot: any) => {\r\n        if (Math.random() < loot.chance) {\r\n        const itemDef = resolveItemDef(loot.name);\r\n            if(itemDef) {\r\n                lootItems.push({\r\n                    ...itemDef,\r\n                    description: t(itemDef.description as TranslationKey),\r\n                    quantity: clamp(Math.floor(Math.random() * (itemDef.baseQuantity.max - itemDef.baseQuantity.min + 1)) + itemDef.baseQuantity.min, 1, Infinity)\r\n                });\r\n            }\r\n        }\r\n    });\r\n    \r\n    if (lootItems.length > 0) {\r\n        const lootText = lootItems.map(l => `${l.quantity} ${t(l.name as TranslationKey)}`).join(', ');\r\n        addNarrativeEntry(t('harvestSuccess', { loot: lootText, target: t(targetName as TranslationKey)}), 'system');\r\n        \r\n        lootItems.forEach((lootItem: ChunkItem) => {\r\n            const existingItem = nextPlayerStats.items.find((i: PlayerItem) => getTranslatedText(i.name, 'en') === getTranslatedText(lootItem.name, 'en'));\r\n            if(existingItem) {\r\n                existingItem.quantity += lootItem.quantity;\r\n            } else {\r\n                nextPlayerStats.items.push(ensurePlayerItemId(lootItem as PlayerItem, customItemDefinitions, t, language));\r\n            }\r\n        });\r\n    } else {\r\n        addNarrativeEntry(t('harvestFail_noLoot', { target: t(targetName as TranslationKey) }), 'system');\r\n    }\r\n\r\n    newWorld[`${playerPosition.x},${playerPosition.y}`]!.enemy = null;\r\n    newWorld[`${playerPosition.x},${playerPosition.y}`]!.actions = newWorld[`${playerPosition.x},${playerPosition.y}`]!.actions.filter((a: any) => a.id !== actionId);\r\n    worldWasModified = true;\r\n    \r\n    if(worldWasModified) {\r\n        setWorld(() => newWorld);\r\n    }\r\n\r\n    setPlayerStats(() => nextPlayerStats);\r\n    advanceGameTime(nextPlayerStats);\r\n    }, [isLoading, isGameOver, isLoaded, world, playerPosition, playerStats, toast, t, addNarrativeEntry, customItemDefinitions, advanceGameTime, setWorld, setPlayerStats]);\r\n\r\n  const handleMove = useCallback((direction: \"north\" | \"south\" | \"east\" | \"west\") => {\r\n    if (isLoading || isGameOver) return;\r\n\r\n    let { x, y } = playerPosition;\r\n    if (direction === \"north\") y += 1;\r\n    if (direction === \"south\") y -= 1;\r\n    if (direction === \"east\") x += 1;\r\n    if (direction === \"west\") x -= 1;\r\n    \r\n    const nextChunkKey = `${x},${y}`;\r\n    let worldSnapshot = { ...world };\r\n    const nextChunk = worldSnapshot[nextChunkKey];\r\n\r\n    if (nextChunk?.terrain === 'wall') {\r\n        addNarrativeEntry(t('wallBlock'), 'system');\r\n        return;\r\n    }\r\n     if (nextChunk?.terrain === 'ocean' && !(playerStats.items || []).some(item => getTranslatedText(item.name, 'en') === 'inflatable_raft')) {\r\n        addNarrativeEntry(t('oceanTravelBlocked'), 'system');\r\n        return;\r\n    }\r\n    \r\n    setPlayerBehaviorProfile(prev => ({ ...prev, moves: prev.moves + 1 }));\r\n    \r\n    const dirKey = `direction${direction.charAt(0).toUpperCase() + direction.slice(1)}` as TranslationKey;\r\n    const directionText = t(dirKey);\r\n    const actionText = t('wentDirection', { direction: directionText });\r\n    addNarrativeEntry(actionText, 'action');\r\n\r\n    // optimistic placeholder: add a low-detail movement narrative immediately\r\n    const placeholderId = `${Date.now()}-move-${x}-${y}`;\r\n    // choose short vs long placeholder based on narrative length setting\r\n    const movingKey = settings.narrativeLength === 'long' ? 'movingLong' : 'movingShort';\r\n    // brief_sensory will be computed after we read finalChunk (best-effort)\r\n    const placeholderText = t(movingKey as TranslationKey, { direction: directionText, brief_sensory: '' });\r\n    addNarrativeEntry(placeholderText, 'narrative', placeholderId);\r\n\r\n    setPlayerPosition({ x, y });\r\n    \r\n    const staminaCost = worldSnapshot[nextChunkKey]?.travelCost ?? 1;\r\n    \r\n    let newPlayerStats = { ...playerStats };\r\n    if ((playerStats.stamina ?? 0) > staminaCost) {\r\n        newPlayerStats.stamina = (newPlayerStats.stamina ?? 0) - staminaCost;\r\n    } else {\r\n        newPlayerStats.stamina = 0;\r\n        newPlayerStats.hp = (newPlayerStats.hp ?? 0) - 5;\r\n    }\r\n    newPlayerStats.dailyActionLog = [...(playerStats.dailyActionLog || []), actionText];\r\n    \r\n    advanceGameTime(newPlayerStats, { x, y });\r\n\r\n    const finalChunk = worldSnapshot[`${x},${y}`];\r\n        if (finalChunk) {\r\n            // Best-effort: compute a short, localized sensory hint from the chunk\r\n            let briefSensory = '';\r\n            try {\r\n                const computeBriefSensory = (c: any) => {\r\n                    // Pick the single most prominent sensory condition (temperature/moisture/light)\r\n                    // to avoid chaining multiple 'in the X, in the Y' fragments. We choose the\r\n                    // condition with the largest deviation from neutral and render one concise\r\n                    // localized phrase based on that.\r\n                    const scores: { key: string; score: number }[] = [];\r\n                    if (typeof c.temperature === 'number') {\r\n                        // score = distance from comfortable (50) biasing extremes\r\n                        const temp = c.temperature;\r\n                        const score = Math.abs(temp - 50) + (temp >= 80 || temp <= 10 ? 20 : 0);\r\n                        scores.push({ key: 'temperature', score });\r\n                    }\r\n                    if (typeof c.moisture === 'number') {\r\n                        const m = c.moisture;\r\n                        const score = Math.abs(m - 50) + (m >= 80 || m <= 20 ? 15 : 0);\r\n                        scores.push({ key: 'moisture', score });\r\n                    }\r\n                    if (typeof c.lightLevel === 'number') {\r\n                        // lightLevel in this project is typically -100..100; treat low values as dark\r\n                        const l = c.lightLevel;\r\n                        // light extremes get a boost\r\n                        const score = Math.abs((l <= 0 ? 0 - l : 100 - l)) + (l <= 10 ? 10 : 0);\r\n                        scores.push({ key: 'light', score });\r\n                    }\r\n\r\n                    // fallback: if nothing numeric present, return empty\r\n                    if (scores.length === 0) return '';\r\n\r\n                    scores.sort((a, b) => b.score - a.score);\r\n                    const primary = scores[0].key;\r\n\r\n                    // language-aware short patterns (keep these short so optimistic placeholder is not verbose)\r\n                    const patternsEn = [\r\n                        \"it's {adj}.\",\r\n                        \"the air feels {adj}.\",\r\n                        \"a {adj} hush falls over the area.\",\r\n                        \"{adj} surrounds you.\",\r\n                        \"you notice it is {adj}.\"\r\n                    ];\r\n                    const patternsVi = [\r\n                        \"{adj}.\",\r\n                        \"kh├┤ng kh├¡ c├│ cß║úm gi├íc {adj}.\",\r\n                        \"mß╗Öt bß║ºu kh├┤ng kh├¡ {adj} bao tr├╣m.\",\r\n                        \"bß║ín nhß║¡n thß║Ñy n╞íi n├áy {adj}.\",\r\n                        \"cß║úm gi├íc chiß║┐c {adj} len lß╗Åi.\" // intentionally short\r\n                    ];\r\n\r\n                    // Helper: pick a localized adjective based on the primary condition\r\n                    const pickAdj = () => {\r\n                        try {\r\n                            // Use the shared keyword variations DB if available on window scope via import\r\n                            // but to avoid extra imports here, prefer existing translation keys for simple mapping.\r\n                            if (primary === 'temperature') {\r\n                                if (c.temperature >= 80) return t('temp_hot') || 'scorching';\r\n                                if (c.temperature <= 10) return t('temp_cold') || 'freezing';\r\n                                return t('temp_mild') || 'mild';\r\n                            }\r\n                            if (primary === 'moisture') {\r\n                                if (c.moisture >= 80) return t('moisture_humid') || 'humid';\r\n                                if (c.moisture <= 20) return t('moisture_dry') || 'dry';\r\n                                return t('moisture_normal') || 'fresh';\r\n                            }\r\n                            if (primary === 'light') {\r\n                                if (c.lightLevel <= 10) return t('light_level_dark') || 'dark';\r\n                                if (c.lightLevel <= 40) return t('light_level_dim') || 'dim';\r\n                                return t('light_level_normal') || 'bright';\r\n                            }\r\n                        } catch (e) {\r\n                            // fallback\r\n                        }\r\n                        return '';\r\n                    };\r\n\r\n                    const adj = pickAdj();\r\n                    const patterns = language === 'vi' ? patternsVi : patternsEn;\r\n                    const chosenPattern = patterns[Math.floor(Math.random() * patterns.length)];\r\n                    // Insert adjective into pattern; keep result short and trimmed.\r\n                    return chosenPattern.replace('{adj}', adj).replace(/\\s+/g, ' ').trim();\r\n                };\r\n\r\n                    briefSensory = computeBriefSensory(finalChunk);\r\n                    if (briefSensory && briefSensory.length > 0) {\r\n                        const updatedPlaceholder = t(movingKey as TranslationKey, { direction: directionText, brief_sensory: briefSensory });\r\n                        // replace the optimistic placeholder with the improved brief sensory text\r\n                        addNarrativeEntry(String(updatedPlaceholder).replace(/\\{[^}]+\\}/g, '').trim(), 'narrative', placeholderId);\r\n                    }\r\n            } catch (e) {\r\n                // non-fatal: if computing brief sensory fails, continue to orchestrator/fallback\r\n                 \r\n                console.warn('[narrative] brief sensory computation failed', e);\r\n            }\r\n\r\n            // If the player moved repeatedly inside the same biome, prefer a short\r\n            // \"continuation\" template (a smaller, linking sentence) rather than\r\n            // loading a full descriptive template. This keeps movement prose compact.\r\n            try {\r\n                const prevChunk = worldSnapshot[`${playerPosition.x},${playerPosition.y}`];\r\n                if (prevChunk && prevChunk.terrain && finalChunk.terrain && String(prevChunk.terrain) === String(finalChunk.terrain)) {\r\n                    const db = getKeywordVariations(language as any);\r\n                    const pool = (db as any)[`${String(finalChunk.terrain).toLowerCase()}_continuation`] || (db as any)['continuation'];\r\n                    if (pool && Array.isArray(pool) && pool.length > 0) {\r\n                        const pick = pool[Math.floor(Math.random() * pool.length)];\r\n                        // Replace simple tokens\r\n                        const text = String(pick).replace('{direction}', directionText).replace('{biome}', t(finalChunk.terrain as TranslationKey));\r\n                        addNarrativeEntry(text, 'narrative', placeholderId);\r\n                        lastMoveRef.current = { biome: finalChunk.terrain, time: Date.now() };\r\n                        return;\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                // non-fatal\r\n            }\r\n\r\n                // Try to use precomputed bundle + runtime orchestrator first (lazy-loaded).\r\n                (async () => {\r\n                // First, attempt conditional movement templates (fast, local)\r\n                try {\r\n                    try {\r\n                        const mn = await import('@/lib/game/movement-narrative');\r\n                        const conditional = mn.selectMovementNarrative({ chunk: finalChunk, playerStats: newPlayerStats || playerStats, directionText, language, briefSensory });\r\n                        if (conditional) {\r\n                            addNarrativeEntry(String(conditional).replace(/\\{[^}]+\\}/g, '').trim(), 'narrative', placeholderId);\r\n                            return;\r\n                        }\r\n                    } catch (e) {\r\n                        // non-fatal: if selector import or execution fails, continue to loader\r\n                    }\r\n                } catch (e) {\r\n                    // ignore and fallthrough to precomputed loader\r\n                }\r\n                try {\r\n                    const loaderMod = await import('@/lib/narrative/loader');\r\n                    const orchestrator = await import('@/lib/narrative/runtime-orchestrator');\r\n                    const biomeKey = finalChunk.terrain || finalChunk.biome || 'default';\r\n                    const bundle = await loaderMod.loadPrecomputedBundle(biomeKey, language);\r\n                    if (bundle && bundle.templates && bundle.templates.length > 0) {\r\n                        // Use conditional-aware orchestrator pick if available\r\n                        try {\r\n                            const res = orchestrator.pickVariantFromBundleWithConditions\r\n                                ? orchestrator.pickVariantFromBundleWithConditions(bundle as any, { chunk: finalChunk, playerStats: newPlayerStats || playerStats, briefSensory }, { seed: `${x},${y}`, persona: undefined })\r\n                                : null;\r\n                            if (res && res.text) {\r\n                                let finalText = String(res.text);\r\n                                // Replace brief_sensory placeholder if present\r\n                                if (briefSensory && briefSensory.length > 0) {\r\n                                    finalText = finalText.replace(/\\{\\s*brief_sensory\\s*\\}/g, briefSensory).replace(/{{\\s*brief_sensory\\s*}}/g, briefSensory);\r\n                                }\r\n                                finalText = finalText.replace(/\\{[^}]+\\}/g, '').trim();\r\n                                addNarrativeEntry(finalText, 'narrative', placeholderId);\r\n                                return;\r\n                            }\r\n                        } catch (e) {\r\n                            // fall back to deterministic index-based pick\r\n                            const seed = `${x},${y}`;\r\n                            const idx = Math.abs(seed.split('').reduce((s, c) => s + c.charCodeAt(0), 0)) % bundle.templates.length;\r\n                            const tplId = bundle.templates[idx].id;\r\n                            const res = orchestrator.pickVariantFromBundle(bundle as any, tplId, { seed, persona: undefined });\r\n                            if (res && res.text) {\r\n                                const finalText = String(res.text).replace(/\\{[^}]+\\}/g, '').trim();\r\n                                addNarrativeEntry(finalText, 'narrative', placeholderId);\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    // If anything fails, fall back to legacy offline generator\r\n                     \r\n                    console.warn('[narrative] precomputed load failed, falling back', String(e));\r\n                }\r\n                // fallback: use offline generator but reduce verbosity if this is a repeated movement\r\n                const recent = narrativeLogRef.current?.slice(-6) || [];\r\n                const repeatCount = recent.reduce((acc, e) => {\r\n                    const txt = (typeof e === 'string' ? e : (e.text || '')).toLowerCase();\r\n                    if (txt.includes(directionText.toLowerCase()) || txt.includes((finalChunk.terrain || '').toLowerCase())) return acc + 1;\r\n                    return acc;\r\n                }, 0);\r\n                const effectiveLength = (repeatCount >= 3) ? 'short' : settings.narrativeLength;\r\n                let narrative = generateOfflineNarrative(finalChunk, effectiveLength as any, worldSnapshot, { x, y }, t, language);\r\n                narrative = String(narrative).replace(/\\{[^}]+\\}/g, '').trim();\r\n                addNarrativeEntry(narrative, 'narrative', placeholderId);\r\n            })();\r\n        }\r\n\r\n    }, [isLoading, isGameOver, playerPosition, world, addNarrativeEntry, t, playerStats, setPlayerBehaviorProfile, setPlayerPosition, settings.narrativeLength, language, advanceGameTime]);\r\n\r\n  return {\r\n    handleMove,\r\n    handleAttack,\r\n    handleAction,\r\n    handleCustomAction,\r\n    handleCraft,\r\n    handleBuild,\r\n    handleItemUsed,\r\n    handleUseSkill,\r\n    handleRest,\r\n    handleFuseItems,\r\n    handleRequestQuestHint,\r\n    handleEquipItem,\r\n    handleUnequipItem,\r\n    handleReturnToMenu,\r\n    handleHarvest,\r\n  };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-game-effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-game-engine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":211,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":211,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":237,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":237,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'innerErr' is defined but never used.","line":252,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":252,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n'use client';\r\n\r\nimport { useRef, useEffect } from 'react';\r\nimport { useLanguage } from '@/context/language-context';\r\nimport { applyTickEffects } from '@/lib/game/effect-engine';\r\nimport type { PlayerStatusDefinition } from '@/lib/game/types';\r\nimport { CreatureEngine } from '@/core/engines/creature-engine';\r\nimport { PlantEngine } from '@/core/engines/plant-engine';\r\nimport { EffectEngine } from '@/core/engines/effect-engine';\r\nimport { WeatherEngine } from '@/core/engines/weather-engine';\r\nimport { WeatherType, WeatherIntensity, WeatherCondition } from '@/core/types/weather';\r\nimport { GridPosition } from '@/core/values/grid-position';\r\nimport { useGameState } from \"./use-game-state\";\r\nimport { useActionHandlers } from \"./use-action-handlers\";\r\nimport { useGameEffects } from \"./useGameEffects\";\r\nimport { useSettings } from \"@/context/settings-context\"; // Import useSettings\r\n\r\ninterface GameEngineProps {\r\n    gameSlot: number;\r\n}\r\n\r\n/**\r\n * The main Game Engine hook.\r\n * This hook acts as the primary \"Manager\" or \"Orchestrator\" in our architecture.\r\n * Its main responsibility is to assemble all the specialized \"workers\" (other hooks)\r\n * and provide a single, clean interface for the UI (the GameLayout component) to interact with.\r\n *\r\n * It follows the \"separation of concerns\" principle:\r\n * - `useGameState`: Manages all the raw state of the game.\r\n * - `useActionHandlers`: Contains the logic for *how* to execute player actions (the \"How\").\r\n * - `useGameEffects`: Manages all side effects that react to state changes (saving, game over checks, etc.).\r\n * - `GameLayout`: The UI layer, which only knows *what* action it wants to perform (the \"What\"),\r\n *   and calls the appropriate function provided by this engine.\r\n */\r\nexport function useGameEngine(props: GameEngineProps) {\r\n    const gameState = useGameState(props);\r\n    const { biomeDefinitions } = gameState as any;\r\n    const narrativeContainerRef = useRef<HTMLDivElement>(null);\r\n    const narrativeLogRef = useRef(gameState.narrativeLog || [] as any[]);\r\n    const { t } = useLanguage();\r\n    const { settings } = useSettings(); // Use settings context\r\n\r\n    // Initialize creature engine\r\n    const creatureEngineRef = useRef(new CreatureEngine(t));\r\n\r\n    // Initialize effect engine\r\n    const effectEngineRef = useRef(new EffectEngine());\r\n\r\n    // Define weather data with realistic base temperatures\r\n    const weatherData: Map<WeatherType, WeatherCondition> = new Map([\r\n        [WeatherType.CLEAR, {\r\n            type: WeatherType.CLEAR,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600, // 1 hour\r\n            effects: [],\r\n            temperature: 22, // Average grassland temperature\r\n            windSpeed: 10,\r\n            precipitation: 0,\r\n            cloudCover: 0,\r\n            visibility: 100,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.CLOUDY, {\r\n            type: WeatherType.CLOUDY,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 20, // Slightly cooler\r\n            windSpeed: 15,\r\n            precipitation: 0,\r\n            cloudCover: 60,\r\n            visibility: 80,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.RAIN, {\r\n            type: WeatherType.RAIN,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 17, // Cooler during rain\r\n            windSpeed: 20,\r\n            precipitation: 50,\r\n            cloudCover: 80,\r\n            visibility: 70,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.SNOW, {\r\n            type: WeatherType.SNOW,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 0, // Cold during snow\r\n            windSpeed: 25,\r\n            precipitation: 30,\r\n            cloudCover: 90,\r\n            visibility: 50,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.WIND, {\r\n            type: WeatherType.WIND,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 20, // Neutral temperature\r\n            windSpeed: 35,\r\n            precipitation: 0,\r\n            cloudCover: 20,\r\n            visibility: 85,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.STORM, {\r\n            type: WeatherType.STORM,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 15, // Stormy and cool\r\n            windSpeed: 40,\r\n            precipitation: 70,\r\n            cloudCover: 95,\r\n            visibility: 40,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.FOG, {\r\n            type: WeatherType.FOG,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 18, // Cool and damp\r\n            windSpeed: 5,\r\n            precipitation: 10,\r\n            cloudCover: 100,\r\n            visibility: 30,\r\n            transitions: []\r\n        }],\r\n        [WeatherType.HEATWAVE, {\r\n            type: WeatherType.HEATWAVE,\r\n            intensity: WeatherIntensity.NORMAL,\r\n            duration: 3600,\r\n            effects: [],\r\n            temperature: 35, // Hot during heatwave\r\n            windSpeed: 10,\r\n            precipitation: 0,\r\n            cloudCover: 20,\r\n            visibility: 90,\r\n            transitions: []\r\n        }]\r\n    ]);\r\n\r\n    // Initialize weather engine\r\n    const weatherEngineRef = useRef(new WeatherEngine(effectEngineRef.current, weatherData));\r\n\r\n    // Initialize plant engine\r\n    const plantEngineRef = useRef(new PlantEngine(t));\r\n\r\n    const addNarrativeEntry = (text: string, type: 'narrative' | 'action' | 'system' | 'monologue', entryId?: string) => {\r\n        // Preserve explicit entryId when provided (placeholders use predictable ids).\r\n        // If no id provided, generate a stable unique id.\r\n        const id = entryId ?? `${Date.now()}_${Math.random().toString(36).slice(2,9)}`;\r\n        const entry = { id, text, type } as any;\r\n        gameState.setNarrativeLog(prev => {\r\n            const arr = (prev || []);\r\n            const existingIdx = arr.findIndex((e: any) => e.id === id);\r\n            let next: any[];\r\n            if (existingIdx >= 0) {\r\n                // Replace existing entry in-place to avoid duplicates when updating placeholders\r\n                next = arr.map((e: any) => e.id === id ? { ...e, text: entry.text, type: entry.type } : e);\r\n            } else {\r\n                next = [...arr, entry];\r\n            }\r\n            // Defensive dedupe: keep last occurrence for each id (handles race conditions)\r\n            const deduped = Array.from(new Map(next.map((e: any) => [e.id, e])).values());\r\n            narrativeLogRef.current = deduped;\r\n            return deduped;\r\n        });\r\n    };\r\n\r\n    const advanceGameTime = (stats?: any) => {\r\n        const currentTurn = gameState.turn || 0;\r\n\r\n        gameState.setGameTime(prev => {\r\n                const next = prev + (settings as any).timePerTurn; // Use timePerTurn from settings\r\n                if (next >= (settings as any).dayDuration) { // Use dayDuration from settings\r\n                    gameState.setDay(d => d + 1);\r\n                    gameState.setTurn(t => t + 1);\r\n                    return next % (settings as any).dayDuration; // Use dayDuration from settings\r\n            }\r\n            gameState.setTurn(t => t + 1);\r\n            return next;\r\n        });\r\n\r\n        // If caller provided a candidate stats object, apply per-tick effects\r\n        if (stats) {\r\n            const newStats = { ...stats } as PlayerStatusDefinition;\r\n            const { newStats: updated, messages } = applyTickEffects(newStats, currentTurn, t);\r\n            for (const m of messages) addNarrativeEntry(m.text, m.type);\r\n            gameState.setPlayerStats(() => updated);\r\n        }\r\n\r\n        // Update weather engine\r\n        weatherEngineRef.current.update(gameState.gameTime);\r\n\r\n        // Apply weather effects to player's current cell\r\n        const playerPosition = new GridPosition(gameState.playerPosition.x, gameState.playerPosition.y);\r\n        if (gameState.world && typeof gameState.world.getCellAt === 'function') {\r\n            try {\r\n                const playerCurrentCell = gameState.world.getCellAt(playerPosition);\r\n                if (playerCurrentCell) {\r\n                    weatherEngineRef.current.applyWeatherEffects(playerCurrentCell, gameState.playerStats);\r\n                }\r\n            } catch (error) {\r\n                console.warn('World getCellAt method not available or failed, skipping weather effects');\r\n            }\r\n        }\r\n\r\n        // (Plant updates moved after visibleChunks are assembled)\r\n\r\n        // Update creatures\r\n        // Get visible chunks around the player for creature simulation\r\n        const visibleChunks = new Map<string, any>();\r\n        const viewRadius = 5; // Include chunks within 5 tiles of the player\r\n\r\n        // Add current chunk if it exists\r\n        if (gameState.currentChunk) {\r\n            const chunkKey = `${gameState.currentChunk.x},${gameState.currentChunk.y}`;\r\n            visibleChunks.set(chunkKey, gameState.currentChunk);\r\n        }\r\n\r\n        // Add surrounding chunks if world data is available\r\n        if (gameState.world && typeof gameState.world.getChunksInArea === 'function') {\r\n            try {\r\n                const surroundingChunks = gameState.world.getChunksInArea(playerPosition, viewRadius);\r\n                for (const chunk of surroundingChunks) {\r\n                    const chunkKey = `${chunk.x},${chunk.y}`;\r\n                    visibleChunks.set(chunkKey, chunk);\r\n                }\r\n            } catch (error) {\r\n                // Fallback to just current chunk if world methods are not available\r\n                console.warn('World getChunksInArea method not available, attempting per-cell getCellAt fallback for visibleChunks');\r\n                // Try to fill visibleChunks by querying getCellAt for each coordinate in viewRadius\r\n                if (gameState.world && typeof gameState.world.getCellAt === 'function' && gameState.currentChunk) {\r\n                    const cx = gameState.currentChunk.x;\r\n                    const cy = gameState.currentChunk.y;\r\n                    for (let dx = -viewRadius; dx <= viewRadius; dx++) {\r\n                        for (let dy = -viewRadius; dy <= viewRadius; dy++) {\r\n                            try {\r\n                                const cell = gameState.world.getCellAt(new GridPosition(cx + dx, cy + dy));\r\n                                if (cell) {\r\n                                    const key = `${cell.x},${cell.y}`;\r\n                                    visibleChunks.set(key, cell);\r\n                                }\r\n                            } catch (innerErr) {\r\n                                // ignore missing cells\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    console.warn('World getCellAt not available; visibleChunks will contain only currentChunk');\r\n                }\r\n            }\r\n        }\r\n\r\n            // Update plants in visible area\r\n            try {\r\n                const plantMessages = plantEngineRef.current.updatePlants(currentTurn, visibleChunks, gameState.currentSeason, gameState.worldProfile);\r\n                for (const m of plantMessages) addNarrativeEntry(m.text, m.type);\r\n            } catch (err) {\r\n                console.warn('PlantEngine update failed', err);\r\n            }\r\n\r\n        const creatureMessages = creatureEngineRef.current.updateCreatures(\r\n            currentTurn,\r\n            playerPosition,\r\n            gameState.playerStats,\r\n            visibleChunks\r\n        );\r\n\r\n        // Add creature messages to narrative\r\n        for (const message of creatureMessages) {\r\n            addNarrativeEntry(message.text, message.type);\r\n        }\r\n    };\r\n    \r\n    // This effect ensures that whenever the narrativeLog changes, we scroll to the bottom.\r\n    // The dependency array [gameState.narrativeLog] triggers the effect on every new entry.\r\n    useEffect(() => {\r\n        const container = narrativeContainerRef.current;\r\n        if (container) {\r\n            // We use a small timeout to ensure the DOM has updated with the new element before we try to scroll.\r\n            setTimeout(() => {\r\n                const lastElementId = gameState.narrativeLog[gameState.narrativeLog.length - 1]?.id;\r\n                if (lastElementId) {\r\n                    const lastElement = container.querySelector('#' + CSS.escape(lastElementId));\r\n                    if (lastElement) {\r\n                        lastElement.scrollIntoView({ behavior: 'smooth', block: 'end' });\r\n                    }\r\n                } else {\r\n                    // Fallback for initial load or if ID is not found\r\n                    container.scrollTop = container.scrollHeight;\r\n                }\r\n            }, 50);\r\n        }\r\n    }, [gameState.narrativeLog]);\r\n    \r\n\r\n    const actionHandlers = useActionHandlers({\r\n        ...gameState,\r\n        narrativeLogRef,\r\n        addNarrativeEntry,\r\n        advanceGameTime,\r\n    } as any);\r\n\r\n    useGameEffects({\r\n        ...gameState,\r\n        narrativeLogRef,\r\n        addNarrativeEntry,\r\n        advanceGameTime,\r\n        gameSlot: props.gameSlot,\r\n    } as any);\r\n    \r\n    return {\r\n        ...gameState,\r\n        ...actionHandlers,\r\n        narrativeContainerRef,\r\n        biomeDefinitions\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-game-state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-keyboard-bindings.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'keyBindings' logical expression could make the dependencies of useMemo Hook (at line 72) change on every render. Move it inside the useMemo callback. Alternatively, wrap the initialization of 'keyBindings' in its own useMemo() Hook.","line":30,"column":9,"nodeType":"VariableDeclarator","endLine":30,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":161,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":161,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport { useEffect, useMemo } from \"react\";\r\nimport { useSettings } from \"@/context/settings-context\";\r\n\r\ntype Dir = 'north' | 'south' | 'west' | 'east';\r\n\r\nexport interface KeyboardHandlers {\r\n  move: (dir: Dir) => void;\r\n  attack: () => void;\r\n  openInventory?: () => void;\r\n  openStatus?: () => void;\r\n  openMap?: () => void;\r\n  customAction?: () => void;\r\n  pickUp?: () => void;\r\n  hotkey?: (index: number) => void;\r\n}\r\n\r\ninterface UseKeyboardBindingsOpts {\r\n  handlers: KeyboardHandlers;\r\n  popupOpen?: boolean; // if any major popup is open, keyboard bindings should be suppressed\r\n  focusCustomActionInput?: () => void;\r\n  enabled?: boolean;\r\n  movementWhileTyping?: boolean; // allow movement keys while typing in inputs\r\n}\r\n\r\nexport function useKeyboardBindings({ handlers, popupOpen = false, focusCustomActionInput, enabled = true, movementWhileTyping = true }: UseKeyboardBindingsOpts) {\r\n  const { settings } = useSettings();\r\n\r\n  const keyBindings = (settings as any).keyBindings ?? {};\r\n\r\n  const keyToAction = useMemo(() => {\r\n    const map = new Map<string, string>();\r\n    const add = (k: string | string[] | undefined, action: string) => {\r\n      if (!k) return;\r\n      const keys = Array.isArray(k) ? k : [k];\r\n      for (const key of keys) {\r\n        if (!key) continue;\r\n        map.set(key, action);\r\n        // also map uppercase/lowercase variants for convenience when keys are letters\r\n        if (key.length === 1) {\r\n          map.set(key.toLowerCase(), action);\r\n          map.set(key.toUpperCase(), action);\r\n        }\r\n      }\r\n    };\r\n\r\n    add(keyBindings.moveUp, 'moveUp');\r\n    add(keyBindings.moveDown, 'moveDown');\r\n    add(keyBindings.moveLeft, 'moveLeft');\r\n    add(keyBindings.moveRight, 'moveRight');\r\n    add(keyBindings.attack, 'attack');\r\n    add(keyBindings.openInventory, 'openInventory');\r\n    add(keyBindings.openStatus, 'openStatus');\r\n    add(keyBindings.openMap, 'openMap');\r\n  add(keyBindings.customAction, 'customAction');\r\n  add((keyBindings as any).pickUp, 'pickUp');\r\n  add((keyBindings as any).hot1, 'hot1');\r\n  add((keyBindings as any).hot2, 'hot2');\r\n  add((keyBindings as any).hot3, 'hot3');\r\n  add((keyBindings as any).hot4, 'hot4');\r\n  add((keyBindings as any).hot5, 'hot5');\r\n\r\n    // Always include common defaults if not provided\r\n    if (!map.has('ArrowUp')) map.set('ArrowUp', 'moveUp');\r\n    if (!map.has('ArrowDown')) map.set('moveDown', 'moveDown');\r\n    if (!map.has('ArrowLeft')) map.set('moveLeft', 'moveLeft');\r\n    if (!map.has('ArrowRight')) map.set('moveRight', 'moveRight');\r\n    if (!map.has(' ')) map.set(' ', 'attack');\r\n\r\n    return map;\r\n  }, [keyBindings]);\r\n\r\n  useEffect(() => {\r\n    if (!enabled) return;\r\n\r\n    const handler = (e: KeyboardEvent) => {\r\n      try {\r\n        if (popupOpen) return;\r\n\r\n        const active = document.activeElement as HTMLElement | null;\r\n        const tag = active?.tagName?.toUpperCase() ?? '';\r\n\r\n        const action = keyToAction.get(e.key);\r\n        // if not mapped, ignore\r\n        if (!action) return;\r\n\r\n        // If active element is an input/textarea/contentEditable and this is not a movement key\r\n        const movementActions = new Set(['moveUp', 'moveDown', 'moveLeft', 'moveRight']);\r\n        if (active && (tag === 'INPUT' || tag === 'TEXTAREA' || active.isContentEditable)) {\r\n          if (!movementWhileTyping || !movementActions.has(action)) return;\r\n        }\r\n\r\n        // Prevent default browser behavior for mapped keys\r\n        e.preventDefault?.();\r\n\r\n        switch (action) {\r\n          case 'moveUp':\r\n            handlers.move('north');\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'moveDown':\r\n            handlers.move('south');\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'moveLeft':\r\n            handlers.move('west');\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'moveRight':\r\n            handlers.move('east');\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'attack':\r\n            handlers.attack();\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'openInventory':\r\n            handlers.openInventory?.();\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'openStatus':\r\n            handlers.openStatus?.();\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'openMap':\r\n            handlers.openMap?.();\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'pickUp':\r\n            handlers.pickUp?.();\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'hot1':\r\n            handlers.hotkey?.(1);\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'hot2':\r\n            handlers.hotkey?.(2);\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'hot3':\r\n            handlers.hotkey?.(3);\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'hot4':\r\n            handlers.hotkey?.(4);\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'hot5':\r\n            handlers.hotkey?.(5);\r\n            focusCustomActionInput?.();\r\n            break;\r\n          case 'customAction':\r\n            handlers.customAction?.();\r\n            focusCustomActionInput?.();\r\n            break;\r\n          default:\r\n            break;\r\n        }\r\n      } catch (err) {\r\n        // swallow errors\r\n        // console.debug('[useKeyboardBindings] error', err);\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handler, { capture: true });\r\n    return () => window.removeEventListener('keydown', handler, { capture: true });\r\n  }, [keyToAction, handlers, popupOpen, enabled, focusCustomActionInput, movementWhileTyping]);\r\n}\r\n\r\nexport default useKeyboardBindings;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-keyboard-controls.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PlayerStatus' is defined but never used.","line":5,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ActionHandler' is defined but never used.","line":9,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":19},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has unnecessary dependencies: 'playerPosition' and 'world'. Either exclude them or remove the dependency array.","line":69,"column":6,"nodeType":"ArrayExpression","endLine":69,"endColumn":101,"suggestions":[{"desc":"Update the dependencies array to be: [onToggleInventory, onMove, onPickUpItem, currentChunk, isInventoryOpen]","fix":{"range":[2288,2383],"text":"[onToggleInventory, onMove, onPickUpItem, currentChunk, isInventoryOpen]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"'use client';\r\n\r\nimport { useEffect, useCallback } from 'react';\r\nimport type { Action } from '@/lib/game/types'; // Assuming Action type is defined here\r\nimport type { PlayerStatus, World } from '@/lib/game/types'; // Assuming these types are needed\r\n\r\n// Define the types for the handlers that will be passed to this hook\r\ntype MoveHandler = (direction: \"north\" | \"south\" | \"east\" | \"west\") => void;\r\ntype ActionHandler = (actionId: number) => void;\r\n\r\ninterface KeyboardControlsProps {\r\n  onToggleInventory: () => void;\r\n  onMove: MoveHandler;\r\n  onPickUpItem: (actionId: number) => void; // Assuming pick up item action has a specific ID\r\n  currentChunk: any; // Assuming currentChunk is needed to find the pick up action\r\n  playerPosition: { x: number, y: number }; // Assuming player position is needed\r\n  world: World; // Assuming world state is needed to find the pick up action\r\n  isInventoryOpen: boolean; // To prevent actions when inventory is open\r\n}\r\n\r\nexport function useKeyboardControls({\r\n  onToggleInventory,\r\n  onMove,\r\n  onPickUpItem,\r\n  currentChunk,\r\n  playerPosition,\r\n  world,\r\n  isInventoryOpen,\r\n}: KeyboardControlsProps) {\r\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\r\n    // Prevent actions if inventory is open, except for closing it\r\n    if (isInventoryOpen && event.key !== 'e' && event.key !== 'Escape') {\r\n      return;\r\n    }\r\n\r\n    switch (event.key) {\r\n      case 'e':\r\n      case 'Escape': // Allow Escape to close inventory if open\r\n        onToggleInventory();\r\n        break;\r\n      case 'w':\r\n      case 'ArrowUp':\r\n        onMove('north');\r\n        break;\r\n      case 's':\r\n      case 'ArrowDown':\r\n        onMove('south');\r\n        break;\r\n      case 'a':\r\n      case 'ArrowLeft':\r\n        onMove('west');\r\n        break;\r\n      case 'd':\r\n      case 'ArrowRight':\r\n        onMove('east');\r\n        break;\r\n      case 'q':\r\n        // Find the first 'pick up item' action in the current chunk\r\n        if (currentChunk && currentChunk.actions) {\r\n          const pickUpAction = currentChunk.actions.find((action: Action) => action.textKey === 'pickUpAction_item');\r\n          if (pickUpAction) {\r\n            onPickUpItem(pickUpAction.id);\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  }, [onToggleInventory, onMove, onPickUpItem, currentChunk, playerPosition, world, isInventoryOpen]);\r\n\r\n  useEffect(() => {\r\n    document.addEventListener('keydown', handleKeyDown);\r\n    return () => {\r\n      document.removeEventListener('keydown', handleKeyDown);\r\n    };\r\n  }, [handleKeyDown]);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\useGameEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\hooks\\useGameEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\infrastructure\\persistence\\firebase.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\infrastructure\\persistence\\indexed-db.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\infrastructure\\persistence\\indexed-db.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\infrastructure\\persistence\\local-storage.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\audio\\AudioProvider.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":119,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":28},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'playbackMode'. Either include it or remove the dependency array.","line":131,"column":6,"nodeType":"ArrayExpression","endLine":131,"endColumn":26,"suggestions":[{"desc":"Update the dependencies array to be: [musicVolume, muted, playbackMode]","fix":{"range":[6077,6097],"text":"[musicVolume, muted, playbackMode]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":177,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":177,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":231,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":231,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":258,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":258,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":261,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":261,"endColumn":15},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'musicVolume' and 'muted'. Either include them or remove the dependency array.","line":264,"column":6,"nodeType":"ArrayExpression","endLine":264,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: [musicVolume, muted, playMenuMusic]","fix":{"range":[11561,11576],"text":"[musicVolume, muted, playMenuMusic]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":283,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":283,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\"use client\";\r\n\r\nimport React, {createContext, useCallback, useContext, useEffect, useRef, useState} from 'react';\r\nimport {BACKGROUND_MUSIC, MENU_MUSIC, SFX, MOOD_TRACK_MAP} from './assets';\r\n\r\n// Prefer static serving from `public/asset/sound` so browsers can fetch files directly.\r\n// We copy the repository `asset/sound` into `public/asset/sound` during setup.\r\nconst AUDIO_BASE = '/asset/sound';\r\n\r\ntype AudioContextType = {\r\n  playMusic: (track?: string) => void;\r\n  playMenuMusic: () => void;\r\n  // play ambience track based on biome name (e.g. 'cave' -> Ambience_Cave_00.mp3)\r\n  playAmbienceForBiome: (biome?: string | null) => void;\r\n  playBackgroundForMoods: (moods: string[] | undefined) => void;\r\n  // whether autoplay was blocked by the browser when attempting menu autoplay\r\n  autoplayBlocked: boolean;\r\n  // try to enable autoplay (attempt to play menu music again) returning immediately\r\n  tryEnableAutoplay: () => void;\r\n  // playbackMode: 'off' | 'occasional' | 'always'\r\n  playbackMode: 'off' | 'occasional' | 'always';\r\n  setPlaybackMode: (m: 'off' | 'occasional' | 'always') => void;\r\n  playbackIntervalMinutes: number;\r\n  setPlaybackIntervalMinutes: (n: number) => void;\r\n  stopMusic: () => void;\r\n  pauseMusic: () => void;\r\n  playSfx: (name: string) => void;\r\n  musicVolume: number;\r\n  sfxVolume: number;\r\n  setMusicVolume: (v: number) => void;\r\n  setSfxVolume: (v: number) => void;\r\n  muted: boolean;\r\n  setMuted: (m: boolean) => void;\r\n  currentTrack?: string;\r\n};\r\n\r\nconst AudioContext = createContext<AudioContextType | null>(null);\r\n\r\nfunction buildPath(...parts: string[]) {\r\n  // join and encode components so filenames with spaces work in URLs\r\n  return parts.map(p => encodeURI(p)).join('/');\r\n}\r\n\r\nexport const AudioProvider: React.FC<{children: React.ReactNode}> = ({children}) => {\r\n  const musicRef = useRef<HTMLAudioElement | null>(null);\r\n  const [musicVolume, setMusicVolumeState] = useState<number>(() => {\r\n    try { return Number(localStorage.getItem('dl_music_volume') ?? 0.6); } catch { return 0.6; }\r\n  });\r\n  const [sfxVolume, setSfxVolumeState] = useState<number>(() => {\r\n    try { return Number(localStorage.getItem('dl_sfx_volume') ?? 0.9); } catch { return 0.9; }\r\n  });\r\n  const [muted, setMutedState] = useState<boolean>(() => {\r\n    try { return localStorage.getItem('dl_muted') === '1'; } catch { return false; }\r\n  });\r\n  const [currentTrack, setCurrentTrack] = useState<string | undefined>(undefined);\r\n  const [autoplayBlocked, setAutoplayBlocked] = useState<boolean>(false);\r\n  const [playbackMode, setPlaybackModeState] = useState<'off' | 'occasional' | 'always'>(() => {\r\n    try { return (localStorage.getItem('dl_playback_mode') as any) ?? 'off'; } catch { return 'off'; }\r\n  });\r\n  const [playbackIntervalMinutes, setPlaybackIntervalMinutesState] = useState<number>(() => {\r\n    try { return Number(localStorage.getItem('dl_playback_interval_minutes') ?? 3); } catch { return 3; }\r\n  });\r\n\r\n  // timers for occasional/always modes\r\n  const occasionalTimerRef = useRef<number | null>(null);\r\n  const nextTrackTimeoutRef = useRef<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    try { localStorage.setItem('dl_music_volume', String(musicVolume)); } catch {}\r\n    if (musicRef.current) musicRef.current.volume = muted ? 0 : musicVolume;\r\n  }, [musicVolume, muted]);\r\n\r\n  useEffect(() => { try { localStorage.setItem('dl_sfx_volume', String(sfxVolume)); } catch {} }, [sfxVolume]);\r\n  useEffect(() => { try { localStorage.setItem('dl_muted', muted ? '1' : '0'); } catch {} }, [muted]);\r\n  useEffect(() => { try { localStorage.setItem('dl_playback_mode', playbackMode); } catch {} }, [playbackMode]);\r\n  useEffect(() => { try { localStorage.setItem('dl_playback_interval_minutes', String(playbackIntervalMinutes)); } catch {} }, [playbackIntervalMinutes]);\r\n\r\n  const playMusic = useCallback((track?: string) => {\r\n    const list = [...BACKGROUND_MUSIC, ...MENU_MUSIC];\r\n    const chosen = track ?? list[0];\r\n    if (!chosen) return;\r\n    // background music files are stored in background_music; menu tracks may live in menu_music\r\n    const isMenu = MENU_MUSIC.includes(chosen);\r\n    const folder = isMenu ? 'menu_music' : 'background_music';\r\n    const full = buildPath(AUDIO_BASE, folder, chosen);\r\n    // stop and cleanup previous audio\r\n    if (musicRef.current) {\r\n      try { musicRef.current.pause(); } catch {}\r\n      try { musicRef.current.src = ''; } catch {}\r\n      musicRef.current = null;\r\n    }\r\n\r\n    const audio = new Audio(full);\r\n    audio.volume = muted ? 0 : musicVolume;\r\n    audio.preload = 'auto';\r\n\r\n    // Determine if this is ambience/menu so we can decide looping behavior.\r\n    const chosenLower = String(chosen).toLowerCase();\r\n    const isAmbience = /ambience[_\\-\\s]?/.test(chosenLower) || chosenLower.startsWith('ambience');\r\n    // playback mode affects looping/next-track behavior for non-ambience background music\r\n    if (isMenu) {\r\n      // Menu tracks should loop continuously\r\n      audio.loop = true;\r\n      audio.onended = null;\r\n    } else if (isAmbience) {\r\n      // Ambience tracks should loop continuously\r\n      audio.loop = true;\r\n      audio.onended = null;\r\n    } else if (playbackMode === 'always') {\r\n      // when the track ends, schedule next after 5s\r\n      audio.loop = false;\r\n      audio.onended = () => {\r\n        try { nextTrackTimeoutRef.current = window.setTimeout(() => {\r\n          // pick next background music (rotate through list)\r\n          const available = BACKGROUND_MUSIC.length ? BACKGROUND_MUSIC : [chosen];\r\n          const idx = available.indexOf(chosen);\r\n          const next = available[(idx + 1) % available.length] ?? available[0];\r\n          playMusic(next);\r\n        }, 5000); } catch(e){}\r\n      };\r\n    } else {\r\n      // for 'off' and 'occasional', keep music looping when played directly\r\n      audio.loop = true;\r\n      audio.onended = null;\r\n    }\r\n\r\n    // Play and ignore rejection here; autoplay detection handled elsewhere.\r\n    audio.play().catch(()=>{});\r\n    musicRef.current = audio;\r\n    setCurrentTrack(chosen);\r\n  }, [musicVolume, muted]);\r\n\r\n  const playMenuMusic = useCallback(() => {\r\n    if (MENU_MUSIC.length === 0) return;\r\n    playMusic(MENU_MUSIC[0]);\r\n  }, [playMusic]);\r\n\r\n  const playAmbienceForBiome = useCallback((biome?: string | null) => {\r\n    if (!biome) return;\r\n    const b = String(biome).toLowerCase();\r\n    // try to find a background music that matches the biome name or contains 'ambience' + biome\r\n    const candidate = BACKGROUND_MUSIC.find(fn => fn.toLowerCase().includes(b) || fn.toLowerCase().includes(`ambience_${b}`) || fn.toLowerCase().includes(`ambience ${b}`));\r\n    if (candidate) playMusic(candidate);\r\n  }, [playMusic]);\r\n\r\n  const playBackgroundForMoods = useCallback((moods: string[] | undefined) => {\r\n    if (!moods || moods.length === 0) return;\r\n    for (const m of moods) {\r\n      const candidates = MOOD_TRACK_MAP[m];\r\n      if (!candidates) continue;\r\n      for (const c of candidates) {\r\n        if (BACKGROUND_MUSIC.includes(c) || MENU_MUSIC.includes(c)) {\r\n          playMusic(c);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n    if (BACKGROUND_MUSIC.length) playMusic(BACKGROUND_MUSIC[0]);\r\n  }, [playMusic]);\r\n\r\n  // manage occasional mode timer\r\n  useEffect(() => {\r\n    // clear any existing timers\r\n    if (occasionalTimerRef.current) { clearInterval(occasionalTimerRef.current); occasionalTimerRef.current = null; }\r\n    if (nextTrackTimeoutRef.current) { clearTimeout(nextTrackTimeoutRef.current); nextTrackTimeoutRef.current = null; }\r\n\r\n    if (playbackMode === 'occasional') {\r\n      // schedule occasional play every playbackIntervalMinutes minutes\r\n      const ms = Math.max(1, playbackIntervalMinutes) * 60 * 1000;\r\n      try {\r\n        occasionalTimerRef.current = window.setInterval(() => {\r\n          // pick a random background track and play it\r\n          if (BACKGROUND_MUSIC.length === 0) return;\r\n          const idx = Math.floor(Math.random() * BACKGROUND_MUSIC.length);\r\n          playMusic(BACKGROUND_MUSIC[idx]);\r\n        }, ms);\r\n      } catch (e) {}\r\n    }\r\n\r\n    return () => {\r\n      if (occasionalTimerRef.current) { clearInterval(occasionalTimerRef.current); occasionalTimerRef.current = null; }\r\n      if (nextTrackTimeoutRef.current) { clearTimeout(nextTrackTimeoutRef.current); nextTrackTimeoutRef.current = null; }\r\n    };\r\n  }, [playbackMode, playbackIntervalMinutes, playMusic]);\r\n\r\n  const stopMusic = useCallback(() => {\r\n    if (musicRef.current) {\r\n      try { musicRef.current.pause(); } catch {}\r\n      musicRef.current = null;\r\n      setCurrentTrack(undefined);\r\n    }\r\n  }, []);\r\n\r\n  const pauseMusic = useCallback(() => {\r\n    if (musicRef.current) {\r\n      try { musicRef.current.pause(); } catch {}\r\n    }\r\n  }, []);\r\n\r\n  const playSfx = useCallback((name: string) => {\r\n    // prefer exact filename, but allow base name lookup\r\n    let file = name;\r\n    if (!file.includes('.mp3') && SFX.includes(name + '.mp3')) file = name + '.mp3';\r\n    if (!file) return;\r\n    const full = buildPath(AUDIO_BASE, 'sfx', file);\r\n    const a = new Audio(full);\r\n    a.volume = muted ? 0 : sfxVolume;\r\n    a.preload = 'auto';\r\n    // allow overlapping sfx by not reusing element\r\n    a.play().catch(()=>{});\r\n  }, [sfxVolume, muted]);\r\n\r\n  const setMusicVolume = useCallback((v: number) => setMusicVolumeState(Math.max(0, Math.min(1, v))), []);\r\n  const setSfxVolume = useCallback((v: number) => setSfxVolumeState(Math.max(0, Math.min(1, v))), []);\r\n  const setMuted = useCallback((m: boolean) => setMutedState(m), []);\r\n  const setPlaybackMode = useCallback((m: 'off' | 'occasional' | 'always') => setPlaybackModeState(m), []);\r\n  const setPlaybackIntervalMinutes = useCallback((n: number) => setPlaybackIntervalMinutesState(Math.max(1, Math.floor(n))), []);\r\n\r\n  // optional: preload a few small sfx to reduce initial latency\r\n  useEffect(() => {\r\n    try {\r\n      const preload = SFX.slice(0, 6).map(name => {\r\n        const p = buildPath(AUDIO_BASE, 'sfx', name);\r\n        const a = new Audio(p);\r\n        a.preload = 'auto';\r\n        return a;\r\n      });\r\n      // keep them briefly in memory\r\n      const t = setTimeout(() => { preload.forEach(p => { try { p.src = ''; } catch {} }); }, 5000);\r\n      return () => { clearTimeout(t); preload.forEach(p => { try { p.src = ''; } catch {} }); };\r\n    } catch (e) { /* ignore */ }\r\n  }, []);\r\n\r\n  // Attempt to autoplay menu music on first client mount unless user disabled it.\r\n  useEffect(() => {\r\n    try {\r\n      const disabled = localStorage.getItem('dl_auto_menu');\r\n      if (disabled === '0') return;\r\n      // Respect user mute: if muted, don't attempt autoplay\r\n      if (muted) return;\r\n      // try to play menu music; browsers may block autoplay until a user gesture.\r\n      if (!MENU_MUSIC.length) return;\r\n      try {\r\n        const temp = new Audio(buildPath(AUDIO_BASE, 'menu_music', MENU_MUSIC[0]));\r\n        temp.preload = 'auto';\r\n        temp.volume = muted ? 0 : musicVolume;\r\n        temp.loop = true;\r\n        temp.play().then(() => {\r\n          // autoplay allowed: play via provider to keep state consistent\r\n          playMenuMusic();\r\n          try { temp.src = ''; } catch {}\r\n        }).catch(() => {\r\n          // autoplay blocked: persist opt-out so we don't keep retrying\r\n          setAutoplayBlocked(true);\r\n          try { localStorage.setItem('dl_auto_menu', '0'); } catch {}\r\n          try { temp.src = ''; } catch {}\r\n        });\r\n      } catch (e) {\r\n        // ignore\r\n      }\r\n    } catch (e) {\r\n      // ignore\r\n    }\r\n  }, [playMenuMusic]);\r\n\r\n  const tryEnableAutoplay = useCallback(() => {\r\n    // attempt to play menu music and clear blocked flag on success\r\n    setAutoplayBlocked(false);\r\n    if (!MENU_MUSIC.length) return;\r\n    try {\r\n      const temp = new Audio(buildPath(AUDIO_BASE, 'menu_music', MENU_MUSIC[0]));\r\n      temp.preload = 'auto';\r\n      temp.volume = muted ? 0 : musicVolume;\r\n      temp.loop = true;\r\n      temp.play().then(() => {\r\n        try { localStorage.setItem('dl_auto_menu', '1'); } catch {}\r\n        playMenuMusic();\r\n        try { temp.src = ''; } catch {}\r\n      }).catch(() => {\r\n        setAutoplayBlocked(true);\r\n        try { temp.src = ''; } catch {}\r\n      });\r\n    } catch (e) {\r\n      setAutoplayBlocked(true);\r\n    }\r\n  }, [musicVolume, muted, playMenuMusic]);\r\n\r\n  const api: AudioContextType = {\r\n    playMusic,\r\n    playMenuMusic,\r\n    playAmbienceForBiome,\r\n    playBackgroundForMoods,\r\n    autoplayBlocked,\r\n    tryEnableAutoplay,\r\n    playbackMode,\r\n    setPlaybackMode,\r\n    playbackIntervalMinutes,\r\n    setPlaybackIntervalMinutes,\r\n    stopMusic,\r\n    pauseMusic,\r\n    playSfx,\r\n    musicVolume,\r\n    sfxVolume,\r\n    setMusicVolume,\r\n    setSfxVolume,\r\n    muted,\r\n    setMuted,\r\n    currentTrack,\r\n  };\r\n\r\n  return <AudioContext.Provider value={api}>{children}</AudioContext.Provider>;\r\n};\r\n\r\nexport function useAudioContext() {\r\n  const ctx = useContext(AudioContext);\r\n  if (!ctx) throw new Error('useAudioContext must be used inside AudioProvider');\r\n  return ctx;\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\audio\\assets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\audio\\useAudio.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\config\\game-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\debug.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'label' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":23,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* Lightweight debug helper used to trigger `debugger;` in dev when a runtime flag is set.\r\n * Usage: import { maybeDebug } from '@/lib/debug'; maybeDebug('label');\r\n * To activate in the browser console: window.__DEBUG_BREAK = true\r\n * Or set process.env.DEBUG_BREAK = '1' for server-side debugging.\r\n */\r\nexport function maybeDebug(label?: string) {\r\n  try {\r\n    // Prefer client-side flag\r\n    if (typeof window !== 'undefined') {\r\n      const w = window as any;\r\n      if (w.__DEBUG_BREAK) {\r\n         \r\n        debugger;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Server-side fallback via env\r\n    if (process && process.env && process.env.DEBUG_BREAK === '1') {\r\n       \r\n      debugger;\r\n    }\r\n  } catch (_e) {\r\n    // swallow\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\firebase-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\__tests__\\effect-engine.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\__tests__\\item-utils.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\biomes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Terrain' is defined but never used.","line":2,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { worldConfig } from './world-config';\r\nimport type { BiomeDefinition, Terrain } from './types';\r\n\r\n// Minimal emoji map for common terrains ΓÇö can be extended or overridden by mods\r\nconst emojiMap: Record<string, string> = {\r\n  forest: '≡ƒî▓',\r\n  grassland: '≡ƒî╛',\r\n  desert: '≡ƒÅ£∩╕Å',\r\n  swamp: '≡ƒªå',\r\n  mountain: 'Γ¢░∩╕Å',\r\n  cave: '≡ƒò│∩╕Å',\r\n  jungle: '≡ƒî┤',\r\n  volcanic: '≡ƒîï',\r\n  floptropica: '≡ƒÅ¥∩╕Å',\r\n  wall: '≡ƒº▒',\r\n  tundra: 'Γ¥ä∩╕Å',\r\n  beach: '≡ƒÅû∩╕Å',\r\n  mesa: '≡ƒ¬¿',\r\n  mushroom_forest: '≡ƒìä',\r\n  ocean: '≡ƒîè',\r\n  city: '≡ƒÅÖ∩╕Å',\r\n  space_station: '≡ƒ¢░∩╕Å',\r\n  underwater: '≡ƒÉá',\r\n};\r\n\r\nexport const biomeDefinitions: Record<string, BiomeDefinition> = Object.fromEntries(\r\n  Object.entries(worldConfig).map(([key, val]) => {\r\n    const def: BiomeDefinition = {\r\n      id: key,\r\n      travelCost: (val as any).travelCost ?? 1,\r\n      minSize: (val as any).minSize ?? 1,\r\n      maxSize: (val as any).maxSize ?? 1,\r\n      spreadWeight: (val as any).spreadWeight ?? 1,\r\n      allowedNeighbors: (val as any).allowedNeighbors ?? [],\r\n      defaultValueRanges: (val as any).defaultValueRanges ?? {},\r\n      soilType: (val as any).soilType ?? [],\r\n      templates: (val as any).templates,\r\n      emoji: emojiMap[key] ?? undefined,\r\n    } as BiomeDefinition;\r\n    return [key, def];\r\n  })\r\n);\r\n\r\nexport default biomeDefinitions;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\data.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\equipment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\food.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\magic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\materials.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\modded\\nature_plus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\support.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\tools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\items\\weapons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\narrative-placeholders.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\narrative-templates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\detective-noir.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\floptropica.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\frozen-wasteland.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\generation-ship.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\haunted-mansion.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\mage-academy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\space-western.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\premade-worlds\\underwater-kingdom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\recipes\\nature_plus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\data\\sensory-database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\base.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\biome.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\creature.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\enemy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\event.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\item.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\recipe.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\structure.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\terrain-definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\unlock-condition.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\weather.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\definitions\\world-definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\dice.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\effect-engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\__tests__\\chunk-generation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\__tests__\\crafting.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\__tests__\\crafting_localized.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\__tests__\\generation-integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\__tests__\\generation.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'language' is defined but never used. Allowed unused args must match /^_/u.","line":6,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'counter' is assigned a value but never used.","line":44,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { selectEntities } from '../entity-generation';\r\nimport { generateChunkContent } from '../chunk-generation';\r\n\r\n// Mock getTemplates used by generateChunkContent\r\njest.mock('@/lib/game/templates', () => ({\r\n  getTemplates: (language: string) => ({\r\n    testTerrain: {\r\n      descriptionTemplates: ['A test terrain [adjective] with [feature]'],\r\n      adjectives: ['rocky'],\r\n      features: ['stones'],\r\n      items: [\r\n        { name: 'MasterItem', conditions: { chance: 1 } }\r\n      ],\r\n      NPCs: [],\r\n      enemies: [],\r\n      structures: []\r\n    }\r\n  })\r\n}));\r\n\r\ndescribe('entity generation and chunk content', () => {\r\n  const originalRandom = Math.random;\r\n\r\n  afterEach(() => {\r\n    Math.random = originalRandom;\r\n    jest.resetModules();\r\n  });\r\n\r\n  test('selectEntities selects entity when random is low and tier multiplier applied', () => {\r\n    // Force deterministic random values\r\n    Math.random = () => 0.01; // very low => should spawn when chance ~1\r\n\r\n    const available = [ { name: 'TestItem', conditions: { chance: 1 } } ];\r\n    const chunkMock: any = { vegetationDensity: 10, moisture: 0, elevation: 0, dangerLevel: 0, magicAffinity: 0, humanPresence: 0, predatorPresence: 0, temperature: 20, terrain: 'testTerrain', explorability: 10, soilType: 'loam', travelCost: 1, lightLevel: 50, windLevel: 10 };\r\n    const allItemDefinitions: any = { TestItem: { name: 'TestItem', description: 'desc', tier: 1, baseQuantity: { min:1, max:1 }, emoji: 'x' } };\r\n    const worldProfile: any = { resourceDensity: 50 };\r\n\r\n    const selected = selectEntities(available as any, 3, chunkMock, allItemDefinitions, worldProfile);\r\n    expect(selected.length).toBeGreaterThan(0);\r\n  });\r\n\r\n  test('generateChunkContent produces spawned items using mocked templates', () => {\r\n    // deterministic random\r\n    let counter = 0;\r\n    Math.random = () => {\r\n      // first call to pick description, others to decide spawns: return low values\r\n      counter++;\r\n      return 0.02;\r\n    };\r\n\r\n    const chunkData: any = {\r\n      vegetationDensity: 5,\r\n      moisture: 10,\r\n      elevation: 0,\r\n      dangerLevel: 0,\r\n      magicAffinity: 0,\r\n      humanPresence: 0,\r\n      predatorPresence: 0,\r\n      temperature: 20,\r\n      terrain: 'testTerrain',\r\n      explorability: 10,\r\n      soilType: 'loam',\r\n      travelCost: 1,\r\n      lightLevel: 50,\r\n      windLevel: 10\r\n    };\r\n\r\n    const worldProfile: any = { resourceDensity: 100 };\r\n    const allItemDefinitions: any = { MasterItem: { name: {en: 'MasterItem'}, description: 'master', tier: 1, baseQuantity: { min:1, max:2 }, emoji: 'Γÿà' } };\r\n    const customCatalog: any[] = [];\r\n\r\n    const result = generateChunkContent(chunkData, worldProfile, allItemDefinitions, customCatalog, [], 'en');\r\n\r\n    expect(result.items.length).toBeGreaterThan(0);\r\n    // Ensure instrumentation sample items matches items names\r\n    const sample = result.items.map(i => {\r\n      if (typeof i.name === 'string') return i.name;\r\n      const nameObj: any = i.name as any;\r\n      return nameObj.en ?? nameObj.default ?? JSON.stringify(nameObj);\r\n    });\r\n    expect(sample).toContain('MasterItem');\r\n    expect(result.enemy).toBeNull();\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\__tests__\\narrative-templates.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\chunk-generation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\crafting.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":144,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":150,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n/**\r\n * Core implementation of the game's crafting system engine. This module orchestrates\r\n * the complex interactions between Recipe schemas, ItemDefinition data, and player inventory\r\n * to determine crafting feasibility, success probabilities, and resource consumption.\r\n *\r\n * Key responsibilities:\r\n * - Ingredient validation and substitution matching using ItemRelationshipSchema\r\n * - Tool requirement verification against player inventory\r\n * - Success probability calculation based on material quality and substitution penalties\r\n * - Resource consumption planning and inventory impact assessment\r\n * - Crafting feasibility scoring for UI display\r\n *\r\n * Data flow and interdependencies:\r\n * 1. RecipeSchema ΓåÆ provides crafting requirements and constraints\r\n * 2. ItemDefinitionSchema ΓåÆ supplies item properties and relationships\r\n * 3. Player inventory ΓåÆ checked for available materials and tools\r\n * 4. CraftingOutcome ΓåÆ returned to UI for display and execution\r\n * 5. Inventory system ΓåÆ updated with consumed ingredients and crafted results\r\n *\r\n * Algorithm complexity:\r\n * - O(n*m) where n=recipe ingredients, m=player inventory items\r\n * - Substitution lookup requires full item registry scan\r\n * - Quality-based sorting ensures optimal material selection\r\n */\r\n\r\nimport type { PlayerItem, Recipe, ItemDefinition, TranslatableString, RecipeIngredient } from \"../types\";\r\n\r\n/**\r\n * Assessment of how craftable a recipe is based on current player inventory.\r\n * Used by UI to show crafting progress and missing requirements.\r\n *\r\n * Score calculation: available_ingredients / total_required_ingredients\r\n * - 1.0 = all ingredients available (ready to craft)\r\n * - 0.5 = half ingredients available (partially ready)\r\n * - 0.0 = no ingredients available (cannot craft)\r\n */\r\nexport interface CraftabilityInfo {\r\n    score: number;  // Percentage of available ingredients (0-1), used for UI progress bars\r\n    missingIngredients: string[];  // Names of ingredients not available in sufficient quantity\r\n    availableIngredients: string[];  // Names of ingredients that are available and sufficient\r\n}\r\n\r\n/**\r\n * Comprehensive result of crafting feasibility analysis. This interface encapsulates\r\n * all information needed to display crafting status and execute the craft.\r\n *\r\n * Data flow: RecipeSchema + PlayerInventory + ItemDefinitions ΓåÆ CraftingOutcome ΓåÆ UI/CraftingExecution\r\n *\r\n * Key calculations within this structure:\r\n * - canCraft: canCraftAllIngredients AND hasRequiredTool\r\n * - chance: Based on worst substitution quality (1=100%, 2=50%, 3=10%)\r\n * - ingredientsToConsume: Deduplicated list of actual items to remove from inventory\r\n * - resolvedIngredients: Detailed mapping of requirements to available substitutes\r\n */\r\nexport interface CraftingOutcome {\r\n    canCraft: boolean;  // True if all requirements met and craft can proceed\r\n    chance: number;  // Success probability percentage (0-100), affected by material quality\r\n    hasRequiredTool: boolean;  // Whether player has the tool specified in recipe.requiredTool\r\n    ingredientsToConsume: { name: string; quantity: number }[];  // Actual items to remove from inventory\r\n    resolvedIngredients: {  // Detailed breakdown of each ingredient requirement\r\n        requirement: RecipeIngredient;  // Original recipe requirement\r\n        usedItem: { name: TranslatableString, tier: number };  // Item that will be used (may be substitute)\r\n        isSubstitute: boolean;  // Whether this is a substitute rather than exact match\r\n        hasEnough: boolean;  // Whether player has sufficient quantity\r\n        playerQuantity: number;  // How many of this item the player actually has\r\n    }[];\r\n    craftability?: CraftabilityInfo;  // Optional UI helper for showing crafting readiness\r\n}\r\nimport { getTranslatedText, resolveItemId } from \"@/lib/utils\";\r\n\r\n/**\r\n * Core crafting feasibility algorithm that analyzes player inventory against recipe requirements.\r\n * This pure function performs complex substitution matching and quality-based calculations\r\n * to determine crafting viability without modifying any game state.\r\n *\r\n * Algorithm breakdown:\r\n * 1. **Tool Verification**: Checks recipe.requiredTool against player inventory using multiple ID resolution strategies\r\n * 2. **Ingredient Resolution Loop**: For each recipe ingredient:\r\n *    - Finds all possible substitutes via ItemRelationshipSchema.substituteFor\r\n *    - Sorts substitutes by quality (lower = better)\r\n *    - Selects best available substitute that meets quantity requirements\r\n *    - Tracks worst quality used for success chance calculation\r\n * 3. **Success Probability**: Based on substitution quality tiers:\r\n *    - Quality 1 (perfect/exact match): 100% success\r\n *    - Quality 2 (good substitute): 50% success\r\n *    - Quality 3 (poor substitute): 10% success\r\n * 4. **Consumption Planning**: Deduplicates ingredients and calculates total quantities to remove\r\n * 5. **Craftability Scoring**: Percentage of ingredients available for UI feedback\r\n *\r\n * Item matching complexity:\r\n * - Supports 4 identification methods: explicit ID, resolved ID, English name, relationship lookup\r\n * - Handles legacy data migration with fallback matching strategies\r\n * - Prioritizes exact matches over substitutes, quality over availability\r\n *\r\n * Performance characteristics:\r\n * - O(n*m*p) where n=ingredients, m=player items, p=item registry size\r\n * - Substitution lookup is the most expensive operation\r\n * - Results are cached by calling systems for repeated calculations\r\n *\r\n * @param {PlayerItem[]} playerItems - The player's current inventory items with quantities\r\n * @param {Recipe} recipe - The recipe schema defining crafting requirements\r\n * @param {Record<string, ItemDefinition>} allItemDefinitions - Complete item registry for relationship lookups\r\n * @returns {CraftingOutcome} Comprehensive analysis of crafting feasibility and requirements\r\n *\r\n * @example\r\n * ```typescript\r\n * const outcome = calculateCraftingOutcome(player.items, recipes['torch'], allItems);\r\n * if (outcome.canCraft && outcome.chance > 50) {\r\n *   console.log(`Ready to craft with ${outcome.chance}% success rate`);\r\n *   // outcome.ingredientsToConsume shows exactly what will be used\r\n * }\r\n * ```\r\n */\r\nexport const calculateCraftingOutcome = (\r\n    playerItems: PlayerItem[],\r\n    recipe: Recipe,\r\n    allItemDefinitions: Record<string, ItemDefinition>\r\n): CraftingOutcome => {\r\n    // Helper to robustly resolve a player's item to a canonical id.\r\n    // Try explicit `id`, then resolver using English and Vietnamese fallbacks,\r\n    // then fall back to translated text strings. This helps handle items stored\r\n    // as localized strings or inline translation objects.\r\n    const getPlayerItemId = (pi: PlayerItem | { name?: any; id?: string } | undefined): string | undefined => {\r\n        if (!pi) return undefined;\r\n        // If item already has an id, validate it against known definitions.\r\n        // Some saved/legacy items may have an `id` that is actually a translated string\r\n        // (e.g., \"Sturdy Branch\") which will not match recipe ids like `sturdy_branch`.\r\n        // Only accept the existing id if it exists in the provided definitions.\r\n        const existingId = (pi as any).id;\r\n        if (existingId) {\r\n            if (allItemDefinitions && allItemDefinitions[existingId]) return existingId;\r\n            // otherwise fall through to attempt resolving from the item's name\r\n        }\r\n        // Try resolver with English then Vietnamese\r\n        const byEn = resolveItemId((pi as any).name, allItemDefinitions, undefined, 'en');\r\n        if (byEn) return byEn;\r\n        const byVi = resolveItemId((pi as any).name, allItemDefinitions, undefined, 'vi');\r\n        if (byVi) return byVi;\r\n        // Fallback to raw translations\r\n        try {\r\n            const nameEn = getTranslatedText((pi as any).name as TranslatableString, 'en');\r\n            if (nameEn && allItemDefinitions[nameEn]) return nameEn;\r\n        } catch (e) {\r\n            // ignore\r\n        }\r\n        try {\r\n            const nameVi = getTranslatedText((pi as any).name as TranslatableString, 'vi');\r\n            if (nameVi && allItemDefinitions[nameVi]) return nameVi;\r\n        } catch (e) {\r\n            // ignore\r\n        }\r\n        return undefined;\r\n    };\r\n    const resolvedIngredients: CraftingOutcome['resolvedIngredients'] = [];\r\n    const ingredientsToConsumeMap = new Map<string, number>();\r\n    let worstTier = 1;\r\n    let canCraftAllIngredients = true;\r\n    let availableIngredientsCount = 0;\r\n    const missingIngredients: string[] = [];\r\n    const availableIngredients: string[] = [];\r\n\r\n    const hasRequiredTool = !recipe.requiredTool || playerItems.some(item => (\r\n        // Prefer explicit id comparison\r\n        (item as any).id === recipe.requiredTool ||\r\n        // Try robust resolver to map the player's item to a canonical id (checks en/vi)\r\n        getPlayerItemId(item) === recipe.requiredTool ||\r\n        // Fallback to legacy English name match\r\n        getTranslatedText(item.name, 'en') === recipe.requiredTool\r\n    ));\r\n\r\n    for (const requirement of recipe.ingredients) {\r\n        let bestAvailable: { item: PlayerItem, quality: number } | null = null;\r\n        \r\n        const possibleItems = Object.entries(allItemDefinitions)\r\n            .filter(([key, def]) => (\r\n                def.relationship?.substituteFor === requirement.name ||\r\n                def.id === requirement.name ||\r\n                key === requirement.name ||\r\n                getTranslatedText(def.name, 'en') === requirement.name\r\n            ))\r\n            .map(([key, def]) => ({ id: def.id ?? key, name: getTranslatedText(def.name, 'en'), quality: def.relationship?.quality ?? 1 }));\r\n            \r\n        // Also add the primary ingredient itself if not already included via relationship\r\n        if (!possibleItems.some(p => p.id === requirement.name)) {\r\n            possibleItems.push({ id: requirement.name, name: requirement.name, quality: 1 });\r\n        }\r\n        \r\n        // Find the best quality substitute the player has enough of\r\n        possibleItems.sort((a, b) => a.quality - b.quality);\r\n        \r\n        for (const possible of possibleItems) {\r\n            const playerItem = playerItems.find(pi => {\r\n                // Prefer explicit id on player item\r\n                if ((pi as any).id && (pi as any).id === possible.id) return true;\r\n                // Resolve the player's item name to an id using robust resolver\r\n                const playerId = getPlayerItemId(pi);\r\n                if (playerId && playerId === possible.id) return true;\r\n                // Legacy fallback to English-name comparison\r\n                if (getTranslatedText(pi.name, 'en') === possible.id) return true;\r\n                if (getTranslatedText(pi.name, 'en') === possible.name) return true;\r\n                return false;\r\n            });\r\n            if (playerItem && playerItem.quantity >= requirement.quantity) {\r\n                bestAvailable = { item: playerItem, quality: possible.quality };\r\n                break;\r\n            }\r\n        }\r\n        \r\n        const playerItemForQtyCheck = playerItems.find(pi => {\r\n            if ((pi as any).id === requirement.name) return true;\r\n            const playerId = getPlayerItemId(pi);\r\n            if (playerId && playerId === requirement.name) return true;\r\n            if (getTranslatedText(pi.name, 'en') === requirement.name) return true;\r\n            return false;\r\n        });\r\n        const playerQuantity = playerItemForQtyCheck ? playerItemForQtyCheck.quantity : 0;\r\n\r\n        if (bestAvailable) {\r\n            resolvedIngredients.push({\r\n                requirement,\r\n                usedItem: { name: bestAvailable.item.name, tier: bestAvailable.quality },\r\n                // Determine substitute status by comparing canonical ids when possible\r\n                isSubstitute: !(((bestAvailable.item as any).id && (bestAvailable.item as any).id === requirement.name) || resolveItemId(bestAvailable.item.name, allItemDefinitions) === requirement.name || getTranslatedText(bestAvailable.item.name, 'en') === requirement.name),\r\n                hasEnough: true,\r\n                playerQuantity\r\n            });\r\n            availableIngredientsCount++;\r\n            availableIngredients.push(getTranslatedText(bestAvailable.item.name, 'en'));\r\n            worstTier = Math.max(worstTier, bestAvailable.quality);\r\n            const consumptionKey = getTranslatedText(bestAvailable.item.name, 'en');\r\n            const currentConsumption = ingredientsToConsumeMap.get(consumptionKey) || 0;\r\n            ingredientsToConsumeMap.set(consumptionKey, currentConsumption + requirement.quantity);\r\n        } else {\r\n            canCraftAllIngredients = false;\r\n            resolvedIngredients.push({\r\n                requirement,\r\n                usedItem: { name: requirement.name as unknown as TranslatableString, tier: 1 },\r\n                isSubstitute: false,\r\n                hasEnough: false,\r\n                playerQuantity\r\n            });\r\n            missingIngredients.push(requirement.name);\r\n        }\r\n    }\r\n\r\n    const canCraft = canCraftAllIngredients && hasRequiredTool;\r\n    let chance = 100;\r\n    if (worstTier === 2) chance = 50;\r\n    if (worstTier === 3) chance = 10;\r\n    if (!canCraft) chance = 0;\r\n\r\n    const craftability: CraftabilityInfo = {\r\n        score: availableIngredientsCount / recipe.ingredients.length,\r\n        missingIngredients,\r\n        availableIngredients\r\n    };\r\n\r\n    return {\r\n        canCraft,\r\n        chance,\r\n        hasRequiredTool,\r\n        ingredientsToConsume: Array.from(ingredientsToConsumeMap.entries()).map(([name, quantity]) => ({ name, quantity })),\r\n        resolvedIngredients,\r\n        craftability\r\n    };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\entity-generation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\generation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\offline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\offline.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNight' is defined but never used.","line":9,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":393,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":393,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\r\n\r\nimport type { Chunk, MoodTag, NarrativeLength, NarrativeTemplate, ConditionType, Language, PlayerStatus, World } from \"../types\";\r\nimport { getTranslatedText, SmartJoinSentences, resolveItemId } from \"../../utils\"; \r\nimport { getTemplates } from '../templates';\r\nimport type { TranslationKey } from \"../../i18n\";\r\nimport { logger } from \"@/lib/logger\";\r\nimport type { ItemDefinition } from \"../types\";\r\nimport { isDay, isNight } from \"../time/time-utils\"; // Import new time utilities\r\n// clamp imported elsewhere when needed; not required here\r\nimport { biomeNarrativeTemplates, getKeywordVariations, selectRandom } from \"../data/narrative-templates\";\r\n\r\n/**\r\n * Ph├ón t├¡ch c├íc thuß╗Öc t├¡nh cß╗ºa chunk ─æß╗â x├íc ─æß╗ïnh c├íc MoodTag chß╗º ─æß║ío.\r\n * H├ám n├áy ─æß╗ìc c├íc gi├í trß╗ï sß╗æ v├á g├ín c├íc nh├ún t├óm trß║íng dß╗▒a tr├¬n ng╞░ß╗íng ─æ├ú ─æß╗ïnh (dß║úi 0-100).\r\n * @param chunk Dß╗» liß╗çu chunk hiß╗çn tß║íi.\r\n * @returns Mß║úng c├íc MoodTag m├┤ tß║ú t├óm trß║íng cß╗ºa chunk.\r\n */\r\nexport const analyze_chunk_mood = (chunk: Chunk): MoodTag[] => {\r\n    const moods: MoodTag[] = [];\r\n\r\n    // 1. Mß╗⌐c ─æß╗Ö Nguy hiß╗âm (dangerLevel) - Dß║úi 0-100\r\n    if (chunk.dangerLevel >= 70) { // Rß║Ñt nguy hiß╗âm\r\n        moods.push(\"Danger\", \"Foreboding\", \"Threatening\");\r\n    } else if (chunk.dangerLevel >= 40) { // C├│ thß╗â nguy hiß╗âm\r\n        moods.push(\"Threatening\");\r\n    }\r\n\r\n    // 2. Mß╗⌐c ─æß╗Ö ├ünh s├íng (lightLevel) - Dß║úi -100 ─æß║┐n 100\r\n    if (chunk.lightLevel <= 10) { // Tß╗æi ho├án to├án (v├¡ dß╗Ñ, trong hang ─æß╗Öng hoß║╖c ─æ├¬m tß╗æi)\r\n        moods.push(\"Dark\", \"Gloomy\", \"Mysterious\");\r\n    } else if (chunk.lightLevel < 50) { // Mß╗¥ ß║úo, thiß║┐u s├íng (v├¡ dß╗Ñ, ho├áng h├┤n, rß╗½ng rß║¡m)\r\n        moods.push(\"Mysterious\", \"Gloomy\");\r\n    } else if (chunk.lightLevel >= 80) { // Rß║Ñt s├íng (ban ng├áy, khu vß╗▒c trß╗æng trß║úi)\r\n        moods.push(\"Vibrant\", \"Peaceful\");\r\n    }\r\n\r\n    // 3. ─Éß╗Ö ß║⌐m (moisture) - Dß║úi 0-100\r\n    if (chunk.moisture >= 80) { // Rß║Ñt ß║⌐m ╞░ß╗¢t (─æß║ºm lß║ºy, rß╗½ng m╞░a nhiß╗çt ─æß╗¢i)\r\n        moods.push(\"Lush\", \"Wet\", \"Vibrant\");\r\n    } else if (chunk.moisture <= 20) { // Kh├┤ hß║ín (sa mß║íc, khu vß╗▒c nß╗⌐t nß║╗)\r\n        moods.push(\"Arid\", \"Desolate\");\r\n    }\r\n\r\n    // 4. Sß╗▒ hiß╗çn diß╗çn cß╗ºa kß║╗ s─ân mß╗ôi (predatorPresence) - Dß║úi 0-100\r\n    if (chunk.predatorPresence >= 60) { // Nhiß╗üu kß║╗ s─ân mß╗ôi\r\n        moods.push(\"Danger\", \"Wild\");\r\n    }\r\n\r\n    // 5. Li├¬n kß║┐t ma thuß║¡t (magicAffinity) - Dß║úi 0-100\r\n    if (chunk.magicAffinity >= 70) { // N─âng l╞░ß╗úng ma thuß║¡t mß║ính\r\n        moods.push(\"Magic\", \"Mysterious\", \"Ethereal\");\r\n    } else if (chunk.magicAffinity >= 40) { // C├│ dß║Ñu hiß╗çu ma thuß║¡t\r\n        moods.push(\"Mysterious\");\r\n    }\r\n\r\n    // 6. Sß╗▒ hiß╗çn diß╗çn cß╗ºa con ng╞░ß╗¥i (humanPresence) - Dß║úi 0-100\r\n    if (chunk.humanPresence >= 60) { // C├│ dß║Ñu hiß╗çu con ng╞░ß╗¥i ─æ├íng kß╗â (l├áng mß║íc, t├án t├¡ch)\r\n        moods.push(\"Civilized\", \"Historic\"); // C├│ thß╗â th├¬m \"Ruined\" nß║┐u thß║Ñp h╞ín\r\n    } else if (chunk.humanPresence > 0) { // C├│ ch├║t dß║Ñu hiß╗çu nh╞░ng kh├┤ng ─æ├íng kß╗â\r\n        moods.push(\"Abandoned\");\r\n    }\r\n\r\n    // 7. Nhiß╗çt ─æß╗Ö (temperature) - Dß║úi 0-100 (0: ─æ├│ng b─âng, 100: cß╗▒c n├│ng, 50: dß╗à chß╗ïu)\r\n    // Use numeric existence checks (Number.isFinite) so that 0 is treated as a valid value.\r\n    const temp: number = (chunk.temperature ?? NaN) as number;\r\n    if (Number.isFinite(temp) && temp >= 80) { // Rß║Ñt n├│ng\r\n        moods.push(\"Hot\", \"Harsh\");\r\n    } else if (Number.isFinite(temp) && temp <= 20) { // Rß║Ñt lß║ính\r\n        moods.push(\"Cold\", \"Harsh\");\r\n    } else if (Number.isFinite(temp) && temp > 35 && temp < 65) { // Nhiß╗çt ─æß╗Ö dß╗à chß╗ïu\r\n        moods.push(\"Peaceful\");\r\n    }\r\n\r\n    // 8. ─Éß╗ïa h├¼nh (terrain) - G├ín mood dß╗▒a tr├¬n loß║íi ─æß╗ïa h├¼nh c╞í bß║ún\r\n    switch (chunk.terrain) {\r\n        case \"swamp\":\r\n            moods.push(\"Gloomy\", \"Wet\", \"Mysterious\");\r\n            break;\r\n        case \"desert\":\r\n            moods.push(\"Arid\", \"Desolate\", \"Harsh\");\r\n            break;\r\n        case \"mountain\":\r\n            moods.push(\"Harsh\", \"Rugged\", \"Elevated\"); // Th├¬m Elevated\r\n            break;\r\n        case \"forest\":\r\n            moods.push(\"Lush\", \"Peaceful\");\r\n            break;\r\n        case \"cave\":\r\n            moods.push(\"Dark\", \"Mysterious\", \"Foreboding\", \"Confined\"); // Th├¬m Confined\r\n            break;\r\n        case \"jungle\": // Bß║ín c├│ biome Jungle trong template, n├¬n th├¬m v├áo ─æ├óy\r\n            moods.push(\"Lush\", \"Vibrant\", \"Mysterious\", \"Wild\");\r\n            break;\r\n        case \"volcanic\":\r\n            moods.push(\"Danger\", \"Harsh\", \"Smoldering\"); // Th├¬m Smoldering\r\n            break;\r\n        case \"ocean\":\r\n        case \"underwater\":\r\n            moods.push(\"Serene\", \"Mysterious\", \"Vast\");\r\n            break;\r\n        case \"city\":\r\n        case \"space_station\":\r\n            moods.push(\"Civilized\", \"Structured\");\r\n            break;\r\n        case \"tundra\":\r\n            moods.push(\"Cold\", \"Desolate\", \"Barren\");\r\n            break;\r\n        // ... (th├¬m c├íc terrain kh├íc nß║┐u cß║ºn)\r\n    }\r\n\r\n    return Array.from(new Set(moods));\r\n};\r\n\r\nexport const get_sentence_limits = (narrativeLength: NarrativeLength): { min_s: number; max_s: number; } => {\r\n    switch (narrativeLength) {\r\n        case \"short\":\r\n            return { min_s: 1, max_s: 2 };\r\n        case \"medium\":\r\n            return { min_s: 2, max_s: 4 };\r\n        case \"long\":\r\n        case \"detailed\":\r\n            return { min_s: 4, max_s: 7 };\r\n        default:\r\n            return { min_s: 1, max_s: 2 }; // Fallback an to├án\r\n    }\r\n};\r\n\r\nexport const check_conditions = (template_conditions: ConditionType | undefined, chunk: Chunk, playerState?: PlayerStatus): boolean => {\r\n    if (!template_conditions) return true; // Kh├┤ng c├│ ─æiß╗üu kiß╗çn n├áo, lu├┤n ─æ├║ng\r\n\r\n    // This is a comprehensive check that iterates over all possible condition keys.\r\n    for (const key in template_conditions) {\r\n        if (!Object.prototype.hasOwnProperty.call(template_conditions, key)) continue;\r\n\r\n        const conditionValue = (template_conditions as any)[key];\r\n        const chunkValue = (chunk as any)[key];\r\n\r\n        // Handle special string-based conditions\r\n        if (key === 'timeOfDay') {\r\n            const gameTime = (chunk as any).gameTime;\r\n            // We need world settings to determine day/night, but chunk doesn't have it.\r\n            // For now, we'll assume default day/night cycle for offline mode.\r\n            // In a real game, this would be passed down from a global game state or settings.\r\n            const defaultStartTime = 360; // 6 AM\r\n            const defaultDayDuration = 1440; // 24 hours\r\n            if (gameTime === undefined) continue;\r\n            const isCurrentDay = isDay(gameTime, defaultStartTime, defaultDayDuration);\r\n            if (conditionValue === 'day' && !isCurrentDay) return false;\r\n            if (conditionValue === 'night' && isCurrentDay) return false;\r\n            continue;\r\n        }\r\n\r\n        if (key === 'soilType') {\r\n            if (Array.isArray(conditionValue) && !conditionValue.includes(chunk.soilType)) return false;\r\n            continue;\r\n        }\r\n\r\n        // Handle player-based conditions\r\n        if (key === 'playerHealth' && playerState) {\r\n            if (playerState.hp < (conditionValue.min ?? 0) || playerState.hp > (conditionValue.max ?? 100)) return false;\r\n            continue;\r\n        }\r\n\r\n        if (key === 'playerStamina' && playerState) {\r\n            if (playerState.stamina < (conditionValue.min ?? 0) || playerState.stamina > (conditionValue.max ?? 100)) return false;\r\n            continue;\r\n        }\r\n        \r\n        // Handle entity presence checks\r\n        if (key === 'requiredEntities') {\r\n            const { enemyType, itemType } = conditionValue;\r\n            let entityFound = false;\r\n            if (enemyType && chunk.enemy && chunk.enemy.type && getTranslatedText(chunk.enemy.type, 'vi') === enemyType) {\r\n                entityFound = true;\r\n            }\r\n            if (itemType && !entityFound) {\r\n                if (chunk.items.some(item => getTranslatedText(item.name, 'vi') === itemType)) {\r\n                    entityFound = true;\r\n                }\r\n            }\r\n            if (!entityFound && (enemyType || itemType)) return false;\r\n            continue;\r\n        }\r\n\r\n        // Handle generic numerical range conditions\r\n        if (typeof chunkValue === 'number' && typeof conditionValue === 'object' && conditionValue !== null) {\r\n            if (chunkValue < (conditionValue.min ?? -Infinity) || chunkValue > (conditionValue.max ?? Infinity)) return false;\r\n        }\r\n    }\r\n\r\n    return true; // Tß║Ñt cß║ú ─æiß╗üu kiß╗çn ─æß╗üu ─æ╞░ß╗úc ─æ├íp ß╗⌐ng\r\n};\r\n\r\nexport const has_mood_overlap = (template_moods: MoodTag[], current_moods: MoodTag[]): boolean => {\r\n    if (!template_moods || template_moods.length === 0) return true; \r\n    if (!current_moods || current_moods.length === 0) return false;\r\n    return template_moods.some(mood => current_moods.includes(mood));\r\n};\r\n\r\nexport const select_template_by_weight = (templates: NarrativeTemplate[]): NarrativeTemplate => {\r\n    if (templates.length === 0) throw new Error(\"No templates provided for weighted selection.\");\r\n    const totalWeight = templates.reduce((sum, tmpl) => sum + (tmpl.weight || 0.5), 0);\r\n    let randomNum = Math.random() * totalWeight;\r\n\r\n    for (const tmpl of templates) {\r\n        randomNum -= (tmpl.weight || 0.5);\r\n        if (randomNum <= 0) return tmpl;\r\n    }\r\n    return templates[0];\r\n};\r\n\r\nexport const fill_template = (\r\n    template_string: string,\r\n    chunk: Chunk,\r\n    world: World,\r\n    playerPosition: { x: number; y: number; },\r\n    t: (key: TranslationKey, replacements?: any) => string,\r\n    language: Language,\r\n    playerState?: PlayerStatus\r\n): string => {\r\n    let filled_template = template_string;\r\n    const currentBiomeName: string = chunk.terrain;\r\n    // Lookup biome templates in a case-insensitive and flexible way to handle dataset/casing differences.\r\n    let biomeTemplateData = biomeNarrativeTemplates[currentBiomeName];\r\n    if (!biomeTemplateData) {\r\n        const lower = currentBiomeName.toLowerCase();\r\n        biomeTemplateData = biomeNarrativeTemplates[lower] || biomeNarrativeTemplates[currentBiomeName.charAt(0).toUpperCase() + currentBiomeName.slice(1)];\r\n    }\r\n    if (!biomeTemplateData) {\r\n        // Fallback: try to find a template whose declared terrain matches case-insensitively\r\n        biomeTemplateData = Object.values(biomeNarrativeTemplates).find((b: any) => b && b.terrain && String(b.terrain).toLowerCase() === String(currentBiomeName).toLowerCase()) as any;\r\n    }\r\n\r\n    if (!biomeTemplateData) {\r\n        logger.warn(`Placeholder data not found for ${chunk.terrain}`);\r\n        return template_string;\r\n    }\r\n\r\n    filled_template = filled_template.replace(/{{(.*?)}}/g, (match, p1) => {\r\n        const key = p1.trim();\r\n        const category =\r\n            (biomeTemplateData.adjectives as any)[key] ||\r\n            (biomeTemplateData.features as any)[key] ||\r\n            (biomeTemplateData.smells as any)[key] ||\r\n            (biomeTemplateData.sounds as any)[key] ||\r\n            (biomeTemplateData.sky ? (biomeTemplateData.sky as any)[key] : undefined);\r\n        if (category && Array.isArray(category) && category.length > 0) {\r\n            return category[Math.floor(Math.random() * category.length)];\r\n        }\r\n        logger.warn(`Placeholder category not found or empty: ${p1}`); \r\n        return match; \r\n    });\r\n    \r\n    filled_template = filled_template.replace('{light_level_detail}', () => chunk.lightLevel <= 10 ? t('light_level_dark') : chunk.lightLevel < 50 ? t('light_level_dim') : t('light_level_normal'));\r\n    filled_template = filled_template.replace('{temp_detail}', () => chunk.temperature && chunk.temperature <= 20 ? t('temp_cold') : chunk.temperature && chunk.temperature >= 80 ? t('temp_hot') : t('temp_mild'));\r\n    filled_template = filled_template.replace('{moisture_detail}', () => chunk.moisture >= 80 ? t('moisture_humid') : chunk.moisture <= 20 ? t('moisture_dry') : t('moisture_normal'));\r\n    filled_template = filled_template.replace('{jungle_feeling_dark}', t('jungle_feeling_dark_phrase'));\r\n    filled_template = filled_template.replace(/{enemy_name}/g, chunk.enemy && chunk.enemy.type ? getTranslatedText(chunk.enemy.type, language, t) : t('no_enemy_found'));\r\n    filled_template = filled_template.replace(/{item_found}/g, chunk.items && chunk.items.length > 0 ? getTranslatedText(chunk.items[Math.floor(Math.random() * chunk.items.length)].name, language, t) : t('no_item_found'));\r\n\r\n    if (playerState) {\r\n        filled_template = filled_template.replace('{player_health_status}', playerState.hp < 30 ? t('player_health_low') : t('player_health_normal'));\r\n        filled_template = filled_template.replace('{player_stamina_status}', playerState.stamina < 30 ? t('player_stamina_low') : t('player_stamina_normal'));\r\n    }\r\n\r\n    return filled_template;\r\n};\r\n\r\n// --- CORE OFFLINE NARRATIVE FUNCTIONS ---\r\n\r\nexport const generateOfflineNarrative = (\r\n    currentChunk: Chunk,\r\n    narrativeLength: NarrativeLength,\r\n    world: World,\r\n    playerPosition: { x: number; y: number; },\r\n    t: (key: TranslationKey, replacements?: any) => string,\r\n    language: Language,\r\n    playerState?: PlayerStatus\r\n): string => {\r\n    const currentBiomeName: string = currentChunk.terrain;\r\n    const currentBiomeData = biomeNarrativeTemplates[currentBiomeName];\r\n\r\n    if (!currentBiomeData) {\r\n        logger.warn(`[generateOfflineNarrative] No biome template data found for: ${currentBiomeName}`);\r\n        return currentChunk.description || \"An unknown area.\";\r\n    }\r\n\r\n    const currentMoods = analyze_chunk_mood(currentChunk);\r\n\r\n    const narrativeTemplates = (\r\n        currentBiomeData && Array.isArray(currentBiomeData.descriptionTemplates)\r\n    ) ? currentBiomeData.descriptionTemplates : [];\r\n\r\n    let candidateTemplates = narrativeTemplates.filter((tmpl: NarrativeTemplate) => {\r\n        return tmpl && typeof tmpl === 'object' && !Array.isArray(tmpl) && 'id' in tmpl && 'template' in tmpl &&\r\n               has_mood_overlap(tmpl.mood, currentMoods) && check_conditions(tmpl.conditions, currentChunk, playerState);\r\n    });\r\n    \r\n    if (candidateTemplates.length === 0) {\r\n        candidateTemplates = narrativeTemplates.filter((tmpl: NarrativeTemplate) => tmpl && tmpl.mood && tmpl.mood.length === 0);\r\n    }\r\n    if (candidateTemplates.length === 0) return currentChunk.description;\r\n\r\n    const { min_s, max_s } = get_sentence_limits(narrativeLength);\r\n    // Choose a target sentence count within the allowed range so that\r\n    // changing the narrativeLength actually affects how verbose the output is.\r\n    const targetSentences = Math.max(min_s, Math.min(max_s, Math.floor(Math.random() * (max_s - min_s + 1)) + min_s));\r\n    let finalSentences: string[] = [];\r\n    let sentenceCount = 0;\r\n\r\n    const openingTemplates = candidateTemplates.filter(t => t.type === 'Opening');\r\n    if (openingTemplates.length > 0) {\r\n        const chosen = select_template_by_weight(openingTemplates);\r\n        finalSentences.push(fill_template(chosen.template, currentChunk, world, playerPosition, t, language, playerState));\r\n        sentenceCount++;\r\n    }\r\n\r\n    const detailTemplates = candidateTemplates.filter(t => t.type === 'EnvironmentDetail' || t.type === 'SensoryDetail');\r\n    // Helper: synthesize a condition-aware detail sentence when templates are sparse\r\n    const synthesizeDetailSentence = () => {\r\n        try {\r\n            const kv = getKeywordVariations(language);\r\n            // Score prominence for temperature/moisture/light\r\n            const scores: { key: string; score: number }[] = [];\r\n            if (typeof currentChunk.temperature === 'number') {\r\n                const temp = currentChunk.temperature;\r\n                const score = Math.abs(temp - 50) + (temp >= 80 || temp <= 10 ? 20 : 0);\r\n                scores.push({ key: 'temperature', score });\r\n            }\r\n            if (typeof currentChunk.moisture === 'number') {\r\n                const m = currentChunk.moisture;\r\n                const score = Math.abs(m - 50) + (m >= 80 || m <= 20 ? 15 : 0);\r\n                scores.push({ key: 'moisture', score });\r\n            }\r\n            if (typeof currentChunk.lightLevel === 'number') {\r\n                const l = currentChunk.lightLevel;\r\n                const score = Math.abs((l <= 0 ? 0 - l : 100 - l)) + (l <= 10 ? 10 : 0);\r\n                scores.push({ key: 'light', score });\r\n            }\r\n            // Determine primary condition\r\n            scores.sort((a, b) => b.score - a.score);\r\n            const primary = scores[0]?.key;\r\n\r\n            // pick an adjective from kv if available\r\n            let adj = '';\r\n            if (primary === 'temperature' && kv.temp_adj) {\r\n                if (typeof currentChunk.temperature === 'number' && currentChunk.temperature >= 80) adj = selectRandom((kv.temp_adj as any).hot as string[]);\r\n                else if (typeof currentChunk.temperature === 'number' && currentChunk.temperature <= 10) adj = selectRandom((kv.temp_adj as any).cold as string[]);\r\n                else adj = selectRandom((kv.temp_adj as any).mild as string[]);\r\n            } else if (primary === 'moisture' && kv.moisture_adj) {\r\n                if (typeof currentChunk.moisture === 'number' && currentChunk.moisture >= 80) adj = selectRandom((kv.moisture_adj as any).high as string[]);\r\n                else if (typeof currentChunk.moisture === 'number' && currentChunk.moisture <= 20) adj = selectRandom((kv.moisture_adj as any).low as string[]);\r\n                else adj = selectRandom((kv.moisture_adj as any).medium as string[]);\r\n            } else if (primary === 'light' && kv.light_adj) {\r\n                if (typeof currentChunk.lightLevel === 'number' && currentChunk.lightLevel <= 10) adj = selectRandom((kv.light_adj as any).dark as string[]);\r\n                else if (typeof currentChunk.lightLevel === 'number' && currentChunk.lightLevel <= 40) adj = selectRandom((kv.light_adj as any).medium as string[]);\r\n                else adj = selectRandom((kv.light_adj as any).bright as string[]);\r\n            }\r\n\r\n            // Feature: prefer biome feature, then enemy, then item\r\n            let featureText = '';\r\n            if (currentBiomeData && currentBiomeData.features && Object.keys(currentBiomeData.features).length > 0) {\r\n                // pick first non-empty feature list\r\n                const keys = Object.keys(currentBiomeData.features);\r\n                for (const k of keys) {\r\n                    const arr = (currentBiomeData.features as any)[k];\r\n                    if (Array.isArray(arr) && arr.length > 0) { featureText = selectRandom(arr as string[]); break; }\r\n                }\r\n            }\r\n            if (!featureText) {\r\n                if (currentChunk.enemy && currentChunk.enemy.type) featureText = getTranslatedText(currentChunk.enemy.type, language, t);\r\n                else if (currentChunk.items && currentChunk.items.length > 0) featureText = getTranslatedText(currentChunk.items[0].name, language, t);\r\n            }\r\n\r\n            const patternsEn = [\r\n                `You notice ${featureText || 'something'}. ${adj}`,\r\n                `${adj} ΓÇö you catch sight of ${featureText || 'something nearby'}.`,\r\n                `As you move, ${adj} and ${featureText ? `you see ${featureText}` : 'there is a change in the scene'}.`,\r\n                `You step forward; ${featureText ? `${featureText} comes into view` : 'the surroundings shift'}, ${adj}.`,\r\n                `${featureText ? featureText + ',' : ''} ${adj}`\r\n            ];\r\n            const patternsVi = [\r\n                `${featureText || 'mß╗Öt thß╗⌐ g├¼ ─æ├│'} ─æ╞░ß╗úc ch├║ ├╜. ${adj}`,\r\n                `${adj} ΓÇö bß║ín chß╗út thß║Ñy ${featureText || 'mß╗Öt ─æiß╗üu g├¼ ─æ├│'}.`,\r\n                `Khi bß║ín tiß║┐n l├¬n, ${adj} v├á ${featureText ? `bß║ín nh├¼n thß║Ñy ${featureText}` : 'cß║únh vß║¡t thay ─æß╗òi'}.`,\r\n                `Bß║ín tiß║┐n th├¬m mß╗Öt b╞░ß╗¢c; ${featureText ? `${featureText} hiß╗çn ra` : 'cß║únh vß║¡t thay ─æß╗òi'}, ${adj}.`,\r\n                `${featureText ? featureText + ',' : ''} ${adj}`\r\n            ];\r\n\r\n            const picks = language === 'vi' ? patternsVi : patternsEn;\r\n            return picks[Math.floor(Math.random() * picks.length)];\r\n        } catch (e) {\r\n            // fallback to a simple sensory phrase\r\n            if (currentChunk.temperature && currentChunk.temperature >= 80) return t('temp_hot') || 'it is hot';\r\n            if (currentChunk.lightLevel && currentChunk.lightLevel <= 10) return t('light_level_dark') || 'it is dark';\r\n            return '';\r\n        }\r\n    };\r\n\r\n    while (sentenceCount < targetSentences && detailTemplates.length > 0) {\r\n        // If templates are sparse or to inject more varied phrasing, synthesize a sentence\r\n        if (detailTemplates.length < 3 || Math.random() < 0.4) {\r\n            finalSentences.push(synthesizeDetailSentence());\r\n            sentenceCount++;\r\n            continue;\r\n        }\r\n        const chosen = select_template_by_weight(detailTemplates);\r\n        finalSentences.push(fill_template(chosen.template, currentChunk, world, playerPosition, t, language, playerState));\r\n        sentenceCount++;\r\n        const index = detailTemplates.indexOf(chosen);\r\n        if (index > -1) detailTemplates.splice(index, 1);\r\n    }\r\n\r\n    return SmartJoinSentences(finalSentences, narrativeLength);\r\n};\r\n\r\n\r\nexport const generateOfflineActionNarrative = (\r\n    actionType: string,\r\n    actionResult: any,\r\n    currentChunk: Chunk,\r\n    t: (key: TranslationKey, replacements?: any) => string,\r\n    language: Language,\r\n) => {\r\n    let narrativeKey: TranslationKey = '';\r\n    let replacements: any = {};\r\n    const enemyType = currentChunk.enemy && currentChunk.enemy.type ? getTranslatedText(currentChunk.enemy.type, language, t) : ' ╤ü╤â╤ë╨╡╤ü╤é╨▓╨╛';\r\n    const sensoryFeedbackOptions = [\r\n        `sensoryFeedback_${currentChunk.temperature && currentChunk.temperature > 80 ? 'hot' : 'cold'}`,\r\n        `sensoryFeedback_${currentChunk.lightLevel < 20 ? 'dark' : 'normal'}`,\r\n        `sensoryFeedback_${currentChunk.moisture > 70 ? 'rain' : 'normal'}`\r\n    ];\r\n    const sensory_feedback = t(sensoryFeedbackOptions[Math.floor(Math.random() * sensoryFeedbackOptions.length)]);\r\n\r\n    switch (actionType) {\r\n    case 'attack':\r\n            // Map SuccessLevel values to existing locale suffixes\r\n            const succ = actionResult.successLevel;\r\n            const suffixMap: Record<string, string> = {\r\n                CriticalFailure: 'critFail',\r\n                Failure: 'fail',\r\n                Success: 'success',\r\n                GreatSuccess: 'success', // No separate GreatSuccess key; use 'success'\r\n                CriticalSuccess: 'critSuccess'\r\n            };\r\n            const suffix = suffixMap[succ] ?? succ.toLowerCase();\r\n            narrativeKey = `actionNarrative_attack_${suffix}`;\r\n            let attack_description = t(`attackNarrative_${suffix}`, { enemyType });\r\n            let damage_report = actionResult.playerDamage > 0 ? t('attackDamageDealt', { damage: actionResult.playerDamage }) : '';\r\n            let enemy_reaction = '';\r\n            \r\n            \r\n            \r\n            \r\n            if (actionResult.enemyDefeated) {\r\n                enemy_reaction = t('enemyDefeatedNarrative', { enemyType });\r\n            } else if (actionResult.fled) {\r\n                enemy_reaction = t('enemyFledNarrative', { enemyType });\r\n            } else if (actionResult.enemyDamage > 0) {\r\n                enemy_reaction = t('enemyRetaliationNarrative', { enemyType, damage: actionResult.enemyDamage });\r\n            } else {\r\n                enemy_reaction = t('enemyPreparesNarrative', { enemyType });\r\n            }\r\n            replacements = { attack_description, damage_report, sensory_feedback, enemy_reaction };\r\n            break;\r\n        case 'useItem':\r\n            if (actionResult.target === 'player') {\r\n                narrativeKey = actionResult.wasUsed ? 'itemUsePlayerSuccessNarrative' : 'itemUsePlayerFailNarrative';\r\n                replacements = { item: getTranslatedText(actionResult.itemName, language, t), effect: actionResult.effectDescription, sensory_feedback };\r\n            } else {\r\n                narrativeKey = actionResult.wasTamed ? 'itemTameSuccessNarrative' : 'itemTameFailNarrative';\r\n                replacements = { item: getTranslatedText(actionResult.itemName, language, t), target: getTranslatedText(actionResult.target, language, t), sensory_feedback };\r\n            }\r\n            break;\r\n        case 'useSkill':\r\n            const skillName = getTranslatedText(actionResult.skill.name, language, t);\r\n            if (actionResult.successLevel === 'CriticalFailure') {\r\n                narrativeKey = 'skillCritFailNarrative';\r\n                replacements = { skillName, damage: actionResult.backfireDamage, sensory_feedback };\r\n            } else if (actionResult.successLevel === 'Failure') {\r\n                narrativeKey = 'skillFailNarrative';\r\n                replacements = { skillName, sensory_feedback };\r\n            } else {\r\n                if (actionResult.skill.effect.type === 'HEAL') {\r\n                    narrativeKey = 'skillHealSuccessNarrative';\r\n                    replacements = { skillName, amount: actionResult.healedAmount, sensory_feedback };\r\n                } else if (actionResult.skill.effect.type === 'DAMAGE') {\r\n                    let narrative = t('skillDamageSuccessNarrative', { skillName, enemy: enemyType, damage: actionResult.finalDamage, sensory_feedback });\r\n                    if (actionResult.siphonedAmount) {\r\n                        narrative += ' ' + t('skillSiphonNarrative', { amount: actionResult.siphonedAmount });\r\n                    }\r\n                    return narrative;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n\r\n    if (!narrativeKey) return \"An unknown action occurred.\";\r\n    return t(narrativeKey, replacements);\r\n};\r\n\r\n\r\n/**\r\n * Handle a player's 'search' / 'explore' action inside a chunk.\r\n *\r\n * The search action uses biome templates (natural candidates) plus a small\r\n * sampled set of non-natural (spawnEnabled=false) items so that players can\r\n * occasionally discover crafted/rare items via searching. Search is intentionally\r\n * more generous than passive natural spawn: a modest `searchBoost` increases\r\n * the effective chance, but non-natural finds are capped to avoid being overpowered.\r\n *\r\n * Implementation details:\r\n * - Natural candidates use their defined `conditions.chance` or a sensible\r\n *   default. Non-natural candidates are given a very small base chance (e.g. 0.02).\r\n * - The function applies a softcapped `spawnMultiplier` before calculating\r\n *   the final chance for the search. A `searchBoost` (>1) is applied to make\r\n *   searching more effective than passive discovery.\r\n * - Non-natural items' final chance is capped (e.g. <= 0.3) so search cannot\r\n *   trivially expose high-tier crafted items every time.\r\n *\r\n * @param currentChunk - Current chunk state where the search occurs.\r\n * @param actionId - The id of the search action (removed from chunk.actions after use).\r\n * @param language - Language code for localized narrative text.\r\n * @param t - Translation function used to build narrative strings.\r\n * @param allItemDefinitions - Registry of item definitions used to resolve found items.\r\n * @param rng - Random integer helper for quantity selection.\r\n * @param spawnMultiplier - Optional multiplier to scale search find-chance (softcapped). Default: 1.\r\n * @returns An object containing the updated chunk, narrative string, and optional toast info.\r\n */\r\nexport const handleSearchAction = (\r\n    currentChunk: Chunk,\r\n    actionId: number,\r\n    language: Language,\r\n    t: (key: TranslationKey, replacements?: any) => string,\r\n    allItemDefinitions: Record<string, ItemDefinition>,\r\n    rng: (range: { min: number, max: number }) => number,\r\n    /** Optional multiplier to scale search find-chance (softcapped). */\r\n    spawnMultiplier: number = 1\r\n) => {\r\n    let newChunk = { ...currentChunk, items: [...currentChunk.items] };\r\n    newChunk.actions = newChunk.actions.filter(a => a.id !== actionId);\r\n\r\n    const templates = getTemplates(language);\r\n    const biomeTemplates = templates[currentChunk.terrain];\r\n    if (!biomeTemplates || !biomeTemplates.items) {\r\n        return { newChunk, narrative: t('exploreFoundNothing'), toastInfo: null };\r\n    }\r\n\r\n    const possibleItems = biomeTemplates.items.filter((itemTmpl: any) => {\r\n        const itemDef = allItemDefinitions[itemTmpl.name];\r\n        return itemDef && check_conditions(itemTmpl.conditions, currentChunk);\r\n    });\r\n\r\n    if (possibleItems.length > 0) {\r\n        // Build a combined candidate pool that includes both natural biome items\r\n        // and a small sampled set of non-natural (spawnEnabled=false) items so\r\n        // searches can sometimes find rarer or crafted-only gear (but not too often).\r\n        const extraCandidates = Object.keys(allItemDefinitions)\r\n            .filter(k => !allItemDefinitions[k].spawnEnabled)\r\n            .sort(() => 0.5 - Math.random())\r\n            .slice(0, 3)\r\n            .map(name => ({ name, conditions: { chance: 0.02 }, __isNatural: false }));\r\n\r\n        const naturalCandidates = possibleItems.map((t: any) => ({ ...t, __isNatural: true }));\r\n        const allCandidates = [...naturalCandidates, ...extraCandidates];\r\n\r\n        // Compute final chance per candidate and perform per-candidate roll.\r\n        // This ensures we use each candidate's own base chance and correctly apply\r\n        // multipliers, search boost, and non-natural caps when evaluating finds.\r\n        const softcap = (m: number, k = 0.4) => m <= 1 ? m : m / (1 + (m - 1) * k);\r\n        const effectiveMultiplier = softcap(spawnMultiplier);\r\n        const searchBoost = 1.4; // make search more generous than passive discovery\r\n\r\n        // Shuffle candidates to avoid ordering bias when multiple have similar chances.\r\n        const shuffledCandidates = allCandidates.sort(() => 0.5 - Math.random());\r\n        let chosen: any = null;\r\n        for (const c of shuffledCandidates) {\r\n            const baseChance = c.conditions?.chance ?? (c.__isNatural ? 0.5 : 0.02);\r\n            let finalChance = Math.min(0.95, baseChance * effectiveMultiplier * searchBoost);\r\n            if (!c.__isNatural) finalChance = Math.min(0.3, finalChance); // cap non-natural finds\r\n            // If this candidate passes its own roll, select it and stop.\r\n            if (Math.random() < finalChance) {\r\n                chosen = c;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (chosen) {\r\n            const foundItemTemplate = chosen;\r\n            const itemDef = allItemDefinitions[foundItemTemplate.name];\r\n            const quantity = itemDef ? rng(itemDef.baseQuantity) : rng({ min: 1, max: 1 });\r\n        \r\n        const existingItem = newChunk.items.find(i => (\r\n            // prefer explicit id if present\r\n            (i as any).id === foundItemTemplate.name ||\r\n            // resolve item's name to canonical id\r\n            resolveItemId(i.name, allItemDefinitions) === foundItemTemplate.name ||\r\n            // legacy fallback: english name\r\n            getTranslatedText(i.name, 'en') === foundItemTemplate.name\r\n        ));\r\n        if (existingItem) {\r\n            existingItem.quantity += quantity;\r\n        } else {\r\n            newChunk.items.push({\r\n                name: itemDef.name,\r\n                description: itemDef.description,\r\n                quantity,\r\n                tier: itemDef.tier,\r\n                emoji: itemDef.emoji,\r\n            });\r\n        }\r\n        \r\n            const itemName = getTranslatedText(foundItemTemplate.name, language, t);\r\n        return {\r\n            newChunk,\r\n            narrative: t('exploreFoundItemsNarrative', { items: `${quantity} ${itemName}` }),\r\n            toastInfo: {\r\n                title: 'exploreSuccessTitle',\r\n                description: 'exploreFoundItems',\r\n                params: { items: `${quantity} ${itemName}` }\r\n            }\r\n        };\r\n        }\r\n    }\r\n\r\n    return { newChunk, narrative: t('exploreFoundNothing'), toastInfo: null };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\region-generation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\weather-generation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\engine\\world-generation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\item-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\movement-narrative.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":36,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":46,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":54,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":54,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":60,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":110,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import movementTemplates from './movement-templates';\r\nimport type { PlayerStatus, Chunk } from '@/lib/game/types';\r\nimport { itemDefinitions } from '@/lib/game/items';\r\nimport { getTranslatedText } from '@/lib/utils';\r\n\r\ntype SelectArgs = {\r\n  chunk: Chunk;\r\n  playerStats: PlayerStatus;\r\n  directionText: string;\r\n  language?: string;\r\n  briefSensory?: string;\r\n};\r\n/**\r\n * Heuristic: does the player have any light-source in their inventory?\r\n * Conservative, best-effort check using itemDefinitions and translated names.\r\n */\r\nfunction hasLightSource(playerStats: PlayerStatus): boolean {\r\n  try {\r\n    const items = (playerStats as any)?.inventory || (playerStats as any)?.items || [];\r\n    if (!Array.isArray(items)) return false;\r\n\r\n    // Build a set of known light-source keys from the master itemDefinitions.\r\n    const lightKeys = new Set<string>();\r\n    for (const k of Object.keys(itemDefinitions)) {\r\n      try {\r\n        const def: any = (itemDefinitions as any)[k];\r\n        const nameEn = (def && def.name && (def.name.en || def.name)) ? String(def.name.en || def.name).toLowerCase() : '';\r\n        const descEn = (def && def.description && (def.description.en || def.description)) ? String(def.description.en || def.description).toLowerCase() : '';\r\n        if (k.toLowerCase().includes('torch') || k.toLowerCase().includes('lantern') || k.toLowerCase().includes('lamp') || k.toLowerCase().includes('candle') || k.toLowerCase().includes('firefly')) {\r\n          lightKeys.add(k);\r\n        }\r\n        // Some items are identified by their name/description instead of key\r\n        if (nameEn.includes('torch') || nameEn.includes('lantern') || nameEn.includes('lamp') || descEn.includes('light') || nameEn.includes('candle')) {\r\n          lightKeys.add(k);\r\n        }\r\n      } catch (_e) {\r\n        // ignore problematic item definitions\r\n      }\r\n    }\r\n\r\n    // Check player's inventory for any item that matches a known light key or has a translated name indicating light\r\n    return items.some((i: any) => {\r\n      try {\r\n        const display = String(getTranslatedText(i?.name || i?.displayName || i?.label || '', 'en') || '').toLowerCase();\r\n        if (display.includes('torch') || display.includes('lantern') || display.includes('lamp') || display.includes('candle') || display.includes('firefly')) return true;\r\n      } catch (_e) {\r\n        // ignore\r\n      }\r\n      // As a final fallback, compare translated display against itemDefinitions names\r\n      for (const k of lightKeys) {\r\n        const defName = (itemDefinitions as any)[k]?.name?.en;\r\n        try {\r\n          if (defName && String(defName).toLowerCase() === String(getTranslatedText(i?.name || '', 'en')).toLowerCase()) return true;\r\n        } catch (_e) {\r\n          // ignore\r\n        }\r\n      }\r\n      return false;\r\n    });\r\n  } catch (_e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction matchesConditions(conds: any, chunk: Chunk, playerStats: PlayerStatus) {\r\n  if (!conds || Object.keys(conds).length === 0) return true;\r\n  if (typeof conds.lightMax === 'number') {\r\n    if (typeof chunk.lightLevel !== 'number' || chunk.lightLevel > conds.lightMax) return false;\r\n  }\r\n  if (conds.requireNoLight) {\r\n    if (hasLightSource(playerStats)) return false;\r\n  }\r\n  if (typeof conds.moistureMin === 'number') {\r\n    if (typeof chunk.moisture !== 'number' || chunk.moisture < conds.moistureMin) return false;\r\n  }\r\n  if (typeof conds.temperatureMax === 'number') {\r\n    if (typeof chunk.temperature !== 'number' || chunk.temperature > conds.temperatureMax) return false;\r\n  }\r\n  if (typeof conds.staminaBelow === 'number') {\r\n    if (typeof playerStats.stamina !== 'number' || playerStats.stamina >= conds.staminaBelow) return false;\r\n  }\r\n  if (typeof conds.hpBelow === 'number') {\r\n    if (typeof playerStats.hp !== 'number' || playerStats.hp >= conds.hpBelow) return false;\r\n  }\r\n  if (typeof conds.terrainEquals === 'string') {\r\n    if (String(chunk.terrain).toLowerCase() !== String(conds.terrainEquals).toLowerCase()) return false;\r\n  }\r\n  if (typeof conds.weather === 'string') {\r\n    // chunk may include weather info under chunk.weatherZone or similar; try common keys\r\n    const wk = (chunk as any).weather || (chunk as any).weatherZone || (chunk as any).currentWeather;\r\n    if (!wk || String(wk).toLowerCase() !== String(conds.weather).toLowerCase()) return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function selectMovementNarrative({ chunk, playerStats, directionText, language = 'en', briefSensory = '' }: SelectArgs): string | undefined {\r\n  try {\r\n    const lang = (language && String(language).startsWith('vi')) ? 'vi' : 'en';\r\n    const pool = (movementTemplates as any)[lang] || (movementTemplates as any)['en'];\r\n    // Find first matching non-default template (priority order)\r\n    for (const tpl of pool) {\r\n      if (tpl.id === 'default') continue;\r\n      if (matchesConditions(tpl.conditions || {}, chunk, playerStats)) {\r\n        return (tpl.template || '').replace('{direction}', String(directionText)).replace('{brief_sensory}', String(briefSensory || '')).replace('{biome}', String(chunk.terrain || ''));\r\n      }\r\n    }\r\n    // fallback to default\r\n    const def = pool.find((p: any) => p.id === 'default');\r\n    if (def) return def.template.replace('{direction}', String(directionText)).replace('{brief_sensory}', String(briefSensory || '')).replace('{biome}', String(chunk.terrain || ''));\r\n  } catch (e) {\r\n    // ignore errors and fallback to caller behavior\r\n  }\r\n  return undefined;\r\n}\r\n\r\nexport default selectMovementNarrative;\r\n","usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\movement-templates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\normalize.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\ports\\game-state.repository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\recipes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\schemas\\narrativeSchema.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\skills.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\structures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\beach.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\cave.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\city.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\corrupted.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\desert.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\floating.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\floptropica.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\forest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\grassland.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\jungle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\mesa.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\modded\\nature_plus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\mountain.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\mushroom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\ocean.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\space_station.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\swamp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\tundra.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\underwater.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\volcanic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\wall.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\templates\\weapons.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\time\\time-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\types\\enemy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\weatherPresets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\game\\world-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\creatures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\events.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\examples.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\gameplay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\items.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\narrative.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\premade-worlds.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\recipes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\skills.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\structures.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\ui-vi-complements.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\ui.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\locales\\weather.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\__tests__\\condition.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\__tests__\\continuation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\__tests__\\rng.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\__tests__\\selector.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\__tests__\\state-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\__tests__\\voice-continuation.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\assembler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\cache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\condition.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\lexicon.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\loader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\orchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\rng.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\runtime-orchestrator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\schemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\selector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\narrative\\state-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"D:\\dreamland-engine\\src\\lib\\utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
